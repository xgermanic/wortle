<!DOCTYPE html>
<html lang="en">
<head>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-check-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-functions-compat.js"></script>
<script src="definitions.js"></script>
<script src="theme.js"></script>
<link rel="icon" type="image/x-icon" href="/wortle/images/favicon.ico">
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Sansita:ital,wght@1,700&display=swap" rel="stylesheet">
<title>WØRTLE</title>

  <link id="theme-stylesheet" rel="stylesheet" href="style-light.css">
  <style>

@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap');

    #mainContent { 
      visibility: hidden;
 }
    /* ADD THIS RULE FOR DISABLED INPUTS */
  input:disabled {
    opacity: 1;
    cursor: not-allowed;
  }
  .disabled-container, .disabled-container * {
  opacity: 1;
  cursor: not-allowed !important;
}
/* ADD THESE RULES FOR THE MINI-KEYBOARD */
  .mini-keyboard {
    margin: 2px 0 !important;
    max-width: 500px; /* Limit width */
    align-self: center; /* Center it */
  }
  .mini-keyboard .key {
    width: 22px; /* Adjust key size */
    height: 28px;
    font-size: 11pt;
    padding: 0;
    background-color: var(--bg-keyboard);
    border: 0px solid var(--border-subtle);
  }
  /* This container allows us to position the '?' icon relative to the input */
  .input-with-tooltip-container {
    position: relative;
    display: flex;
    justify-content: center;
    width: 100%;
    padding:0;
    margin: 4px 0;
    max-width: 500px; /* Ensures it matches other inputs */
  }

  /* The '?' icon itself */
  .tooltip-trigger {
    position: absolute;
    top: 50%;
    right: 23%; /* Position it just outside the container */
    transform: translateY(-50%);
    background-color: #888;
    color: white;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: bold;
    cursor: help;
    user-select: none; /* Prevents selecting the '?' text */
  }

  /* The tooltip text box (hidden by default) */
  .tooltip-trigger .tooltip-text {
    visibility: hidden;
    opacity: 0;
    width: 240px;
    background-color: #333;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 10px;
    position: absolute;
    z-index: 10;
    bottom: 150%; /* Position it above the '?' */
    left: 50%;
    transform: translateX(-50%);
    transition: opacity 0.2s;
    font-weight: normal;
    line-height: 1.4;
  }

  /* Creates the small arrow pointing down from the tooltip */
  .tooltip-trigger .tooltip-text::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: #333 transparent transparent transparent;
  }

  /* Show the tooltip when hovering over the '?' icon */
  .tooltip-trigger:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
  }

  /* Make the label a container for our custom checkbox */
  label.custom-checkbox-label {
    position: relative;
    padding-left: 0px; /* Leave space for the custom checkbox */
    line-height: 18px;  /* Align text vertically */
  }

  /* Hide the default browser checkbox */
  label.custom-checkbox-label .specialCharCheckbox {
    position: absolute;
    opacity: 0;
    height: 0;
    width: 0;
  }

  /* Create a new, stylable checkbox box */
  .custom-checkmark {
    position: absolute;
    top: 0;
    left: 35%;
    height: 16px;
    width: 16px;
    background-color: #eee;
    border: 1px solid #888888;
    border-radius: 3px;
  }
  
  /* When the hidden checkbox is checked, color our custom box blue */
  label.custom-checkbox-label .specialCharCheckbox:checked ~ .custom-checkmark {
    background-color: #2196F3; /* This is our blue color */
    border-color: #2196F3;
  }

  /* Create the checkmark (hidden by default) */
  .custom-checkmark:after {
    content: "";
    position: absolute;
    display: none;
  }

  /* Show the checkmark when the box is checked */
  label.custom-checkbox-label .specialCharCheckbox:checked ~ .custom-checkmark:after {
    display: block;
  }

  /* Style the checkmark itself */
  label.custom-checkbox-label .custom-checkmark:after {
    left: 5px;
    top: 2px;
    width: 4px;
    height: 8px;
    border: solid white;
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }
/* The dark background overlay */
.language-popup-overlay {
  visibility: hidden;
  opacity: 0;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 10000;
  transition: opacity 0.3s ease;
}
.language-popup .close-btn {
  top:-28px;
}

/* The popup window itself */
.language-popup {
    width:300px;
    max-height: 500px;
    background-color: var(--bg-panel);
    border-top:20px solid var(--present-bg);
    border-radius:10px;
    padding: 30px;
    color: var(--text-primary);
    box-shadow: 0 5px 15px var(--shadow);
  visibility: hidden;
  opacity: 0;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.9);
  z-index: 10001;
  text-align: center;
  transition: opacity 0.3s ease, transform 0.3s ease;
}

/* The class that makes the popup visible */
.language-popup-overlay.show,
.language-popup.show {
  visibility: visible;
  opacity: 1;
}
.language-popup.show {
    transform: translate(-50%, -50%) scale(1);
}


/* Styling for elements inside the popup */
.language-popup-title {
  color: var(--text-primary);
  font-size: 16pt;
  font-weight:400;
  margin-top:0;
  font-family:monospace;
}
.language-popup-text {
    color: var(--text-primary);
    font-size: 11pt;
  margin-bottom: 20px;
  font-family:monospace;
}
.language-popup-input {
  width: 80%;
  padding:5px;
  border-radius:10px;
  font-family:monospace;
  border:2px solid var(--border-subtle);
  box-sizing: border-box; /* Important for padding */
}
.language-popup-button {
  margin-top: 20px;
  cursor: pointer;
  transition: background-color 0.2s;
}
.scoreboard-content-container {
  max-height: 400px;
  overflow:scroll;
}
/* REPLACE your old #account-sidebar-header and #account-sidebar-flag rules with these */
/* REPLACE your old #account-sidebar-title and #account-sidebar-flag rules with these */

/* This container is still just for alignment */
#account-sidebar-header {
  text-align: center;
}

/* Make the title the positioning container */
#account-sidebar-title {
  position: relative;
  display: inline-block;
  /* Add padding on BOTH sides to make space for the flag while keeping the text centered */
  padding: 0; 
}

/* Position the flag absolutely within the right padding of the title */
#account-sidebar-flag {
  position: absolute;
  right: -35px; /* Position inside the right padding */
    top: 60%;
    transform: translateY(-50%);
    font-size: 1.4rem;
}
/* ADD THIS RULE FOR THE NEW HINT MESSAGE */
  .hint-popup p, #hint-unlock-next-message {
    font-size: 0.9rem;
    font-style: italic;
    opacity: 0.8;
    margin-top: 15px;
    color: var(--text-secondary);
  }
/* ADD THESE RULES FOR THE LANGUAGE SWITCHER */
  .language-input-container {
    position: relative;
    display: flex;
    justify-content: center;
    width: 100%;
    max-width: 500px; /* Ensures it matches other inputs */
  }

  #switch-language-btn {
    display: none; /* Hidden by default */
    position: absolute;
    top: 48%;
    right: 23.5%;
    transform: translateY(-50%);
    background-color: transparent;
    border: none;
    color: #888888;
    width: 22px;
    height: 22px;
    border-radius: 50%;
    font-size: 26px;
    font-weight: bold;
    line-height: 15px;
    vertical-align: middle;
    cursor: pointer;
    transition: color 0.2s;
  }
  #switch-language-btn:hover {
    color: #555555;
  }
  #word-status-indicator.valid, #word-status-indicator.invalid {
    font-weight:bold;
  }
  .hard-mode-toggle-container {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  margin: 10px 0 0 0;
  letter-spacing: 1px;
  font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
  font-size: 12pt;
  color: var(--text-primary);
}
.toggle-switch {
  position: relative;
  display: inline-block;
  width: 44px;
  height: 24px;
}
.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 34px;
}
.slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}
input:checked + .slider {
  background-color: var(--correct-bg); /* Use your theme's 'correct' color */
}
input:checked + .slider:before {
  transform: translateX(20px);
}

  #account-stats-section {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 2px;
    text-align: center;
  }
  .stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }

    #account-sidebar {
    position: fixed;
    top: 0;
    right: -390px;
    width: 370px;
    height: 100%;
    }
    .modal {
      width:450px;
    }
    .modal-content {
      width:390px;
    }

#word-status-indicator {
    font-size: 8pt;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    font-family: sans-serif;
    height: 20px;
    margin-left: 10px;
    box-sizing: border-box;
}

    /* Style for the container span when the word is valid */
#word-status-indicator.valid {
  color: #28a745; /* A nice success green */
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

/* Style for the SVG icon itself */
#word-status-indicator.valid .checkmark-svg {
  width: 18px; /* Adjust size as needed */
  height: 18px;
  stroke: currentColor; /* Inherits the green color */
  stroke-width: 3;
  fill: none;
  stroke-linecap: round;
  stroke-linejoin: round;
  /* Add a pop-in animation */
  animation: pop-in 0.3s ease-out;
}

/* Keyframe animation for the pop-in effect */
@keyframes pop-in {
  0% {
    transform: scale(0.5);
    opacity: 0;
  }
  80% {
    transform: scale(1.1);
    opacity: 1;
  }
  100% {
    transform: scale(1);
  }
}
/* Style for the container span when the word is invalid */
#word-status-indicator.invalid {
  color: #dc3545; /* A standard error red */
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

/* Style for the SVG 'X' icon itself */
#word-status-indicator.invalid .x-svg {
  width: 18px; /* Adjust size as needed */
  height: 18px;
  stroke: currentColor; /* Inherits the red color */
  stroke-width: 3;
  fill: none;
  stroke-linecap: round;
  stroke-linejoin: round;
  animation: shake-in 0.4s ease-out; /* Add a shake animation */
}
    /* Style for the container span when the word is valid */
#word-status-indicator.word-taken{
  color: #e59400; /* A nice success green */
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

/* Style for the SVG icon itself */
#word-status-indicator.word-taken .clock-svg {
  width: 18px; /* Adjust size as needed */
  height: 18px;
  stroke: currentColor; /* Inherits the green color */
  stroke-width: 3;
  fill: none;
  stroke-linecap: round;
  stroke-linejoin: round;
  /* Add a pop-in animation */
  animation: pop-in 0.3s ease-out;
}
/* Keyframe animation for the shake effect */
@keyframes shake-in {
  0% { transform: translateX(0) scale(0.5); opacity: 0; }
  50% { transform: translateX(0) scale(1); opacity: 1; }
  60% { transform: translateX(-3px); }
  70% { transform: translateX(3px); }
  80% { transform: translateX(-3px); }
  90% { transform: translateX(3px); }
  100% { transform: translateX(0); }
}
#game {
  display: flex;
  flex-direction: column;
}
.hidden {
  display: none !important;
}
/* Add this to your stylesheet */
.game-list-item-no-link {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
  color: var(--text-primary);
  text-decoration: none;
}

/* Main CSS */
body {
  font-family: Trebuchet MS, Helvetica, Arial, sans-serif;
  text-align: center;
  margin: 0 auto;
      background-image: 
        linear-gradient(var(--scanline-color) 50%, transparent 50%), 
        linear-gradient(90deg, var(--scanline-color) 1px, transparent 1px);
      background-size: 100% 5px, 5px 100%;
}

h1, h2, h3 {
  font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
}

.dimmed {
  opacity: 0.5;
  pointer-events: none;
}

.board {
  display: grid;
  grid-template-rows: repeat(6, 1fr);
  gap: 5px;
  margin: 20px;
  transition: opacity 0.4s ease-in-out;
}

.row {
  display: grid;
  grid-template-columns: repeat(5, 60px);
  gap: 10px;
  justify-content: center;
}

.tile {
  width: 60px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2em;
  font-weight: bold;
  text-transform: uppercase;
  border-radius: 5px;
  transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
}

.keyboard {
  display: flex;
  flex-direction: column;
  gap: 5px;
  max-width: 600px;
  margin-top: 20px;
  margin-bottom: 20px;
}

.key-row {
  display: flex;
  justify-content: center;
  gap: 5px;
}

.key {
  padding: 10px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 1em;
  font-weight: bold;
  user-select: none;
}

#hintBtn1, #hintBtn2, #hintBtn3, #hintBtn4 {
  height: 68px;
  text-align: left;
  border-top:0;
  border-left:0;
  border-right:0;
  border-radius: 5px;
  margin-bottom: 5px;
  cursor: pointer;
  padding: 0 0 0 10px;
  font-size: 10pt;
  align-items: center;
  justify-content: center;
  transition: color 0.3s ease;
}

#hintTitle {
  width: auto;
  text-align: center;
  text-transform: lowercase;
  margin: 0 auto;
  font-weight: 700;
  font-style: italic;
  font-family: 'Sansita', cursive;
  margin-bottom: 10px;
  font-size: 1.3em;
  letter-spacing: 2pt;
  position: relative;
  display: inline-block;
}

#hintTitle::before {
  height: 9px;
  width: 105%;
  left: -4%;
  bottom: -2px;
  z-index: -1;
  content: "";
  position: absolute;
  opacity: 0.8;
}

#hintTitle:hover::before {
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
}

.hint-button {
  display: none;
}

#hintButtons button {
  width: 180px;
  align-items: flex-start;
  flex-direction: column;
  gap: 4px;
  padding: 5px 0;
  letter-spacing: 1pt;
  font-weight: bold;
  border-radius: 10px;
  margin: 4px 2px;
  cursor: pointer;
  font-size: 10pt;
  white-space: normal;
  overflow: hidden;
  height: auto;
  transition: background-color 0.3s ease;
}

#hintButtons button.expanded {
  opacity: 1;
  max-height: 220px;
}

#hintButtons button:disabled {
  cursor: default;
  opacity: 1;
}

.hint-label {
  text-transform: lowercase;
  padding-bottom: 2px;
  font-size: 11pt;
  width: 100%;
  letter-spacing: 1pt;
  margin: 0;
  font-family: 'Sansita', cursive;
}

.hint-label.hidden {
  margin-right: 10px;
}

.hint-text {
  display: block;
  font-weight: normal;
  opacity: 0;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1),
    opacity 0.5s ease,
    overflow 0s linear 0.5s;
  width: 100%;
  box-sizing: border-box;
}

.hint-text.visible {
  opacity: 1;
  padding: 7px 15px 7px 7px;
  width: 435px;
  text-transform: uppercase;
  overflow: auto;
  max-height: 68px;
  font-size: 11pt;
  text-align: right;
  font-family: Trebuchet MS, Helvetica, Arial, sans-serif;
}

#hintBtn1:hover, #hintBtn2:hover, #hintBtn3:hover, #hintBtn4:hover,
#hintBtn1.clicked-hint, #hintBtn2.clicked-hint, #hintBtn3.clicked-hint, #hintBtn4.clicked-hint {
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
}

.styled-button {
  border: none;
  width: auto;
  font-size: 10pt;
  font-family: Trebuchet MS, Helvetica, Arial, sans-serif;
  cursor: pointer;
  margin: 0;
  letter-spacing: 1px;
}

#modalCopyBtn, #showStatsBtn, #showScoreboardBtn, #copy-url-btn, #start-playing-btn {
  padding: 10px;
  font-weight: bold;
  font-size: 10pt;
  width: 10em;
  border-radius: 1rem;
  cursor: pointer;
  margin: 5px auto;
  z-index: 100;
}

#modalCopyBtn:hover, #showStatsBtn:hover, #showScoreboardBtn:hover, #copy-url-btn:hover, #start-playing-btn:hover {
  transition: background-color 0.1s ease-in-out, color 0.1s ease-in-out;
}

#modal-stats-display {
  text-align: center;
}

h1 {
  letter-spacing: 1pt;
  margin: 0;
  font-family: 'VT323', monospace;
  box-sizing: border-box;
  height: 75px;
  position: relative;
  text-align: center;
  padding: 0 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

h1 > p {
  margin: 0;
  line-height: 33pt;
  min-width: 400px;
}

.h1-button-group-left {
  position: absolute;
  left: 30px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  gap: 8px;
}

.h1-button-group-right {
  position: absolute;
  right: 30px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  gap: 8px;
}

.share-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 1001;
  width: 450px;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}

.share-popup.show {
  opacity: 1;
  visibility: visible;
}

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}

.modal {
  position: relative;
  transform: scale(0.95);
  opacity: 0;
  transition: opacity 0.3s ease, transform 0.3s ease;
  transition-delay: 0.1s;
}

.modal-overlay.show {
  opacity: 1;
  visibility: visible;
}

.modal-overlay.show .modal {
  transform: scale(1);
  opacity: 1;
}

#modal-message {
  font-size: 16pt;
  width: auto;
  font-family: monospace;
    margin: 10px 0;
}

.modal-content {
  position: relative;
  max-height: 80%;
  border-radius: 10px;
  padding: 15px 30px 30px 30px;
  text-align: center;
  display: flex;
  flex-direction: column;
  gap: 0px;
  max-height: 85vh;
  overflow-y: auto;
}

#modal-summary {
  white-space: pre-wrap;
  font-family: monospace;
  font-size: 1.2em;
  letter-spacing: 2pt;
  margin: 10px 0 0 0;
}

#modal-hints-container {
  width:auto;
  margin:0 auto;
  font-size: 11pt;
  padding: 10px;
  border-radius: 8px;
  max-height: 120px;
  min-height:45px;
  overflow: scroll;
  background-color: var(--hint-panel);
  color: var(--text-secondary);
}

#modal-hints-container h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 12pt;
  display: none;
}

#modal-hints-container p {
  margin: 2px 0;
  padding: 2px;
  font-size: 10pt;
  font-family:'Courier New', Courier, monospace;
  background-color: var(--bg-secondary);
  border: var(--border-style);
}

#hintButtonsContainer {
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 3px;
  margin-top: 30px;
}

.word-host-input {
  font-size: 11pt;
  padding: 7px;
  border-radius: 6px;
  width: 200px;
  margin-top: 5px;
  margin-bottom: 5px;
  margin-left: 30px;
  text-align: center;
  transition: background 0.2s ease;
}

.host-input {
  font-size: 11pt;
  padding: 7px;
  border-radius: 6px;
  width: 200px;
  height: 22px;
  display: block;
  margin: auto;
  margin-top: 2px;
  margin-bottom: 2px;
  text-align: center;
  transition: background 0.2s ease;
}

#hintInput4Container {
  margin: auto;
  margin-top: 3px;
  margin-bottom: 3px;
  display: block;
  padding: 7px;
  width: 200px;
  border-radius: 6px;
  text-align: center;
  transition: background 0.2s ease;
}

#modal-stats-container {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.5s ease-in-out, margin-top 0.5s ease-in-out;
  padding: 0 10px;
  border-radius: 8px;
}

#modal-stats-container.expanded {
  max-height: 500px;
}

.stats-line {
  margin: 5px 0;
  font-family: monospace;
}

.button-group {
  display: inline-block;
  flex-direction: column;
  gap: 15px;
  width: 100%;
  align-items: center;
}

.key:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.shake {
  animation: shake 0.5s ease-in-out;
}

#funFactInput {
  padding: 8px 28px;
  min-height: 70px;
  font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
  border-radius: 6px;
  font-size: 11pt;
  width: 300px;
  display: block;
  margin: auto;
  margin: 5px auto;
  text-align: center;
  transition: background 0.2s ease;
  resize: vertical;
  line-height: 1.4;
}

.fun-fact-section {
  font-size: 11pt;
  padding: 10px;
  border-radius: 8px;
  margin-top: 10px;
  min-height: 60px;
  max-height: 120px;
  overflow: scroll;
}

.fun-fact-section h2 {
  font-size: 12pt;
  margin: 4px 0 6px 0;
}

.fun-fact-section::-webkit-scrollbar {
  width: 10px;
}

.fun-fact-section::-webkit-scrollbar-thumb {
  border-radius: 0 6px 0 6px;
}

.fun-fact-section::-webkit-scrollbar-corner {
  border-radius: 6px 0 6px 0;
}

.help-button {
  border: none;
  border-radius: 50%;
  width: 29px;
  height: 29px;
  font-weight: bold;
  cursor: pointer;
  user-select: none;
  transition: background-color 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  padding: 0;
  line-height: 1;
}

.help-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  max-width: 380px;
  border-radius: 10px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  padding: 2px 6px;
}

.help-popup[hidden] {
  display: none;
}

.help-popup-content {
  position: relative;
  padding: 20px 45px;
  overflow: scroll;
  max-height: 550px;
  font-size: 11.5pt;
}

.close-btn {
  position: absolute;
  top: -8px;
  right: 0px;
  width: 25px;
  height: 25px;
  border: none;
  z-index: 1000;
  border-radius: 50%;
  font-size: 17pt;
  cursor: pointer;
  font-family: 'Sansita', cursive;
}

.close-btn:hover {
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
}

.close-help-btn, .close-hint-btn {
  position: absolute;
  top: 0px;
  right: 1px;
  width: 30px;
  height: 30px;
  border: none;
  z-index: 1000;
  border-radius: 50%;
  font-size: 19pt;
  cursor: pointer;
  font-family: 'Sansita', cursive;
}

.close-help-btn:hover, .close-hint-btn:hover {
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
}

.close-hint-btn {
  top: -3px;
}

#hintPopupOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 999;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0s 0.3s;
}

.hint-popup {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  max-width: 400px;
  margin: 0 auto;
  padding: 10px;
  border-radius: 10px;
  z-index: 1000;
  transform: translateY(100%);
  opacity: 0;
  visibility: hidden;
  transition: transform 0.3s ease, opacity 0.3s ease, visibility 0s 0.3s;
}

.hint-popup.show {
  transform: translateY(0);
  opacity: 1;
  visibility: visible;
  transition-delay: 0s;
  bottom: 10px;
}

.hint-popup.show ~ #hintPopupOverlay {
  opacity: 1;
  visibility: visible;
  transition-delay: 0s;
}

#share-message-box {
  width: 100%;
  height: 80px;
  padding: 10px;
  box-sizing: border-box;
  border-radius: 15px;
  font-family: 'Trebuchet MS', Helvetica, Arial, sans-serif;
  font-size: 1em;
  resize: none;
}

#share-message-box:focus {
  outline: none;
}

.custom-tooltip {
  position: relative;
  cursor: pointer;
}

.custom-tooltip::after {
  content: attr(data-tooltip);
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-top: 10px;
  font-weight: 400;
  padding: 8px;
  border-radius: 4px;
  font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
  font-size: 11pt;
  z-index: 10;
  white-space: normal;
  max-width: 200px;
  text-align: center;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.1s ease, visibility 0.1s ease;
  transition-delay: 0s;
}

.custom-tooltip:hover::after {
  opacity: 1;
  visibility: visible;
  transition-delay: 0s;
}

table {
  font-family: monospace;
  font-size: 10pt;
  border-collapse: collapse;
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
}

tr>:nth-child(2) {
  min-width: 35px;
}

tr>:nth-child(1), tr>:nth-child(4) {
  max-width: 20px;
  text-align: center;
}

tr>:nth-child(3) {
  max-width: 30px;
  text-align: center;
}

tr {
  text-transform: uppercase;
}

td, th {
  border-style: none solid solid none;
  padding: 5px;
  text-align: left;
}

td {
  max-width: 10px;
  overflow: scroll;
}

th {
  border: 0px;
  text-transform: capitalize;
}

tr:first-child td:first-child {
  border-top-left-radius: 10px;
}

tr:first-child td:last-child {
  border-top-right-radius: 10px;
}

tr:last-child td:first-child {
  border-bottom-left-radius: 10px;
}

tr:last-child td:last-child {
  border-bottom-right-radius: 10px;
}

tr:first-child td {
  border-top-style: solid;
}

tr td:first-child {
  border-left-style: solid;
}

#game-over-modal {
  position: relative;
}

.side-panel {
  position: absolute;
  top: 35px;
  left: 100%;
  z-index: 1;
  width: 0;
  overflow: hidden;
  transition: width 0.4s ease-in-out;
  padding: 0;
  height: 85%;
  border-radius: 0 12px 12px 0;
  pointer-events: none;
}

.side-panel.show {
  width: 280px;
  pointer-events: auto;
}

.side-panel-content {
  width: 280px;
  padding: 20px;
  height: 100%;
  overflow: auto;
  box-sizing: border-box;
}

#scoreboard-summary-container {
  padding: 10px 15px;
  margin-bottom: 10px;
}

.summary-stat {
  margin-bottom: 12px;
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
}

.summary-stat:last-child {
  margin-bottom: 0;
}

.stat-label {
  width: 90px;
  text-align: center;
  flex-shrink: 0;
}

.stat-bar-container {
  flex-grow: 1;
  height: 20px;
  overflow: hidden;
}

.stat-bar {
  height: 100%;
  border-radius: 5px;
  transition: width 0.5s ease-in-out;
  text-align: center;
  font-weight: bold;
  line-height: 20px;
  white-space: nowrap;
}

.modal-button-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0px;
  width: 100%;
}

#word-status-indicator.loading::after {
  content: '';
  display: block;
  width: 15px;
  height: 15px;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.shake {
  animation: shake 0.5s;
}

@keyframes shake {
  10%, 90% {
    transform: translateX(-1px);
  }

  20%, 80% {
    transform: translateX(2px);
  }

  30%, 50%, 70% {
    transform: translateX(-4px);
  }

  40%, 60% {
    transform: translateX(4px);
  }
}

.input-with-indicator {
  display: flex;
  justify-content: center;
  align-items: center;
}

#account-sidebar {
  font-family: monospace;
  z-index: 9999;
  padding: 10px;
  transition: right 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  overflow-y: auto;
}

#account-sidebar.show {
  right: 0;
}

#account-sidebar h2 {
  text-align: center;
  margin-top: 25px;
  text-transform: lowercase;
  font-family: 'Sansita', cursive;
  position: relative;
  display: inline-block;
}

#account-sidebar h2::before {
  content: "";
  position: absolute;
  height: 9px;
  width: 110%;
  left: -5%;
  bottom: -2px;
  z-index: -1;
}

.account-section {
  margin-top: 5px;
  margin-bottom: 5px;
}

.account-section:last-child {
  margin-bottom: 20px;
}

.user-games-title {
  font-weight: 400;
  text-transform: lowercase;
  margin: 0 0 10px 0;
  font-size: 11pt;
}

.games-list {
  display: flex;
  flex-direction: column;
  gap: 0px;
  border-radius: 8px;
  padding: 2px;
  min-height: 30px;
}

.games-list a {
  text-decoration: none;
  padding: 8px;
  border-radius: 5px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: background-color 0.2s ease;
}

.game-status {
  font-size: 0.8em;
  font-style: italic;
  opacity: 0.8;
}

.game-list-item {
  padding: 2px;
  border-radius: 5px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: background-color 0.2s ease;
}

.game-list-item a {
  text-decoration: none;
  letter-spacing: 1px;
  font-size: 9pt;
}

.game-item-actions {
  display: flex;
  gap: 0px;
}

.game-item-actions button {
  border: none;
  border-radius: 50%;
  cursor: pointer;
  width: 28px;
  height: 28px;
  font-size: 12pt;
  margin-top: 2px;
  transition: background-color 0.2s ease, color 0.2s ease;
}

.stat-value {
  font-size: 1.4em;
  font-weight: bold;
}

.stat-label {
  font-size: 0.8em;
  text-transform: uppercase;
}

.login-prompt-container {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 5px;
  width: 100%;
}

#sidebar-loader {
  display: none;
  text-align: center;
  margin-top: 50px;
  font-size: 1.1em;
}

.spinner {
  margin: 0 auto 15px auto;
  border-radius: 50%;
  width: 30px;
  height: 30px;
  animation: spin 1s linear infinite;
}

#sidebar-content {
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

#sidebar-content.loaded {
  visibility: visible;
  opacity: 1;
}

#toast-container {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 10003;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  pointer-events: none;
}

.toast {
  padding: 12px 20px;
  border-radius: 25px;
  font-family: 'Trebuchet MS', Helvetica, Arial, sans-serif;
  font-size: 1em;
  font-weight: bold;
  animation: fadeInOut 3s ease-in-out forwards;
  pointer-events: all;
}

@keyframes fadeInOut {
  0% {
    opacity: 0;
    transform: translateY(-20px);
  }

  10%, 90% {
    opacity: 1;
    transform: translateY(0);
  }

  100% {
    opacity: 0;
    transform: translateY(20px);
  }
}

#header-setup {
  display: none;
  padding: 5px 10px;
  justify-content: center;
  height: 32px;
}

.header-content-wrapper {
  width: 100%;
  max-width: 500px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
}

#setup,
#game {
  max-width: 500px;
  width: 100%;
  margin-left: auto;
  margin-right: auto;
  box-sizing: border-box;
  transition: opacity 0.4s ease-in-out;
  display: none;
}

.header-content-wrapper > div {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
}

.header-content-wrapper p,
.header-content-wrapper button {
  font-family: 'Trebuchet MS', Helvetica, Arial, sans-serif;
  font-size: 10pt;
  letter-spacing: 1px;
  margin: 0;
  padding: 4px;
}

#setup-form-content {
  transition: opacity 0.4s ease-in-out;
}

#host-credit {
  font-size: 9pt;
  margin-top: 25px;
  letter-spacing: 1px;
  font-family: monospace;
}

#account-badges-container {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 6px;
  margin: -10px 0 15px 0;
}

.badge {
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 0.8em;
  font-family: 'Trebuchet MS', Helvetica, Arial, sans-serif;
  display: inline-flex;
  align-items: center;
  gap: 5px;
  font-weight: bold;
}

#account-graph-container, #modal-stats-container .stats-graph {
  width: 100%;
  padding: 10px 15px;
  box-sizing: border-box;
  margin-bottom: 5px;
  font-family: monospace;
}

#account-graph-container h3, #modal-stats-container .stats-graph h3 {
  text-align: center;
  margin: 0 0 10px 0;
  font-size: 11pt;
  font-weight: 400;
  text-transform: lowercase;
  font-family: monospace;
}

.graph-row {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
  height: 20px;
}

.graph-label {
  width: 20px;
  font-weight: bold;
}

.graph-bar, .zero-count {
  height: 100%;
  text-align: right;
  padding-right: 8px;
  box-sizing: border-box;
  font-weight: bold;
  min-width: 22px;
  transition: width 0.5s ease-in-out;
  display: flex;
  justify-content: flex-end;
  align-items: center;
  border-radius: 5px;
}

#giveUpBtn {
  width: 140px;
  margin: 0 auto;
  border-radius: 8px;
  padding: 5px 10px;
  font-family: monospace;
  text-transform: lowercase;
  font-size: 11pt;
  font-weight: bold;
  cursor: pointer;
  margin-top: 20px;
  transition: background-color 0.2s ease, color 0.2s ease;
}

#hintInput4Container p {
  margin: 0 0 5px 0;
  font-size: 11pt;
}

#mainContent {
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.3s ease-in;
}

#mainContent.loaded {
  visibility: visible;
  opacity: 1;
}

#loader {
  display: none;
  margin-top: 100px;
  font-size: 1.2em;
}

.overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 9998;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
}

.overlay.show {
  opacity: 1;
  visibility: visible;
}

#letter-pattern-container {
  display: none; /* Hidden by default, JS will make it flex initially */
  justify-content: center;
  align-items: center; 
  margin: 5px auto 5px auto;
  height: 30px; 
}

#pattern-shapes-wrapper {
  display: none; /* The shapes are hidden by default */
  gap: 8px;
  perspective: 800px; /* Creates the 3D space needed for the flip effect */
}

#show-pattern-btn {
  /* --- Previous styles --- */
  background-color: var(--bg-panel);
  color: var(--text-primary);
  border: 0px solid var(--border-subtle);
  border-radius: 4px;
  padding: 5px 15px;
  font-family:monospace;
  font-size: 0.9rem;
  cursor: pointer;
  text-transform: lowercase;
  /* --- New animation styles --- */
  opacity: 1;
  transition: opacity 0.3s ease-out; /* Smooth fade-out transition */
}

#show-pattern-btn:hover {
    background-color: var(--bg-panel);
}

/* New class to control the button's hidden state */
#show-pattern-btn.is-hidden {
  opacity: 0;
  pointer-events: none; /* Prevents clicking the invisible button */
}

/* This is the wrapper for each individual shape SVG */
#pattern-shapes-wrapper > div {
  opacity: 0; /* Shapes start invisible */
  transform: rotateY(90deg); /* Shapes start flipped backwards */
}

/* The animation class we will add with JS */
.is-flipping {
  animation: flip-in 0.2s ease-out forwards;
}

@keyframes flip-in {
  from {
    transform: rotateY(90deg);
    opacity: 0;
  }
  to {
    transform: rotateY(0deg);
    opacity: 1;
  }
}

.pattern-shape {
  width: 35px;
  height: 35px;
  fill: var(--text-secondary); 
}
#daily-hints-container {
  display: none; /* Hidden by default */
  flex-direction: row; /* ✅ Stack items vertically */
  justify-content: center;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
  min-height: 30px; /* Reserve space to prevent layout shift */
}

.daily-hint-btn {
  background-color: transparent;
  color: var(--text-primary);
  border: 0px solid var(--border-subtle);
  padding: 5px 15px;
  font-family: monospace;
  font-size: 0.9rem;
  cursor: pointer;
}

.hint-wrapper {
  position: relative; /* This is crucial for positioning the tooltip */
  background-color: var(--bg-panel);
  border-radius: 50%;
  width: 35px;
  height: 35px;
  display: flex;
  justify-content: center;
  align-items: center;
}
.hint-tooltip {
  position: absolute;
  bottom: 110%; /* Position it right above the button */
  left: 50%;
  transform: translateX(-50%);
  
  background-color: var(--correct-bg); /* Use a theme color for contrast */
  color: var(--bg-primary); /* A contrasting text color */
  padding: 8px 12px;
  border-radius: 6px;
  font-family: monospace;
  font-size: 1rem;
  white-space: nowrap;
  z-index: 10;
  
  /* Hidden by default */
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transition: opacity 0.3s ease, bottom 0.3s ease;
}

/* The small arrow pointing down from the bubble */
.hint-tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border-width: 6px;
  border-style: solid;
  border-color: var(--correct-bg) transparent transparent transparent;
}

/* The class to make the tooltip appear */
.hint-tooltip.is-visible {
  opacity: 1;
  visibility: visible;
  bottom: 120%; /* Move it up slightly for a nice pop effect */
}

/* Style for the button after it's been clicked */
.daily-hint-btn:disabled {
    opacity: 0.7;
    cursor: not-allowed;
}

  </style>
  
</head>
<body>
<div id="toast-container"></div>

<div id="language-popup-overlay" class="language-popup-overlay"></div>

<div id="language-popup" class="language-popup" role="dialog" aria-modal="true" aria-labelledby="language-popup-title">
  <h2 id="language-popup-title" class="language-popup-title">Welcome!</h2>
  <p class="language-popup-text">To finish setting up your profile, can you tell us what your native language is?</p>
    <select id="language-popup-input" class="language-popup-input">
      <option value="" disabled selected>Select your language...</option>
      </select>
  <button id="language-popup-save-btn" class="language-popup-button">Save and Continue</button>
</div>

<div id="game-scoreboard-overlay" class="language-popup-overlay"></div>

<div id="game-scoreboard-popup" class="language-popup" role="dialog" aria-modal="true" aria-labelledby="game-scoreboard-title">
  <button class="close-btn" onclick="closeGameScoreboard()">&times;</button>
  <h2 id="game-scoreboard-title" class="language-popup-title">Scoreboard</h2>
  <div id="game-scoreboard-content" class="scoreboard-content-container">
    <p>Loading scores...</p>
  </div>
</div>

<h1>
  <div class="h1-button-group-left">
    <!-- <button id="practiceBtn" aria-label="Practice Mode" class="help-button custom-tooltip" data-tooltip="Practice Mode">🎯</button>-->
    <button id="globalScoreboardBtn" aria-label="Global Scoreboard" class="help-button custom-tooltip" data-tooltip="Global Scoreboard">🌐</button>
    <!-- <button id="dailyWordleBtn" aria-label="Daily Wørtle" class="help-button custom-tooltip" data-tooltip="Daily Wørtle">📅</button>-->
    <button onclick="window.location.href='directory.html'" aria-label="Game Directory" class="help-button custom-tooltip" data-tooltip="Game Directory">📚</button>
    <button onclick="window.location.href='calculator.html'" aria-label="Guess Calculator" class="help-button custom-tooltip" data-tooltip="Guess Calculator">🧮</button>
    <button id="themeToggleBtn" aria-label="Toggle Theme" class="help-button custom-tooltip" data-tooltip="Switch Theme">🌙</button>
  </div>
  <p><span style="color:var(--accent-color);">Cross-Germanic</span> WØRTLE</p>
  <div class="h1-button-group-right">
    <button id="newGameBtn" aria-label="Create New Game" class="help-button custom-tooltip" data-tooltip="New Wørtle">✏️</button>
    <button id="helpBtn" aria-label="Show Help" data-tooltip="Info" class="help-button custom-tooltip">❔</button>
    <button id="accountBtn" aria-label="My Account" class="help-button custom-tooltip" data-tooltip="My Account">👤</button>
  </div>
</h1>
<div id="loader">Loading Wørtle...</div>

<div id="mainContent">

<div id="header-setup">
    <div class="header-content-wrapper">
      <div id="setup-username-area" class="user-info-area"></div>
    </div>
</div>

<div id="setup" style="padding-bottom:10px;">
  <div id="setup-form-content">
  <p style="margin-bottom:20px;">Enter a secret word, hints and an optional fun fact</p>
      <div class="input-with-indicator">
    <input type="text" id="secretInput" maxlength="5" placeholder="Secret word" class="word-host-input"/>
    <span id="word-status-indicator"></span>
  </div>
    <button id="generateWordBtn" style="margin:5px 0 7px 0;">Pick Random Word</button>
    <!-- 
    <div id="special-char-keyboard" class="keyboard mini-keyboard">
    <div class="key-row">
      <button class="key" onclick="insertSpecialChar('Ä')">Ä</button>
      <button class="key" onclick="insertSpecialChar('Ö')">Ö</button>
      <button class="key" onclick="insertSpecialChar('Ü')">Ü</button>
      <button class="key" onclick="insertSpecialChar('ẞ')">ẞ</button>
      <button class="key" onclick="insertSpecialChar('Æ')">Æ</button>
      <button class="key" onclick="insertSpecialChar('Ø')">Ø</button>
      <button class="key" onclick="insertSpecialChar('Å')">Å</button>
    </div>
  </div>
  -->

<div class="language-input-container">
  <input type="text" id="hintInput" placeholder="Language" class="host-input is-auto-populated" disabled/>
  <button id="switch-language-btn" onclick="switchLanguage()">›</button>
</div>


  <input type="text" id="hintInput2" placeholder="Part of speech" class="host-input"/>

    <div class="input-with-tooltip-container">
    <input type="text" id="hintInput3" placeholder="Context clue" style="margin:0px;" class="host-input"/>
    <span class="tooltip-trigger">?
      <span class="tooltip-text">
        Guessing a word from another language is difficult! 
        Provide a helpful clue, such as a sentence that uses the secret word, replacing the word itself with underscores (e.g., "A Viking longship is powered by a large rectangular ____.").
      </span>
    </span>
  </div>

  <div id="hintInput4Container" class="disabled-container">
  <p>Special character(s)</p>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Ä" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Ä</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Ö" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Ö</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Ü" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Ü</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="ẞ" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>ẞ</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Æ" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Æ</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Ø" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Ø</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Å" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Å</label>
</div>
  <textarea id="funFactInput" placeholder="Fun fact about the word (to be shown after the game is over)"></textarea>
  <button onclick="startGame()" style="margin:10px;">Create Game</button>
</div>
</div>

  
  <p id="message"></p>

<div id="game">

  <div id="board" class="board"></div>
  <div id="letter-pattern-container"></div>
  <div id="daily-hints-container"></div>

<div id="hintButtons" style="display: none;">
  <div id="hintTitle" style="cursor:pointer;">Need a hint?</div>
</div>

  <div id="keyboard" class="keyboard"></div>
    <div class="hard-mode-toggle-container">
    <label for="hard-mode-toggle" class="hard-mode-label">Hard mode</label>
    <label class="toggle-switch">
      <input type="checkbox" id="hard-mode-toggle" checked>
      <span class="slider"></span>
    </label>
  </div>
  <button id="giveUpBtn">I Give Up</button>
  <p id="host-credit"></p>
</div>

<div id="game-over-overlay" class="modal-overlay">

  <div id="game-over-modal" class="modal">

    <div id="scoreboard-panel" class="side-panel">
      <div class="side-panel-content">
        <h2 style="font-size:14pt;">Scoreboard for <span id="scoreboard-word"></span></h2>
        <div id="scoreboard-summary-container"></div>
        <div id="scoreboard-container"></div>
      </div>
    </div>

      <button id="closeModalBtn" class="close-btn">&times;</button>
    <div class="modal-content">
      <p id="modal-message"></p>
      <div id="modal-hints-container"></div>
      <pre id="modal-summary"></pre>

      <div class="modal-button-container">
        <button id="modalCopyBtn">Copy Result</button>
        <button id="showScoreboardBtn">View Scoreboard</button>
      </div>

    </div>

  </div>
</div>

<div id="share-modal" class="share-popup">
  <div class="modal-content">
    <p style="font-weight:600;margin-bottom:5px;font-size: 12pt;width:auto;font-family:monospace;">Share with others:</p>
    <textarea id="share-message-box" readonly></textarea>
    <div class="button-group">
      <button id="copy-url-btn">Copy Text</button>
      <button id="start-playing-btn">Start Playing</button>
    </div>
  </div>
</div>
</div>

<div id="helpOverlay" class="overlay"></div>
<div id="helpPopup" class="help-popup" role="dialog" aria-modal="true" aria-labelledby="helpTitle" tabindex="-1" hidden>
  <div class="help-popup-content">
    <button id="closeHelpBtn" aria-label="Close help" class="close-help-btn">&times;</button>
    <h2 id="helpTitle">How to Wørtle</h2>
    <p>Enter or generate a secret word, as well as hints for the user to reveal. If the word is not accepted, it is either not in the word list or has already been used. Share the URL with players.</p>
    <hr>
    <p>WØRTLE is currently enabled for:<br>
    German &mdash; 3902 words<br>
    Norwegian &mdash; 15651 words<br>
    Swedish &mdash; 4585 words<br>
    Danish &mdash; 4548 words<br>
    English &mdash; 14849 words</p>
    <p>Each language utilises a limited word list, which vary in how extensive they are.</p>
    <hr>
    <p><i>Created by lokke@ and bicks@<br>Original idea by aottl@</i></p>
    <p>Find a bug? Want to add a word to the word list? Or have any other suggestions for improvement?<br>Please write to lokke@google.com</p>
  </div>
</div>

<div id="hintPopup" class="hint-popup" role="dialog" aria-modal="true" aria-labelledby="hintPopupTitle">
    <button id="closeHintPopupBtn" aria-label="Close hint popup" class="close-hint-btn">&times;</button>
    <p id="hint-unlock-message" style="display: none;"></p>
    <div id="hintButtonsContainer">
        <button id="hintBtn1" class="hint-button" onclick="showHint(1)">
            <span class="hint-label">Language</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn2" class="hint-button" onclick="showHint(2)">
            <span class="hint-label">Part Of Speech</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn3" class="hint-button" onclick="showHint(3)">
            <span class="hint-label">Context</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn4" class="hint-button" onclick="showHint(4)">
            <span class="hint-label">Special Character(s)</span>
            <span class="hint-text"></span>
        </button>
    </div>
    <p id="hint-unlock-next-message" style="display: none;"></p>
</div>

<div id="account-overlay" class="overlay"></div>
<div id="account-sidebar">
  <button id="closeAccountBtn" class="close-help-btn">&times;</button>
<div id="account-sidebar-header">
  <h2 id="account-sidebar-title">
    <span id="account-username-text">My Account</span>
    <span id="account-sidebar-flag"></span>
  </h2>
</div>
  <div id="account-badges-container"></div>
  <div id="sidebar-loader">
    <div class="spinner"></div>
    Loading account...
  </div>
  <div id="sidebar-content">
    <div id="account-stats-section" class="account-section"></div>
    <div id="account-graph-container" class="account-section"></div>
    <div class="account-section">
        <h3 id="hosted-games-title" class="user-games-title">Hosted Games</h3>
        <div id="hosted-games-list" class="games-list"></div>
    </div>
    <div class="account-section">
        <h3 id="played-games-title" class="user-games-title">Played Games</h3>
        <div id="played-games-list" class="games-list"></div>
    </div>
  </div>
</div>

<div id="hintPopupOverlay" class="popup-overlay"></div>

<script>
let secret = "";
let customHint1 = "";
let customHint2 = "";
let customHint3 = "";
let customHint4 = "";
let customFunFact = "";
let hintUsed1 = false;
let hintUsed2 = false;
let hintUsed3 = false;
let hintUsed4 = false;
let currentRow = 0;
let currentCol = 0;
const rows = 8;
const cols = 5;
let grid = [];
let keyColors = {};
let guessHistory = [];
let colorHistory = [];
let usernameSet = false;
let isAnimating = false;
let isHardMode = true; // Hard mode is on by default
let hardModeWasDisabled = false;
let gameCreatedDate = null;
let hintExpanded1 = false;
let hintExpanded2 = false;
let hintExpanded3 = false;
let hintExpanded4 = false;
let scoreboardListener = null;
let badgesRef = null;      // <-- Ensure this line exists
let badgesListener = null;
let langRef = null;      // ADD THIS
let langListener = null; // ADD THIS
let isDailyGame = false;
// Near the top of your script with other global variables
let gameNumber = null;
let hostUsername = null;
let isModalOpen = false;
let userListener = { ref: null, listener: null };
let availableLanguagesForWord = [];
let currentLanguageIndex = 0;
document.addEventListener('click', closeAllTooltips);
const hintTitle = document.getElementById("hintTitle");
const hintPopup = document.getElementById("hintPopup");
const hintPopupOverlay = document.getElementById("hintPopupOverlay");
const closeHintPopupBtn = document.getElementById("closeHintPopupBtn");
const game = document.getElementById("game");
const validLanguages = new Set([
    'bulgarian', 'croatian', 'czech', 'danish', 'dutch', 'english', 
    'estonian', 'finnish', 'french', 'german', 'greek', 'hungarian', 
    'irish', 'italian', 'latvian', 'lithuanian', 'polish', 
    'portuguese', 'romanian', 'slovak', 'slovenian', 'spanish', 
    'swedish', 'norwegian', 'russian', 'turkish'
]);
const languageToCountryCode = {
  bulgarian: 'BG', croatian: 'HR', czech: 'CZ', danish: 'DK',
  dutch: 'NL', english: 'GB', estonian: 'EE', finnish: 'FI',
  french: 'FR', german: 'DE', greek: 'GR', hungarian: 'HU',
  irish: 'IE', italian: 'IT', latvian: 'LV', lithuanian: 'LT',
  polish: 'PL', portuguese: 'PT', romanian: 'RO',
  slovak: 'SK', slovenian: 'SI', spanish: 'ES', swedish: 'SE',
  norwegian: 'NO', russian: 'RU', turkish: 'TR'
};
const SUPPORTED_LANGUAGES = ['german', 'norwegian', 'english', 'swedish', 'danish']; // <-- Add all your file names here (without .txt)
const wordLists = new Map();
let allWordsSet = new Set();
const practiceBtn = document.getElementById('practiceBtn');
if (practiceBtn) {
    practiceBtn.addEventListener('click', () => {
        // This will take the user to your new practice page
        window.location.href = 'practice.html';
    });
}
const globalScoreboardBtn = document.getElementById('globalScoreboardBtn');
if (globalScoreboardBtn) {
    globalScoreboardBtn.addEventListener('click', () => {
        // This will take the user to your new scoreboard page
        window.location.href = 'scoreboard.html';
    });
}

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyDGepZP9hu3hHAL1wfrp4gjIurEPLPUbaw",
  authDomain: "woertle-7dc73.firebaseapp.com",
  databaseURL: "https://woertle-7dc73-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "woertle-7dc73",
  storageBucket: "woertle-7dc73.firebasestorage.app",
  messagingSenderId: "97063588719",
  appId: "1:97063588719:web:dc734f9c0772d49e5b0e9a"
};

// Initialize Firebase using the global firebase object
firebase.initializeApp(firebaseConfig);

// Create a database reference for your other functions to use
const database = firebase.database();

const appCheck = firebase.appCheck();
appCheck.activate(
  new firebase.appCheck.ReCaptchaEnterpriseProvider(
  '6LeZ-LwrAAAAALts-h7cHaX434txCE2jbRW-SS6f', // Paste the site key you got from Google here
  ),
  true // Set to true to allow auto-refresh.
);

// --- NEW: Debounce timer for live validation ---
let debounceTimer;

/**
 * Converts a string to uppercase, correctly handling the German Eszett (ß -> ẞ).
 * The standard .toUpperCase() converts 'ß' to 'SS'.
 * @param {string} str The string to convert.
 * @returns {string} The uppercased string.
 */
function germanFriendlyUpperCase(str) {
    return str.replace(/ß/g, 'ẞ').toUpperCase();
}

/**
 * Inserts a special character into the secret word input field.
 * @param {string} char The character to insert.
 */
function insertSpecialChar(char) {
    const secretInput = document.getElementById('secretInput');
    const maxLength = parseInt(secretInput.maxLength, 10);
    
    // Do nothing if the input is already full
    if (secretInput.value.length >= maxLength) {
        return;
    }

    const currentPos = secretInput.selectionStart;
    const currentValue = secretInput.value;

    // Insert the character at the current cursor position
    const newValue = currentValue.slice(0, currentPos) + char + currentValue.slice(currentPos);
    secretInput.value = newValue;

    // Move the cursor to after the inserted character
    secretInput.selectionStart = secretInput.selectionEnd = currentPos + 1;

    // Trigger the input event to run validation and auto-population
    secretInput.dispatchEvent(new Event('input', { bubbles: true }));

    // Return focus to the input field
    secretInput.focus();
}
/**
 * Validates the secret word in the input field.
 * Checks length, dictionary, and database availability.
 * Updates the UI with a status indicator (✅, ❌, or loading spinner).
 * @returns {Promise<boolean>} - True if the word is valid and available, otherwise false.
 */
async function validateSecretWord() {
    const secretInput = document.getElementById('secretInput');
    const indicator = document.getElementById('word-status-indicator');
    const switchBtn = document.getElementById('switch-language-btn');
    const langInput = document.getElementById('hintInput');
    const word = germanFriendlyUpperCase(secretInput.value.trim());
    const wordTakenSvg = `<svg class="clock-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 12"></polyline></svg>`; // ✅ ADD THIS
    const invalidSvg = `<svg class="x-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;

    // --- Reset state on every validation check ---
    indicator.innerHTML = '';
    indicator.className = '';
    switchBtn.style.display = 'none';
    availableLanguagesForWord = [];
    currentLanguageIndex = 0;

    if (!word) {
        langInput.value = ''; // Clear language if word is cleared
        return false;
    }

    if (word.length !== 5 || !/^[A-ZÄÖÜßẞÆØÅ]+$/i.test(word)) {
        indicator.innerHTML = invalidSvg; 
        indicator.className = 'invalid';
        langInput.value = ''; // Clear language if word is invalid
        return false;
    }

    if (!isValidWord(word)) {
        indicator.innerHTML = invalidSvg; 
        indicator.className = 'invalid';
        langInput.value = ''; // Clear language if word is not in list
        return false;
    }

    indicator.className = 'loading';

    try {
        const gameRef = database.ref('games/' + word);
        const snapshot = await gameRef.once('value');

        if (snapshot.exists()) {
            indicator.innerHTML = wordTakenSvg; // ✅ This shows the new clock icon
            indicator.className = 'word-taken'; // Add a new class for styling
            langInput.value = ''; // Clear language if word is taken
            return false;
        } else {
            indicator.innerHTML = `<svg class="checkmark-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
            indicator.className = 'valid';

            // --- START: MODIFIED LANGUAGE LOGIC ---
            const languages = findWordLanguages(word.toLowerCase());
            availableLanguagesForWord = languages; // Store all found languages

                        if (languages.length > 0) {
                // --- START: MODIFIED LOGIC ---
                // This block now prevents the language from being reset if the
                // current selection is still valid for the entered word.
                const currentLangValue = langInput.value.trim().toLowerCase();
                const isCurrentLangValid = languages.includes(currentLangValue);

                if (!langInput.value || !isCurrentLangValid) {
                    // Only auto-populate if the input is empty or the language is no longer valid
                    const displayLanguage = languages[0];
                    langInput.value = displayLanguage.charAt(0).toUpperCase() + displayLanguage.slice(1);
                    currentLanguageIndex = 0; // Reset index to the start
                }
                // --- END: MODIFIED LOGIC ---

                if (languages.length > 1) {
                    switchBtn.style.display = 'block';
                }
            }

            // Auto-populate special characters
            const specialCharsInWord = new Set([...word].filter(c => "ÄÖÜẞÆØÅ".includes(c)));
            document.querySelectorAll(".specialCharCheckbox").forEach(cb => {
                cb.checked = specialCharsInWord.has(cb.value);
            });
            updateHintContainerBackground();
            saveSetupState();

            return true;
        }
    } catch (error) {
        console.error("Firebase check failed:", error);
        indicator.innerHTML = '⚠️';
        indicator.className = 'invalid';
        langInput.value = '';
        return false;
    }
}

// Base64 helpers
function base64Encode(str) { return btoa(unescape(encodeURIComponent(str))); }
function base64Decode(str) { try { return decodeURIComponent(escape(atob(str))); } catch { return null; } }

function getSecretFromURL() {
  const params = new URLSearchParams(window.location.search);
  const encodedWord = params.get("w");
  const encodedHint1 = params.get("h1");
  const encodedHint2 = params.get("h2");
  const encodedHint3 = params.get("h3");
  const encodedHint4 = params.get("h4");

  if (!encodedWord) return null;
  const decodedWord = base64Decode(encodedWord);

  customHint1 = encodedHint1 ? base64Decode(encodedHint1) : "";
  customHint2 = encodedHint2 ? base64Decode(encodedHint2) : "";
  customHint3 = encodedHint3 ? base64Decode(encodedHint3) : "";
  customHint4 = encodedHint4 ? base64Decode(encodedHint4) : "";

  const encodedFunFact = params.get("ff");
  customFunFact = encodedFunFact ? base64Decode(encodedFunFact) : "";

  // ✅ Parse and store creation date ONLY if not already set
  if (!gameCreatedDate) {
    const encodedDate = params.get("d");
    if (encodedDate) {
      const decodedDateStr = base64Decode(encodedDate);
      const parsedDate = new Date(decodedDateStr);
      if (!isNaN(parsedDate)) {
        gameCreatedDate = parsedDate;
      }
    }
  }

  if (decodedWord && /^[A-ZÆØÅÄÖÜẞ]{5}$/.test(decodedWord)) {
    return decodedWord.toUpperCase();
  }
  return null;
}

const hintContainer = document.getElementById("hintInput4Container");
const specialCharBoxes = document.querySelectorAll(".specialCharCheckbox");

function updateHintContainerBackground() {
  const anyChecked = Array.from(specialCharBoxes).some(cb => cb.checked);
  hintContainer.classList.toggle("darkened", anyChecked);
}

specialCharBoxes.forEach(cb => {
  cb.addEventListener("change", updateHintContainerBackground);
});

function saveSetupState() {
  const setupState = {
    secret: document.getElementById('secretInput').value,
    hint1: document.getElementById('hintInput').value,
    hint2: document.getElementById('hintInput2').value,
    hint3: document.getElementById('hintInput3').value,
    funFact: document.getElementById('funFactInput').value,
    // Save an array of the values of all checked boxes
    specialChars: Array.from(document.querySelectorAll('.specialCharCheckbox:checked')).map(cb => cb.value)
  };
  // Convert the object to a string and save it
  localStorage.setItem('wurtleSetupState', JSON.stringify(setupState));
}

function loadSetupState() {
  const savedStateJSON = localStorage.getItem('wurtleSetupState');
  if (savedStateJSON) {
    const savedState = JSON.parse(savedStateJSON);
    
    // Repopulate all the text fields
    document.getElementById('secretInput').value = savedState.secret || '';
    document.getElementById('hintInput').value = savedState.hint1 || '';
    document.getElementById('hintInput2').value = savedState.hint2 || '';
    document.getElementById('hintInput3').value = savedState.hint3 || '';
    document.getElementById('funFactInput').value = savedState.funFact || '';

    // Re-check all the necessary checkboxes
    if (savedState.specialChars && savedState.specialChars.length > 0) {
      document.querySelectorAll('.specialCharCheckbox').forEach(cb => {
        if (savedState.specialChars.includes(cb.value)) {
          cb.checked = true;
        }
      });
    }
  }
}

function generateShareURL(word, hint1, hint2, hint3, hint4, funFact) {
  const url = new URL(window.location.origin + window.location.pathname);
  url.searchParams.set("w", base64Encode(word));
  if (hint1) url.searchParams.set("h1", base64Encode(hint1));
  if (hint2) url.searchParams.set("h2", base64Encode(hint2));
  if (hint3) url.searchParams.set("h3", base64Encode(hint3));
  if (hint4) url.searchParams.set("h4", base64Encode(hint4));
  if (funFact) url.searchParams.set("ff", base64Encode(funFact));
  return url.href;
}

async function updateStats(username, won, guesses) {
    if (!username) return;

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const statsRef = database.ref(`userProfiles/${sanitizedUsername}/stats`);

    try {
        await statsRef.transaction(currentStats => {
            // If stats object doesn't exist at all, create a default one.
            if (currentStats === null) {
                currentStats = { gamesPlayed: 0, wins: 0, totalGuesses: 0 };
            }

            // ✅ ADD THIS BLOCK: This is the key fix.
            // It ensures each property is a number before we use it.
            currentStats.gamesPlayed = currentStats.gamesPlayed || 0;
            currentStats.wins = currentStats.wins || 0;
            currentStats.totalGuesses = currentStats.totalGuesses || 0;

            // Now we can safely do the math
            currentStats.gamesPlayed++;
            if (won) {
                currentStats.wins++;
                currentStats.totalGuesses += guesses;
            }
            currentStats.lastGameTrend = won ? "up" : "down";

            return currentStats;
        });

        // The badge check can remain here, it's correct.
        const newStatsSnapshot = await statsRef.once('value');
        const newStats = newStatsSnapshot.val();
        if (newStats && newStats.gamesPlayed >= 25) {
            awardBadge(username, 'social_butterfly');
        }

    } catch (error) {
        // This will now catch the NaN error if it ever happens again.
        console.error("Could not update stats in Firebase:", error);
    }
}

async function displayStats(username) {
    const user = username || "Player";
    const defaultStats = { gamesPlayed: 0, wins: 0, totalGuesses: 0 };
    let stats = { ...defaultStats }; // Use a copy

    if (username) {
        try {
            const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
            const statsRef = database.ref(`userProfiles/${sanitizedUsername}/stats`);
            const snapshot = await statsRef.once('value');
            if (snapshot.exists()) {
                stats = snapshot.val();
            }
        } catch (error) {
            console.error("Could not fetch stats from Firebase:", error);
        }
    }

    // Calculate the derived stats
    const winPct = stats.gamesPlayed > 0 ? ((stats.wins / stats.gamesPlayed) * 100).toFixed(1) : "0.0";
    const avgGuesses = stats.wins > 0 ? (stats.totalGuesses / stats.wins).toFixed(2) : "-";
    
    // Return a proper JavaScript object with key: value pairs
    return {
        username: user,
        gamesPlayed: stats.gamesPlayed,
        wins: stats.wins,
        totalGuesses: stats.totalGuesses,
        winPct: winPct,
        avgGuesses: avgGuesses
    };
}

async function startGame() {
    // 1. Get the username from localStorage just ONCE.
    const localHost = localStorage.getItem("gerNordleUsername");

    // 2. Check if it exists.
    if (!localHost) {
        showToast("You must be logged in to host a game.", "error");
        return;
    }

    // 3. Set the global 'hostUsername' variable for use in other functions (like generateResultText).
    //    The 'localHost' const will be used within this function.
    hostUsername = localHost;
    
    const isWordAvailable = await validateSecretWord();
    if (!isWordAvailable) {
        const secretInput = document.getElementById('secretInput');
        if (secretInput) {
            secretInput.classList.add('shake');
            setTimeout(() => secretInput.classList.remove('shake'), 500);
        }
        return;
    }

        // --- START: MODIFIED LOGIC TO GET GAME NUMBER ---
    let newGameNumber;
    try {
        const counterRef = database.ref('metadata/totalGames');
        const transactionResult = await counterRef.transaction(currentCount => {
            // If the counter doesn't exist, start it at 1. Otherwise, increment it.
            return (currentCount || 0) + 1;
        });

        if (!transactionResult.committed) {
            throw new Error("Failed to get a new game number from the database.");
        }
        newGameNumber = transactionResult.snapshot.val();
        gameNumber = newGameNumber; // Set the global variable for the current session

    } catch (error) {
        console.error("Could not generate game number:", error);
        showToast("Error creating game. Please try again.", "error");
        return;
    }

    const setupDiv = document.getElementById("setup");
    const headerSetup = document.getElementById("header-setup");
    const inputWord = germanFriendlyUpperCase(document.getElementById("secretInput").value.trim());
    const inputHint1 = document.getElementById("hintInput").value.trim();
    const inputHint2 = document.getElementById("hintInput2").value.trim();
    const inputHint3 = document.getElementById("hintInput3").value.trim();
    if (!inputHint1 || !inputHint2 || !inputHint3) {
        showToast("Hints must be filled out.", "error");
        return; // Stop the function if any required hints are missing
    }
    const inputHint4 = Array.from(document.querySelectorAll(".specialCharCheckbox:checked")).map(cb => cb.value).join(", ");
    const inputFunFact = document.getElementById("funFactInput").value.trim();

    secret = inputWord;
    customHint1 = inputHint1;
    customHint2 = inputHint2;
    customHint3 = inputHint3;
    customHint4 = inputHint4;
    customFunFact = inputFunFact;

    const metadataRef = database.ref('games/' + secret + '/metadata');
    try {
        const metadataToSave = {
            word: secret,
            hint1: customHint1, hint2: customHint2, hint3: customHint3,
            hint4: customHint4, funFact: customFunFact, host: localHost,
            gameNumber: newGameNumber
        };
        await metadataRef.set(metadataToSave);

        const sanitizedUsername = hostUsername.replace(/[.#$[\]]/g, '_');
        // 1. Check for 'Master Hintsmith' badge
        if (inputHint1 && inputHint2 && inputHint3 && inputHint4 && inputFunFact) {
            awardBadge(hostUsername, 'master_hintsmith');
        }

        // 2. Check for 'Prolific Host' and 'Community Pillar' badges
        const hostedGamesRef = database.ref(`userProfiles/${sanitizedUsername}/hostedGames`);
        const hostedSnapshot = await hostedGamesRef.once('value');
        const hostedCount = hostedSnapshot.numChildren();

        if (hostedCount + 1 >= 10) {
            awardBadge(hostUsername, 'prolific_host');
        }
        if (hostedCount + 1 >= 25) {
            awardBadge(hostUsername, 'community_pillar');
        }
        // --- END OF NEW LOGIC ---

        const userProfileRef = database.ref('userProfiles/' + sanitizedUsername);
        const newGameData = {};
        // Use the current date for the hosted game entry
        newGameData[`/hostedGames/${secret}`] = { createdDate: new Date().toISOString() };
        await userProfileRef.update(newGameData);

    } catch (error) {
        console.error("Firebase save failed:", error);
        return;
    }
    
    localStorage.removeItem('wurtleSetupState');

    const longUrl = generateShareURL(secret, customHint1, customHint2, customHint3, customHint4, customFunFact);
    const shareModal = document.getElementById("share-modal");
    const shareMessageBox = document.getElementById("share-message-box");
    const copyBtn = document.getElementById("copy-url-btn");
    const startBtn = document.getElementById("start-playing-btn");

    shareMessageBox.value = "Creating short link...";
    copyBtn.disabled = true;
    startBtn.disabled = true;
    shareModal.classList.add("show");
    setupDiv.inert = true;

    try {
        const shortenUrlFunction = firebase.functions().httpsCallable('shortenUrl');
        const result = await shortenUrlFunction({ url: longUrl });
        const shortUrl = result.data.shortUrl;
        
        shareMessageBox.value = shortUrl;
        await metadataRef.update({ shortUrl: shortUrl });
    } catch (error) {
        console.error("Could not shorten URL via Cloud Function:", error);
        shareMessageBox.value = longUrl; // Fallback to the long URL
    } finally {
        copyBtn.disabled = false;
        startBtn.disabled = false;
    }

    copyBtn.onclick = () => {
        shareMessageBox.select();
        navigator.clipboard.writeText(shareMessageBox.value).then(() => {
            copyBtn.textContent = "Copied!";
            setTimeout(() => { copyBtn.textContent = "Copy Text"; }, 2000);
        });
    };

    startBtn.onclick = () => {
        shareModal.classList.remove("show");
        window.history.replaceState({}, "", longUrl);

      const gameDiv = document.getElementById("game");
      const setupDiv = document.getElementById("setup");
      const headerSetup = document.getElementById("header-setup");

      // 1. Hide the setup view by adding the .hidden class
      setupDiv.classList.add('hidden');
      setupDiv.style.display = 'none'; // Also set style for immediate effect

      // 2. Show the game view by REMOVING the .hidden class
      headerSetup.classList.remove('hidden');
      gameDiv.classList.remove('hidden');
          
        // Show the game board. The header remains visible.
        gameDiv.style.display = "flex";
        gameDiv.style.flexDirection = "column";

        // This will initialize the game state and ensure the header has the correct content.
        checkUserStatus();
    };
}

async function checkUserStatus() {
    let savedUsername = localStorage.getItem("gerNordleUsername");
    const gameElement = document.getElementById("game");
    displayHostCredit();

    if (!savedUsername) {
        window.currentUsername = null;
        loadGameFromStorage();
        return;
    }

    window.currentUsername = savedUsername;
    listenForUserDeletion(savedUsername);

    try {
        const sanitizedUsername = savedUsername.replace(/[.#$[\]]/g, '_');

        // ✅ ADD THIS BLOCK to check for an ongoing daily game first
        if (isDailyGame) {
            const ongoingDailyRef = database.ref(`userProfiles/${sanitizedUsername}/ongoingDailyGame`);
            const dailySnapshot = await ongoingDailyRef.once('value');
            // Check if a temp game exists AND if its word matches today's secret word
            if (dailySnapshot.exists() && dailySnapshot.val().word === secret) {
                loadOngoingGame(dailySnapshot.val());
                return; // Exit early since we found the game
            }
        }

        // The rest of the function continues as before, checking the permanent list
        const playedGameRef = database.ref(`userProfiles/${sanitizedUsername}/playedGames/${secret}`);
        const playedGameSnapshot = await playedGameRef.once('value');

        if (playedGameSnapshot.exists()) {
            const playedGameData = playedGameSnapshot.val();
            const gameStatus = playedGameData.status;

            if (gameStatus === 'won' || gameStatus === 'lost') {
                gameElement.classList.add("dimmed");
                loadCompletedGame(playedGameData);
                return;
            }
            else if (gameStatus === 'ongoing') {
                loadOngoingGame(playedGameData);
                return;
            }
        }
        
        loadGameFromStorage();

    } catch (error) {
        console.error("Firebase completion check failed:", error);
        loadGameFromStorage();
    }
}
function loadGameFromStorage() {
    let savedUsername = localStorage.getItem("gerNordleUsername");
    const gameElement = document.getElementById("game");
    const headerSetup = document.getElementById("header-setup");
    
    const savedPin = localStorage.getItem("gerNordleUserPin");
    if (savedUsername && !savedPin) {
        localStorage.removeItem("gerNordleUsername");
        savedUsername = null;
    }

    initBoard();
    initKeyboard();

    if (savedUsername) {
        // Setup for a brand new game for a logged-in user
        usernameSet = true;
        grid = Array(rows).fill(null).map(() => Array(cols).fill(""));
        guessHistory = [];
        colorHistory = [];
        keyColors = {};
        currentRow = 0;
        currentCol = 0;
        isAnimating = false;
        hardModeWasDisabled = false;
        
        setupUsernameInterface({
            isGamePage: true,
            containerId: 'setup-username-area',
            inputId: 'usernameInputGame',
            placeholder: 'Enter username'
        });
        updateBoard();
        updateKeyboardColors();
        updateHintButtons();
        gameElement.classList.remove("dimmed");
        headerSetup.style.display = 'flex'; // Show the setup header
        gameElement.style.display = 'flex';
    
    } else {
        // Setup for a logged-out user
        updateHintButtons();
        setupUsernameInterface({
            isGamePage: true,
            containerId: 'setup-username-area', // Target the setup header's container
            inputId: 'usernameInputGame',
            placeholder: 'Enter username'
        });
        
        headerSetup.style.display = 'flex'; // Show the setup header
        gameElement.style.display = 'flex';
        gameElement.classList.add("dimmed");
    }
}

function updateBoard() {
  const board = document.getElementById("board");
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      board.children[r].children[c].textContent = grid[r][c];
    }
  }
}

function handleKeyPress(key) {
    if (!usernameSet || isAnimating) {
        return;
    }

    const msgEl = document.getElementById("message");
    if (msgEl.textContent.trim().startsWith("You win! 🎉") || msgEl.textContent.trim().startsWith("Game over!")) return;

    // Animate the on-screen keyboard button if it exists
    const keyButton = document.querySelector(`.key[data-key="${key.toUpperCase()}"], .key[data-key="ẞ"][data-key-lower="ß"]`);
    if (keyButton) {
        keyButton.classList.add("key-pop");
        setTimeout(() => {
            keyButton.classList.remove("key-pop");
        }, 100);
    }

    if (/^[a-zA-ZÄÖÜäöüßẞÆØÅæøå]$/.test(key) && currentCol < cols) {
        let letter = key;
        // This logic now correctly handles ß -> ẞ before any other uppercasing
        if (key === "ß") {
            letter = "ẞ";
        } else {
            letter = key.toUpperCase();
        }

        grid[currentRow][currentCol] = letter;
        currentCol++;
        updateBoard();
    } else if (key === "Backspace" && currentCol > 0) {
        currentCol--;
        grid[currentRow][currentCol] = "";
        updateBoard();
    } else if (key === "Enter" && currentCol === cols) {
        submitGuess();
    }
}

window.addEventListener("keydown", (e) => {
    if (isModalOpen) return;
    if (!usernameSet || isAnimating) return;
    if (document.getElementById("game").style.display !== "flex") return;

    const key = e.key; // Get the key without changing its case

    if (key === "Backspace") {
        handleKeyPress("Backspace");
    } else if (key === "Enter") {
        handleKeyPress("Enter");
    } else if (/^[a-zA-ZÄÖÜäöüßẞÆØÅæøå]$/.test(key)) { // Check for any valid letter
        handleKeyPress(key); // Pass the original, unaltered key
    }
});

function validateHardMode(guess) {
  for (let i = 0; i < guessHistory.length; i++) {
    const prevGuess = guessHistory[i];
    const colors = colorHistory[i];
    
    for (let j = 0; j < cols; j++) {
      if (colors[j] === "correct" && guess[j] !== prevGuess[j]) {
        return `Hard mode violation: Letter '${prevGuess[j]}' must be in position ${j+1}`;
      }
    }

    const presentLetters = {};
    for (let j = 0; j < cols; j++) {
      if (colors[j] === "present") {
        presentLetters[prevGuess[j]] = (presentLetters[prevGuess[j]] || 0) + 1;
      }
    }
    for (const letter in presentLetters) {
      const countInGuess = [...guess].filter(l => l === letter).length;
      if (countInGuess < presentLetters[letter]) {
        return `Hard mode violation: Guess must include letter '${letter}' at least ${presentLetters[letter]} time(s)`;
      }
    }

    for (let j = 0; j < cols; j++) {
      if (colors[j] === "absent") {
        const absentLetter = prevGuess[j];
        const isElsewherePresentOrCorrect = colors.some((color, idx) => 
          (color === "correct" || color === "present") && prevGuess[idx] === absentLetter);
        if (!isElsewherePresentOrCorrect) {
          if (guess.includes(absentLetter)) {
            return `Hard mode violation: Letter '${absentLetter}' cannot be used`;
          }
        }
      }
    }
  }
  return true;
}

async function loadAllWordLists() {
    console.log("Loading all word lists...");

    const promises = SUPPORTED_LANGUAGES.map(lang => {
        const filePath = `${lang}.txt`; // e.g., "german.txt"
        return fetch(filePath)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${filePath}`);
                }
                return response.text();
            })
            .then(text => ({ lang, text })); // Pass language name along with text
    });

    try {
        const results = await Promise.all(promises);

        results.forEach(({ lang, text }) => {
            const words = text.split(/\s+/);
            const wordSet = new Set();
            words.forEach(word => {
                if (word) {
                    wordSet.add(word.trim().toLowerCase());
                }
            });
            wordLists.set(lang, wordSet); // Add the language-specific set to our Map
        });

        // ✅ ADD THIS BLOCK to populate the global set
        allWordsSet.clear(); // Clear it first in case this is ever re-run
        for (const wordSet of wordLists.values()) {
            for (const word of wordSet) {
                allWordsSet.add(word);
            }
        }

        const totalWords = Array.from(wordLists.values()).reduce((sum, set) => sum + set.size, 0);
        console.log(`All word lists loaded! Total valid words: ${totalWords}`);

    } catch (error) {
        console.error("Could not load one or more word lists:", error);
    }
}

// ADD these two new functions right after 'loadAllWordLists'

/**
 * Finds the language a given word belongs to.
 * @param {string} word The word to search for (should be lowercase).
 * @returns {string|null} The name of the language or null if not found.
 */
function findWordLanguages(word) {
    const foundLanguages = []; // Initialize an empty array
    // Loop through all languages without stopping at the first match
    for (const [language, wordSet] of wordLists.entries()) {
        if (wordSet.has(word)) {
            foundLanguages.push(language); // Add every match to the array
        }
    }
    return foundLanguages; // Return the array of all languages found
}

function isValidWord(word) {
    // A word is valid if the array of languages is not empty.
    return findWordLanguages(word.toLowerCase()).length > 0;
}

async function submitGuess() {
    const guess = grid[currentRow].join("");
    const currentRowDiv = document.getElementById("board").children[currentRow];

    // This handles all validation checks before proceeding
    if (guess.length !== cols) {
        if (currentRowDiv) {
            currentRowDiv.classList.add("shake");
            setTimeout(() => { currentRowDiv.classList.remove("shake"); }, 500);
        }
        showToast("Not enough letters", "error");
        isAnimating = false;
        return;
    }

    if (!isValidWord(guess)) {
        if (currentRowDiv) {
            currentRowDiv.classList.add("shake");
            setTimeout(() => { currentRowDiv.classList.remove("shake"); }, 500);
        }
        showToast("Not in word list", "error");
        isAnimating = false;
        return;
    }

    // ✅ FIX: The hard mode validation and its toast message are now handled correctly.
      if (isHardMode) {
        const hardModeViolation = validateHardMode(guess);
        if (hardModeViolation !== true) { // Check if it returned a string message
            if (currentRowDiv) {
                currentRowDiv.classList.add("shake");
                setTimeout(() => { currentRowDiv.classList.remove("shake"); }, 500);
            }
            showToast(hardModeViolation, "error");
            isAnimating = false;
            return;
        }
    }

    isAnimating = true;
    document.getElementById("message").textContent = "";

    guessHistory.push(guess);
    
    // ...The rest of the function is correct and remains the same...

    const colors = Array(cols).fill("absent");
    const secretLetters = secret.split("");
    for (let i = 0; i < cols; i++) {
        if (guess[i] === secret[i]) {
            colors[i] = "correct";
            secretLetters[i] = null;
        }
    }
    for (let i = 0; i < cols; i++) {
        if (colors[i] === "correct") continue;
        const index = secretLetters.indexOf(guess[i]);
        if (index !== -1) {
            colors[i] = "present";
            secretLetters[index] = null;
        }
    }
    for (let i = 0; i < cols; i++) {
        const letter = guess[i];
        const color = colors[i];
        if (!keyColors[letter] || (color === "correct") || (color === "present" && keyColors[letter] === "absent")) {
            keyColors[letter] = color;
        }
    }

    colorHistory.push(colors);
    updateKeyboardColors();

    const board = document.getElementById("board");
    for (let i = 0; i < cols; i++) {
        const tile = board.children[currentRow].children[i];
        setTimeout(() => {
            tile.classList.add(colors[i]);
        }, i * 200);
    }

    setTimeout(async () => {
        if (guess === secret) {
            endGame(true);
        } else if (currentRow === rows - 1) {
            endGame(false);
        } else {
            currentRow++;
            currentCol = 0;
            updateHintButtons(); 
            isAnimating = false;
            await saveOngoingGame(window.currentUsername, base64Encode(secret));
        }
    }, (cols * 200) + 250);
}

async function endGame(won) {
    hideHintPopup();

    // Fetch the definitive fun fact from the database
    let definitiveFunFact = "";
    try {
        const metadataRef = database.ref(`games/${secret}/metadata`);
        const metaSnapshot = await metadataRef.once('value');
        if (metaSnapshot.exists()) {
            definitiveFunFact = metaSnapshot.val().funFact || "";
        }
    } catch (error) {
        console.error("Could not fetch metadata for final popup:", error);
        definitiveFunFact = customFunFact;
    }

    const gameResult = {
        isSolved: won,
        history: guessHistory,
        colors: colorHistory,
        hints: { hintUsed1, hintUsed2, hintUsed3, hintUsed4 },
        funFact: definitiveFunFact
    };

    // First, save the game data.
    try {
        await saveCompletedGameData(won);
    } catch (error) {
        console.error("Failed to save game results to Firebase:", error);
    }

    // Then, show the results modal.
    await showGameOverModal(
        gameResult.isSolved,
        gameResult.history,
        gameResult.colors,
        gameResult.hints,
        gameResult.funFact
    );

    // This block updates the underlying game board to the finished state
    setTimeout(() => {
        const gameContainer = document.getElementById('game');
        const messageEl = document.getElementById('message');
        const board = document.getElementById('board');

        // 1. Display the "You win!" or "Game over!" message on the board
        if (won) {
            messageEl.textContent = "You win! 🎉";
        } else {
            messageEl.textContent = `Game over! The word was ${secret}.`;
        }
        messageEl.classList.add('visible');

        // 2. Replace the interactive board with a static summary of the guesses
        board.innerHTML = generateGuessHistoryHTML(gameResult.history, gameResult.colors);

        // --- ADD THIS LINE ---
        // This removes the fixed grid layout, allowing the board to shrink to fit the content.
        board.style.gridTemplateRows = 'none';

        // 3. Dim and disable the game container
        gameContainer.style.opacity = '0.5';
        gameContainer.style.pointerEvents = 'none';

        // 4. Disable the keyboard
        disableKeyboard();

        // --- ADD THIS BLOCK ---
        // Visually update the toggle to reflect the game's true hard mode status.
        const toggle = document.getElementById('hard-mode-toggle');
        if (toggle) {
            // '!hardModeWasDisabled' is the final truth for whether the game was hard mode.
            toggle.checked = !hardModeWasDisabled;
            toggle.disabled = true; // Also ensure it's not clickable
        }
        // --- END OF NEW BLOCK ---

    }, 400);
}

function disableKeyboard() {
  // Disable all on-screen keys
  document.querySelectorAll('.key').forEach(keyBtn => {
    keyBtn.disabled = true;
  });
  document.getElementById('giveUpBtn').disabled = true;
  // Use the existing isAnimating flag to block physical keyboard input
  isAnimating = true; 
}

function initBoard() {
  const board = document.getElementById("board");
  board.innerHTML = "";
  for (let r = 0; r < rows; r++) {
    const rowDiv = document.createElement("div");
    rowDiv.classList.add("row");
    for (let c = 0; c < cols; c++) {
      const tileDiv = document.createElement("div");
      tileDiv.classList.add("tile");
      rowDiv.appendChild(tileDiv);
    }
    board.appendChild(rowDiv);
  }
}

function initKeyboard() {
  const keyboardDiv = document.getElementById("keyboard");
  keyboardDiv.innerHTML = "";
  const keysLayout = [
    ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "Å"],
    ["A", "S", "D", "F", "G", "H", "J", "K", "L", "Ö", "Ä", "Ø"],
    ["Enter", "Z", "X", "C", "V", "B", "N", "M", "Ü", "ẞ", "Æ", "Backspace"]
  ];

  keysLayout.forEach(row => {
    const rowDiv = document.createElement("div");
    rowDiv.classList.add("key-row");
    row.forEach(key => {
      const keyBtn = document.createElement("button");
      keyBtn.textContent = key;
      keyBtn.classList.add("key");
      keyBtn.dataset.key = key;
      keyBtn.onclick = () => handleKeyPress(key);
      rowDiv.appendChild(keyBtn);
    });
    keyboardDiv.appendChild(rowDiv);
  });
}

function updateKeyboardColors() {
    for (const key in keyColors) {
        const keyBtn = document.querySelector(`.key[data-key="${key}"]`);
        if (keyBtn) {
            keyBtn.classList.remove("present", "absent", "correct"); // Clear old colors
            keyBtn.classList.add(keyColors[key]);
        }
    }
}

function showHint(hintNumber) {
    let btn, hintText, hintContent;
    
    switch(hintNumber) {
        case 1:
            btn = document.getElementById('hintBtn1');
            hintContent = customHint1;
            if (hintUsed1) return; 
            hintUsed1 = true; 
            hintExpanded1 = true;
            break;
        case 2:
            btn = document.getElementById('hintBtn2');
            hintContent = customHint2;
            if (hintUsed2) return; 
            hintUsed2 = true; 
            hintExpanded2 = true;
            break;
        case 3:
            btn = document.getElementById('hintBtn3');
            hintContent = customHint3;
            if (hintUsed3) return; 
            hintUsed3 = true; 
            hintExpanded3 = true;
            break;
        case 4:
            btn = document.getElementById('hintBtn4');
            hintContent = customHint4;
            if (hintUsed4) return; 
            hintUsed4 = true; 
            hintExpanded4 = true;
            break;
    }

    if (btn && !btn.classList.contains('expanded')) {
        hintText = btn.querySelector('.hint-text');
        hintText.textContent = hintContent;
        btn.classList.add('expanded');
        hintText.classList.add('visible');
        btn.classList.add('clicked-hint');
        btn.disabled = true;
    }
    
    // ✅ Add this line to save the game state immediately
    if (window.currentUsername && secret) {
        saveOngoingGame(window.currentUsername, base64Encode(secret));
    }
}

function generateResultText(isForDisplay, history, colors, won, hintStatus) {
    let text = '';
    const guessCountText = `(${won ? history.length : 'X'}/${rows})`;

    // ✅ MODIFIED: Check if it's a daily game to change the header and add the date.
    if (isDailyGame) {
        const headerLine = `DAILY WØRTLE ${guessCountText}`;
        
        // Get and format the current date for the daily game
        const today = new Date();
        const options = { year: 'numeric', month: 'short', day: 'numeric' };
        const dateString = today.toLocaleDateString('en-GB', options);
        
        // Assemble the text with the header and date on separate lines
        text = headerLine + '\n' + dateString + '\n';
    } else {
        // This is the original logic for custom games
        let headerLine = `WØRTLE ${guessCountText}`;
        if (gameNumber) {
            headerLine = `WØRTLE #${gameNumber} ${guessCountText}`;
        }
        text = headerLine + '\n'; // Add extra newline for spacing
    }

    // Count the total number of hints used
    let hintCount = 0;
    if (hintStatus.hintUsed1) hintCount++;
    if (hintStatus.hintUsed2) hintCount++;
    if (hintStatus.hintUsed3) hintCount++;
    if (hintStatus.hintUsed4) hintCount++;

    // Add the emoji grid (this part remains the same)
    const colorMap = {
        correct: '🟩',
        present: '🟨',
        absent: '⬛'
    };

    for (let i = 0; i < colors.length; i++) {
        let rowText = colors[i].map(color => colorMap[color] || '⬛').join('');
        text += rowText + '\n';
    }

    // Add the hint summary sentence if any hints were used, followed by a blank line
    if (hintCount === 1) {
        text += "1 hint used\n";
    } else if (hintCount > 1) {
        text += `${hintCount} hints used\n`;
    } else {
        // If no hints were used, just add a blank line for spacing
        text += "\n";
    }

    return text;
}

function resetHints() {
    hintUsed1 = hintUsed2 = hintUsed3 = hintUsed4 = false;
    hintExpanded1 = hintExpanded2 = hintExpanded3 = hintExpanded4 = false; // Reset new variables
    ['hintBtn1', 'hintBtn2', 'hintBtn3', 'hintBtn4'].forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            btn.classList.remove('expanded', 'clicked-hint');
            btn.disabled = false;
            const hintTextSpan = btn.querySelector('.hint-text');
            if(hintTextSpan) {
              hintTextSpan.classList.remove('visible');
              hintTextSpan.textContent = '';
            }
            const hintLabel = btn.querySelector('.hint-label');
            if (hintLabel) {
                hintLabel.classList.remove('hidden');
            }
        }
    });
}
window.onload = async () => {
    await loadAllWordLists();

    const loader = document.getElementById('loader');
    const mainContent = document.getElementById('mainContent');
    const params = new URLSearchParams(window.location.search);

    const setupDiv = document.getElementById("setup");
    const gameDiv = document.getElementById("game");
    const messageEl = document.getElementById("message");
    const headerSetup = document.getElementById("header-setup");
    setupDiv.classList.add('hidden');
    gameDiv.classList.add('hidden');
    headerSetup.classList.add('hidden');
    let viewToShow = null; 
    
    // --- Step 1: Determine the secret word FIRST ---
    const isDaily = params.get("daily") === 'true';
    if (isDaily) {
        isDailyGame = true;
        try {
            const dailyRef = database.ref('dailyChallenge/word');
            const snapshot = await dailyRef.once('value');
            if (snapshot.exists()) {
                secret = snapshot.val().toUpperCase();
                displayLetterPattern(secret);
            } else {
                messageEl.textContent = "The Daily Wørtle has not been set yet. Please check back later!";
                loader.style.display = 'none';
                mainContent.classList.add('loaded');
                return; // Stop the function
            }
        } catch (error) {
            console.error("Could not fetch Daily Wørtle:", error);
            messageEl.textContent = "Could not load the Daily Wørtle. Please try again.";
            loader.style.display = 'none';
            mainContent.classList.add('loaded');
            return; // Stop the function
        }
    } else {
        // This is the original logic for custom games
        secret = getSecretFromURL();
    }

    // --- Step 2: NOW, based on whether we have a secret, render the correct page ---
    if (secret) {
        // This block now runs for BOTH daily and custom games.
        
        // For custom games, we need to fetch metadata. For daily games, we skip this.
        if (!isDaily) {
            const gameRef = database.ref('games/' + secret);
            const snapshot = await gameRef.once('value');
            if (!snapshot.exists()) {
                messageEl.innerHTML = `The game you are looking for does not exist or has been deleted.<br><br><a href="/wortle" style="text-decoration: underline;">Create a new game</a>`;
                loader.style.display = 'none';
                mainContent.classList.add('loaded');
                return; // Stop if the custom game doesn't exist
            }
            const metadata = snapshot.val().metadata;
            if (metadata) {
                gameNumber = metadata.gameNumber;
                hostUsername = metadata.host;
            }
        }
        
        checkUserStatus(); // This will load the board for play
        viewToShow = 'game';

    } else {
        // This logic only runs if it's not a daily game and no custom game is in the URL
        headerSetup.style.display = "flex";
        setupDiv.style.display = "block";
    
        const savedUsername = localStorage.getItem("gerNordleUsername");
        if (savedUsername) {
            listenForUserDeletion(savedUsername);
        }
        
        setupUsernameInterface({
            isGamePage: false,
            containerId: 'setup-username-area',
            inputId: 'usernameInputHost',
            placeholder: 'Enter username'
        });

        loadSetupState();
        validateSecretWord();
        
        const setupInputs = [
            document.getElementById('secretInput'),
            document.getElementById('hintInput'),
            document.getElementById('hintInput2'),
            document.getElementById('hintInput3'),
            document.getElementById('funFactInput')
        ];
        setupInputs.forEach(input => input.addEventListener('input', saveSetupState));
        // --- THIS LINE IS NOW CORRECTED ---
        document.querySelectorAll('.specialCharCheckbox').forEach(cb => cb.addEventListener('change', saveSetupState));
        viewToShow = 'setup';

      }

    if (viewToShow === 'game') {
        headerSetup.classList.remove('hidden');
        gameDiv.classList.remove('hidden');
    } else if (viewToShow === 'setup') {
        headerSetup.classList.remove('hidden');
        setupDiv.classList.remove('hidden');
    }

    loader.style.display = 'none';
    mainContent.classList.add('loaded');

    const secretInput = document.getElementById('secretInput');
if (secretInput) {
    secretInput.addEventListener('input', () => {
        // --- START: Real-time uppercase conversion ---
        const selectionStart = secretInput.selectionStart;
        const selectionEnd = secretInput.selectionEnd;
        // Use the German-friendly function to correctly uppercase the input value
        secretInput.value = germanFriendlyUpperCase(secretInput.value);
        // Restore the cursor position
        secretInput.setSelectionRange(selectionStart, selectionEnd);
        // --- END: Real-time uppercase conversion ---
            clearTimeout(debounceTimer);
            const indicator = document.getElementById('word-status-indicator');
            indicator.innerHTML = ''; 
            indicator.className = 'loading'; 
            debounceTimer = setTimeout(() => {
                validateSecretWord();
            }, 500); 
        });
    }
};

function renderPlayedGames(snapshot) {
    const playedGamesList = document.getElementById('played-games-list');
    const titleElement = document.getElementById('played-games-title');

    if (!snapshot.exists()) {
        if (titleElement) titleElement.textContent = 'Played Games (0)';
        playedGamesList.innerHTML = '<p style="padding: 10px;">You have not played any games.</p>';
        if (resolvePlayedGames) resolvePlayedGames();
        return;
    }

    const gamesObject = snapshot.val();
    const allGames = [];
    for (const word in gamesObject) {
        allGames.push({ word: word, ...gamesObject[word] });
    }

    // --- ✅ UPDATED: LOGIC FOR FORMATTING THE TITLE ---
    if (titleElement) {
        const currentUsername = localStorage.getItem("gerNordleUsername");
        let gamesByOthersCount = 0;
        let gamesBySelfCount = 0;

        for (const game of allGames) {
            if (game.host && game.host === currentUsername) {
                gamesBySelfCount++;
            } else {
                gamesByOthersCount++;
            }
        }

        // Check if any self-hosted games have been played
        if (gamesBySelfCount > 0) {
            titleElement.textContent = `Played Games (${gamesByOthersCount}, ${gamesBySelfCount})`;
        } else {
            titleElement.textContent = `Played Games (${gamesByOthersCount})`;
        }
    }
    // --- END OF UPDATED LOGIC ---

    const currentUsername = localStorage.getItem("gerNordleUsername");
    const renderedElements = [];

    // --- NEW: Separate daily games from custom games ---
    const dailyGames = allGames.filter(game => game.host === 'WØRTLE');
    const customGames = allGames.filter(game => game.host !== 'WØRTLE');

    // First, create the HTML for daily games (they don't need metadata)
    dailyGames.forEach(gameData => {
        const gameElement = document.createElement('div');
        gameElement.className = 'game-list-item-no-link';

        const wordSpan = document.createElement('span');
        wordSpan.innerHTML = `${gameData.word} <span style="color: var(--accent-color); font-weight: bold;">(Daily)</span>`;
        
        const statusSpan = document.createElement('span');
        statusSpan.className = 'game-status';
        if (gameData.status === 'won') statusSpan.textContent = `Won (${gameData.guesses}/${rows})`;
        else if (gameData.status === 'lost') statusSpan.textContent = 'Lost';
        else statusSpan.textContent = 'In progress';

        gameElement.appendChild(wordSpan);
        gameElement.appendChild(statusSpan);
        renderedElements.push({ element: gameElement, date: new Date(gameData.createdDate) });
    });

    // Now, fetch metadata ONLY for the custom games
    const metaPromises = customGames.map(game => database.ref(`games/${game.word}/metadata`).once('value'));

    Promise.all(metaPromises).then(metaSnapshots => {
        metaSnapshots.forEach((metaSnap, idx) => {
            if (metaSnap.exists()) {
                const meta = metaSnap.val();
                const gameData = customGames[idx];
                const gameLink = document.createElement('a');
                gameLink.className = 'game-list-item';
                gameLink.href = generateShareURL(meta.word, meta.hint1, meta.hint2, meta.hint3, meta.hint4, meta.funFact);
                
                const wordSpan = document.createElement('span');
                let wordText = (gameData.status === 'won' || gameData.status === 'lost') ? meta.word : '?????';

                if (meta.host && meta.host === currentUsername) {
                    wordText += ` <span style="color: #951414; font-weight: bold;">H</span>`;
                }
                wordSpan.innerHTML = wordText;

                const statusSpan = document.createElement('span');
                statusSpan.className = 'game-status';
                if (gameData.status === 'won') statusSpan.textContent = `Won (${gameData.guesses}/${rows})`;
                else if (gameData.status === 'lost') statusSpan.textContent = 'Lost';
                else statusSpan.textContent = 'In progress';
                
                gameLink.appendChild(wordSpan);
                gameLink.appendChild(statusSpan);
                renderedElements.push({ element: gameLink, date: new Date(gameData.createdDate) });
            }
        });

        // Sort all the generated elements by date
        renderedElements.sort((a, b) => b.date - a.date);
        
        const fragment = document.createDocumentFragment();
        renderedElements.forEach(item => fragment.appendChild(item.element));
        
        playedGamesList.innerHTML = ''; // Clear any previous content
        playedGamesList.appendChild(fragment);

        if (resolvePlayedGames) {
            resolvePlayedGames();
            resolvePlayedGames = null;
        }
    });
}

async function saveOngoingGame(username, encodedSecret) {
    if (!username || !encodedSecret) return;
    
    const word = base64Decode(encodedSecret);
    if (!word) return;

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    
    // Package the entire current game state
    const ongoingStateForFirebase = {
        word: secret, // Store the secret word to prevent loading the wrong game
        status: 'ongoing',
        lastPlayedDate: new Date().toISOString(),
        grid: grid,
        currentRow: currentRow,
        guessHistory: guessHistory,
        colorHistory: colorHistory,
        keyColors: keyColors,
        isHardMode: isHardMode,
        hardModeWasDisabled: hardModeWasDisabled,
        hintStatus: { hintUsed1, hintUsed2, hintUsed3, hintUsed4, hintExpanded1, hintExpanded2, hintExpanded3, hintExpanded4 }
    };

    // ✅ CHANGE: Check if it's a daily game
    if (isDailyGame) {
        // For daily games, save to a temporary, singular location
        const dailyGameRef = database.ref(`userProfiles/${sanitizedUsername}/ongoingDailyGame`);
        await dailyGameRef.set(ongoingStateForFirebase);
    } else {
        // For custom games, save to the permanent "playedGames" list as before
        const playedGameRef = database.ref(`userProfiles/${sanitizedUsername}/playedGames/${word}`);
        const snapshot = await playedGameRef.once('value');
        const existingData = snapshot.val();
        const createdDate = existingData?.createdDate || new Date().toISOString();
        ongoingStateForFirebase.createdDate = createdDate; // Add createdDate for custom games
        
        await playedGameRef.set(ongoingStateForFirebase);
        
        const isFirstGuess = guessHistory.length === 1;
        if (isFirstGuess) {
            const centralPlayerListRef = database.ref(`games/${word}/players/${sanitizedUsername}`);
            await centralPlayerListRef.set(true);
        }
    }
    
    // Local storage saving can remain for both for quick refreshes
    const allGameData = JSON.parse(localStorage.getItem("gerNordleGameData") || "{}");
    if (!allGameData[username]) allGameData[username] = {};
    allGameData[username][encodedSecret] = {
        ongoingState: ongoingStateForFirebase,
        createdDate: ongoingStateForFirebase.createdDate || new Date().toISOString()
    };
    localStorage.setItem("gerNordleGameData", JSON.stringify(allGameData));
}


const helpBtn = document.getElementById("helpBtn");
const helpPopup = document.getElementById("helpPopup");
const closeHelpBtn = document.getElementById("closeHelpBtn");
const helpOverlay = document.getElementById("helpOverlay");
const mainContent = document.getElementById("mainContent");
// Add this to your script
const giveUpBtn = document.getElementById('giveUpBtn');
if (giveUpBtn) {
    giveUpBtn.addEventListener('click', handleGiveUp);
}

function showHelpPopup() {
  isModalOpen = true;
  helpPopup.hidden = false;
  helpOverlay.classList.add('show');
  mainContent.inert = true;
  mainContent.setAttribute('aria-hidden', 'true');
  setInputsDisabled(true);
  helpPopup.focus();
}

function hideHelpPopup() {
  isModalOpen = false;
  helpPopup.hidden = true;
  helpOverlay.classList.remove('show');
  mainContent.inert = false;
  mainContent.removeAttribute('aria-hidden');
  setInputsDisabled(false);
}

// Find the new button in the document
const newGameBtn = document.getElementById("newGameBtn");

// This function navigates to the base URL of your site
function goToHostPage() {
  // window.location.origin provides the base URL (e.g., "https://your-site.com")
  window.location.href = window.location.origin + window.location.pathname;
}

// Attach the function to the button's click event
if (newGameBtn) {
  newGameBtn.addEventListener("click", goToHostPage);
}

helpBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  if (helpPopup.hidden) {
    showHelpPopup();
  } else {
    hideHelpPopup();
  }
});

closeHelpBtn.addEventListener("click", () => {
  hideHelpPopup();
});

helpOverlay.addEventListener("click", () => {
  hideHelpPopup();
});

// Global keydown: block all keys except Ctrl/Meta shortcuts and Escape when popup is visible
document.addEventListener("keydown", (event) => {
  if (!helpPopup.hidden) {
    // Allow Escape to close popup
    if (event.key === "Escape") {
      return;
    }

    // For Cmd/Ctrl + key combos like Cmd+C:
    if (event.ctrlKey || event.metaKey) {
      // Stop propagation to prevent Wordle input, but allow native shortcut
      event.stopImmediatePropagation();
      // Don't preventDefault here so native shortcut works
      return;
    }

    // Block all other keys completely (typing)
    event.preventDefault();
    event.stopImmediatePropagation();
  }
}, true);

// Also block typing on Wordle input elements specifically except shortcuts and Escape
const wordleInputs = mainContent.querySelectorAll('input, textarea, [contenteditable="true"]');
wordleInputs.forEach(input => {
  input.addEventListener('keydown', (event) => {
    if (!helpPopup.hidden) {
      if (event.ctrlKey || event.metaKey || event.key === "Escape") {
        return; // allow shortcuts and Escape
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    }
  }, true);
});

// Optional: allow Escape to close popup (already handled above, but keep if needed)
document.addEventListener("keydown", (event) => {
  if (!helpPopup.hidden && event.key === "Escape") {
    hideHelpPopup();
  }
});

// Prevent clicks inside popup from closing it
helpPopup.addEventListener("click", (event) => {
  event.stopPropagation();
});

function setInputsDisabled(state) {
    const inputs = mainContent.querySelectorAll('input, textarea, [contenteditable="true"], button, select');
    inputs.forEach(el => {
        if (state === true) {
            // When disabling, disable everything.
            el.disabled = true;
            el.setAttribute('aria-disabled', 'true');
            el.blur();
        } else {
            // When re-enabling, ONLY enable elements that are NOT auto-populated.
            if (!el.classList.contains('is-auto-populated')) {
                el.disabled = false;
                el.removeAttribute('aria-disabled');
            }
        }
    });
}

function updateHintButtons() {
    const hintButtons = [
        document.getElementById("hintBtn1"),
        document.getElementById("hintBtn2"),
        document.getElementById("hintBtn3"),
        document.getElementById("hintBtn4")
    ];
    const hintUnlockMessage = document.getElementById('hint-unlock-message');
    const hintUnlockNextMessage = document.getElementById('hint-unlock-next-message'); // Get the new message element
    const hintButtonsContainer = document.getElementById('hintButtonsContainer');

    const hints = [customHint1, customHint2, customHint3, customHint4];
    const hintUsedFlags = [hintUsed1, hintUsed2, hintUsed3, hintUsed4];
    const hintExpandedFlags = [hintExpanded1, hintExpanded2, hintExpanded3, hintExpanded4];

    const guessCount = guessHistory.length;
    let hasAnyAvailableHints = hints.some(hint => hint && hint.trim() !== "");
    
    document.getElementById("hintButtons").style.display = hasAnyAvailableHints ? "block" : "none";

    if (guessCount < 2) {
        hintUnlockMessage.textContent = "Enter at least 2 guesses to start unlocking hints.";
        hintUnlockMessage.style.display = 'block';
        hintButtonsContainer.style.display = 'none';
        hintUnlockNextMessage.style.display = 'none'; // Ensure next-hint message is hidden
        return;
    }

    hintUnlockMessage.style.display = 'none';
    hintButtonsContainer.style.display = 'flex';

    const unlockThresholds = [2, 3, 4, 5];

    for (let i = 0; i < 4; i++) {
        const btn = hintButtons[i];
        const hintContent = hints[i];
        const isUnlocked = guessCount >= unlockThresholds[i];
        
        if (!hintContent || hintContent.trim() === "") {
            btn.style.display = "none";
            continue;
        }

        btn.style.display = isUnlocked ? "inline-flex" : "none";

        if (isUnlocked) {
            const used = hintUsedFlags[i];
            const expanded = hintExpandedFlags[i];

            if (used) {
                btn.classList.add('clicked-hint');
                btn.disabled = true;

                if (expanded) {
                    const hintTextSpan = btn.querySelector('.hint-text');
                    if (hintTextSpan) {
                        hintTextSpan.textContent = hintContent;
                        hintTextSpan.classList.add('visible');
                    }
                    btn.classList.add('expanded');
                }
            } else {
                btn.disabled = false;
                btn.classList.remove('clicked-hint', 'expanded');
                const hintTextSpan = btn.querySelector('.hint-text');
                if (hintTextSpan) {
                    hintTextSpan.classList.remove('visible');
                    hintTextSpan.textContent = "";
                }
                btn.querySelector('.hint-label').classList.remove('hidden');
            }
        }
    }

    // --- START: NEW LOGIC FOR "UNLOCK NEXT" MESSAGE ---
    hintUnlockNextMessage.style.display = 'none'; // Hide by default

    // Determine if the *next* potential hint exists
    let nextHintExists = false;
    if (guessCount === 2 && hints[1] && hints[1].trim() !== "") nextHintExists = true;
    if (guessCount === 3 && hints[2] && hints[2].trim() !== "") nextHintExists = true;
    if (guessCount === 4 && hints[3] && hints[3].trim() !== "") nextHintExists = true;

    // Show the message if appropriate
    if (guessCount >= 2 && guessCount < 5 && nextHintExists) {
        hintUnlockNextMessage.textContent = "Enter one more guess to unlock another hint.";
        hintUnlockNextMessage.style.display = 'block';
    }
    // --- END: NEW LOGIC FOR "UNLOCK NEXT" MESSAGE ---
}

function bindModalButtons(savedGuessHistory, savedColorHistory, isSolved, savedHintStatus) {
    const modalCopyBtn = document.getElementById("modalCopyBtn");
    const showStatsBtn = document.getElementById("showStatsBtn");
    const showScoreboardBtn = document.getElementById("showScoreboardBtn");
    const closeModalBtn = document.getElementById("closeModalBtn"); // --- Find the new button

    // --- ADD THIS BLOCK ---
    if (closeModalBtn) {
        closeModalBtn.onclick = closeGameOverModal;
    }

    // --- 1. Copy Result Button ---
    if (modalCopyBtn) {
        modalCopyBtn.onclick = () => {
            const resultText = generateResultText(false, savedGuessHistory, savedColorHistory, isSolved, savedHintStatus);
            navigator.clipboard.writeText(resultText).then(() => {
                modalCopyBtn.innerHTML = "<i>Copied!</i>";
                modalCopyBtn.disabled = true;
                setTimeout(() => {
                    modalCopyBtn.innerHTML = "Copy Result";
                    modalCopyBtn.disabled = false;
                }, 1500);
            });
        };
    }

    // --- 3. View/Hide Scoreboard Button (MODIFIED) ---
    if (showScoreboardBtn) {
        // Set initial text
        showScoreboardBtn.textContent = "View Scoreboard";
        
        showScoreboardBtn.onclick = () => {
            const scoreboardPanel = document.getElementById('scoreboard-panel');
            // Check if the panel is already visible
            if (scoreboardPanel.classList.contains('show')) {
                hideScoreboard(); // If yes, hide it
            } else {
                showScoreboard(); // If no, show it
            }
        };
    }
}

function showHintPopup() {
  hintPopup.classList.add("show");
  document.addEventListener("keydown", handleTypingToClose);
}

function hideHintPopup() {
  hintPopup.classList.remove("show");
  document.removeEventListener("keydown", handleTypingToClose);
}
// Event listeners for the hint popup
if (hintTitle) {
  hintTitle.addEventListener("click", showHintPopup);
}
if (closeHintPopupBtn) {
  closeHintPopupBtn.addEventListener("click", hideHintPopup);
}

// This handles the "click outside" functionality
if (hintPopupOverlay) {
  hintPopupOverlay.addEventListener("click", hideHintPopup);
}

// This prevents clicks *inside* the popup from closing it
if (hintPopup) {
  hintPopup.addEventListener("click", (event) => {
    event.stopPropagation();
  });
}
// --- Add this new function to your script ---

async function generateRandomWord() {
    const generateBtn = document.getElementById("generateWordBtn");
    const secretInput = document.getElementById("secretInput");
    const indicator = document.getElementById("word-status-indicator");

    // CHANGED: Check the new wordLists Map instead of the old Set.
    if (wordLists.size === 0) {
        showToast("Word lists are still loading. Please wait a moment and try again.", "error");
        return;
    }

    // Set the UI to a "loading" state
    if (generateBtn) generateBtn.disabled = true;
    secretInput.value = '';
    indicator.innerHTML = '';
    indicator.className = 'loading';

    // CHANGED: Create a flat array of all words from all languages in the Map.
    const allWordsArray = [...wordLists.values()].flatMap(wordSet => [...wordSet]);
    let foundWord = null;
    let attempts = 0;
    const maxAttempts = 50; // Safety limit to prevent an infinite loop
    let hadError = false;

    while (!foundWord && attempts < maxAttempts) {
        attempts++;
        const randomIndex = Math.floor(Math.random() * allWordsArray.length);
        const randomWord = allWordsArray[randomIndex].toUpperCase();

        try {
            const gameRef = database.ref('games/' + randomWord);
            const snapshot = await gameRef.once('value');
            if (!snapshot.exists()) {
                foundWord = randomWord; // We found an available word!
            }
        } catch (error) {
            console.error("Database error while finding a random word:", error);
            hadError = true;
            break; // Exit the loop on a database error
        }
    }

    // --- Final UI update after the search is complete ---

    // Always remove the loading spinner
    indicator.className = '';
    indicator.innerHTML = '';

    if (foundWord) {
        secretInput.value = foundWord;
        // ADDED: Call validateSecretWord() to trigger the check mark AND auto-populate hints.
        validateSecretWord();
    } else {
        // If we failed, show an error icon briefly
        console.warn("Could not find an available random word after several attempts.");
        if (hadError) {
            indicator.innerHTML = '⚠️';
            indicator.className = 'invalid';
            // Clear the error icon after a few seconds
            setTimeout(() => { indicator.innerHTML = ''; indicator.className = ''; }, 2500);
        }
    }

    // Always re-enable the button
    if (generateBtn) generateBtn.disabled = false;
}

// --- Add this event listener to make the button work ---

// Find the new button in the document
const generateBtn = document.getElementById("generateWordBtn");

// Attach the function to the button's click event
if (generateBtn) {
  generateBtn.addEventListener("click", generateRandomWord);
}

// --- Find the new scoreboard elements ---
const scoreboardPanel = document.getElementById('scoreboard-panel');

function showScoreboard() {
  const showScoreboardBtn = document.getElementById('showScoreboardBtn');
  // First, fetch the data and populate the panel
  fetchAndDisplayScoreboard();
  // Then, slide the panel into view
  scoreboardPanel.classList.add('show');
  // Update button text
  if (showScoreboardBtn) {
    showScoreboardBtn.textContent = 'Hide Scoreboard';
  }
}

// This function now hides the side panel
function hideScoreboard() {
  const showScoreboardBtn = document.getElementById('showScoreboardBtn');
  scoreboardPanel.classList.remove('show');
  
  // Reset the button text
  if (showScoreboardBtn) {
    showScoreboardBtn.textContent = 'View Scoreboard';
  }
  
  // Clean up the real-time listener to prevent memory leaks
  if (scoreboardListener && secret) {
      const gameRef = database.ref('games/' + secret);
      gameRef.off('value', scoreboardListener);
      scoreboardListener = null; // Clear the variable
  }
}

function fetchAndDisplayScoreboard() {
    if (!secret) return;

    const container = document.getElementById('scoreboard-container');
    const wordDisplay = document.getElementById('scoreboard-word');
    const summaryContainer = document.getElementById('scoreboard-summary-container');
    
    if (!container || !wordDisplay || !summaryContainer) {
        console.error("Scoreboard HTML elements not found! Check your element IDs.");
        return; 
    }

    const gameRef = database.ref('games/' + secret);

    wordDisplay.textContent = secret;
    container.innerHTML = '<p>Loading scores...</p>';
    summaryContainer.innerHTML = '';

    if (scoreboardListener) {
        gameRef.off('value', scoreboardListener);
    }
    
    scoreboardListener = gameRef.on('value', (snapshot) => {
        const scoresData = snapshot.val();

        if (!scoresData) {
            container.innerHTML = '<p>Be the first to set a score!</p>';
            return;
        }

        // ✅ Step 1: Get the host's name from the game's metadata.
        const hostName = scoresData.metadata ? scoresData.metadata.host : null;

        const playerScores = Object.keys(scoresData)
            .filter(key => key !== 'metadata' && key !== 'players') 
            .map(key => scoresData[key]);

        if (playerScores.length === 0) {
            container.innerHTML = '<p>Be the first to set a score!</p>';
            summaryContainer.innerHTML = ''; 
            return;
        }
        
        const totalPlayers = playerScores.length;
        const winners = playerScores.filter(score => score.guesses > 0);
        const totalWinners = winners.length;
        const solveRate = totalPlayers > 0 ? (totalWinners / totalPlayers) * 100 : 0;
        const totalGuesses = winners.reduce((sum, player) => sum + player.guesses, 0);
        const avgGuesses = totalWinners > 0 ? totalGuesses / totalWinners : 0;

        summaryContainer.innerHTML = `
            <div class="summary-stat">
                <span class="stat-label">Solve Rate</span>
                <div class="stat-bar-container">
                    <div class="stat-bar" style="width: ${solveRate.toFixed(1)}%;">${solveRate.toFixed(1)}%</div>
                </div>
            </div>
            <div class="summary-stat">
                <span class="stat-label">Avg. Guesses</span>
                <div class="stat-bar-container">
                    <div class="stat-bar" style="width: ${(avgGuesses / rows) * 100}%;">${avgGuesses.toFixed(1)}</div>
                </div>
            </div>
        `;

        winners.sort((a, b) => {
            const guessDifference = a.guesses - b.guesses;
            if (guessDifference !== 0) return guessDifference;
            return (a.hintCount || 0) - (b.hintCount || 0);
        });

        const losers = playerScores.filter(score => score.guesses <= 0);
        const sortedScores = [...winners, ...losers];

        let tableHTML = `
            <table>
                <thead><tr><th>Rank</th><th>Player</th><th>Guesses</th><th>Hints</th></tr></thead>
                <tbody>`;

        sortedScores.forEach((score, index) => {
            const guessDisplay = score.guesses > 0 ? score.guesses : 'X';

            // ✅ Step 2: Check if the current player is the host and prepare the display name.
            let nameDisplay = score.username;
            if (hostName && score.username === hostName) {
                nameDisplay += ` <span style="color: #951414; font-weight: bold;">H</span>`;
            }

            // ✅ Step 3: Use the new display name in the table row.
            tableHTML += `
                <tr>
                    <td>${index + 1}</td>
                    <td>${nameDisplay}</td>
                    <td>${guessDisplay}</td>
                    <td>${score.hintCount || 0}</td>
                </tr>`;
        });

        tableHTML += '</tbody></table>';
        container.innerHTML = tableHTML;

    }, (error) => {
        console.error("Firebase listener error:", error);
        container.innerHTML = '<p>Could not load scores due to an error.</p>';
        summaryContainer.innerHTML = '<p style="text-align:center;">Could not load stats.</p>';
    });
}

function closeGameOverModal() {
    isModalOpen = false;
    // Check the URL to see if we are in the special scoreboard view
    const params = new URLSearchParams(window.location.search);
    const isScoreboardView = params.get('view') === 'scoreboard';

    if (isScoreboardView) {
        // If we are in scoreboard view, navigate back to the main page.
        history.back();
    } else {
        // Otherwise, just hide the modal as usual.
        const overlay = document.getElementById('game-over-overlay');
        if (overlay) {
            overlay.classList.remove('show');
        }
        hideScoreboard();
    }
}

function generateGuessHistoryHTML(guessHistory, colorHistory) {
  let historyHtml = '';
  
  // Loop through each guess
  for (let i = 0; i < guessHistory.length; i++) {
    const guess = guessHistory[i];
    const colors = colorHistory[i];
    historyHtml += '<div class="row">';
    // Loop through each letter in the guess
    for (let j = 0; j < guess.length; j++) {
      const letter = guess[j];
      const colorClass = colors[j]; // 'correct', 'present', or 'absent'
      // Create a tile with the original classes for styling
      historyHtml += `<div class="tile ${colorClass}">${letter}</div>`;
    }
    historyHtml += '</div>';
  }
  return historyHtml;
}

async function loginUser(inputId, pinInputId, config) {
    const usernameInput = document.getElementById(inputId);
    const pinInput = document.getElementById(pinInputId);
    const username = usernameInput.value.trim().toUpperCase();
    const pin = pinInput.value.trim();

    if (!username || !pin) {
        showToast("Please enter both a username and a PIN.", "error");
        return;
    }
    if (username.length > 10) {
        showToast("Username cannot be more than 10 characters long.", "error");
        return;
    }

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const userRef = database.ref('users/' + sanitizedUsername);

    try {
        const snapshot = await userRef.once('value');
        if (snapshot.exists()) {
            const userData = snapshot.val();
            if (userData.pin === pin) {
                // PIN is correct! Log the user in.
                localStorage.setItem("gerNordleUsername", username);
                localStorage.setItem("gerNordleUserPin", pin); 
                window.location.reload();
                // Refresh the UI
                if (config.isGamePage) {
                    checkUserStatus();
                } else {
                    setupUsernameInterface(config);
                }
            } else {
                showToast("Incorrect PIN. Please try again.", "error");
            }
        } else {
            showToast(`Username "${username}" does not exist. Please register first.`, "error");
        }
    } catch (error) {
        console.error("Login error:", error);
        showToast("Could not log in. Please check your connection.", "error");
    }
}

async function registerUser(inputId, pinInputId, config) {
    const usernameInput = document.getElementById(inputId);
    const pinInput = document.getElementById(pinInputId);
    const username = usernameInput.value.trim().toUpperCase();
    const pin = pinInput.value.trim();

    if (!username || !pin) {
        showToast("Please enter both a username and a PIN.", "error");
        return;
    }
    if (username.length < 3) {
        showToast("Username must be at least 3 characters long.", "error");
        return;
    }
    if (username.length > 10) {
        showToast("Username cannot be more than 10 characters long.", "error");
        return;
    }
    if (pin.length !== 4 || isNaN(pin)) {
        showToast("Your PIN must be 4 digits.", "error");
        return;
    }

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const userRef = database.ref('users/' + sanitizedUsername);

    try {
        const snapshot = await userRef.once('value');
        if (snapshot.exists()) {
            showToast(`The username "${username}" is already taken. Please try logging in or choose another name.`, "error");
        } else {
            // Username is available, register it with the PIN.
            await userRef.set({
                original: username,
                pin: pin, // Store the PIN
                registeredAt: firebase.database.ServerValue.TIMESTAMP
            });

            // Automatically log the user in after registration.
            localStorage.setItem("gerNordleUsername", username);
            localStorage.setItem("gerNordleUserPin", pin);
          showLanguagePopup(username, true); 
        }
    } catch (error) {
        console.error("Registration error:", error);
        showToast("Could not register username. Please try again.", "error");
    }
}

function setupUsernameInterface(config) {
    const { isGamePage, containerId, inputId, placeholder } = config;
    const pinInputId = inputId + '-pin';
    const container = document.getElementById(containerId);
    if (!container) return;

    const savedUsername = localStorage.getItem("gerNordleUsername");
    
    // Clear the specific container we're working with.
    container.innerHTML = ''; 
    // Remove any special layout classes before we start
    container.classList.remove('login-prompt-container');

    if (savedUsername) {
        // This block now correctly handles the display for a LOGGED-IN user on BOTH pages.
        const displayMessage = document.createElement("p");
        displayMessage.textContent = `Logged in as: ${savedUsername.toUpperCase()}`;

        const changeButton = document.createElement("button");
        changeButton.textContent = "Change User";
        changeButton.onclick = () => {
                document.getElementById('game').classList.add('dimmed');
                document.getElementById('setup-form-content').classList.add('dimmed');
                stopUserDeletionListener();
                localStorage.removeItem("gerNordleUsername");
                localStorage.removeItem("gerNordleUserPin");
                setupUsernameInterface(config);
            };
        changeButton.classList.add("styled-button");

        container.appendChild(displayMessage);
        container.appendChild(changeButton);

        // Only interact with the setup form if we are on the setup page.
        if (!isGamePage) {
            document.getElementById('setup-form-content').classList.remove('dimmed');
        }
    } else {
        // This block handles the display for a LOGGED-OUT user.
        if (!isGamePage) {
            document.getElementById('setup-form-content').classList.add('dimmed');
        }

        // ✨ APPLY THE NEW CLASS to the container
        container.classList.add('login-prompt-container');
        
        const usernameInput = document.createElement("input");
        usernameInput.type = "text";
        usernameInput.id = inputId;
        usernameInput.placeholder = placeholder;
        usernameInput.maxLength = 10; 
        usernameInput.style.cssText = "padding: 3px 6px; border-radius: 6px; margin: 0px; width: 140px;";

        const pinInput = document.createElement("input");
        pinInput.type = "password";
        pinInput.id = pinInputId;
        pinInput.placeholder = "4-digit PIN";
        pinInput.maxLength = 4;
        pinInput.style.cssText = "padding: 3px 6px; border-radius: 6px; margin: 0px; width: 100px;";

        const loginButton = document.createElement("button");
        loginButton.textContent = "Login";
        loginButton.classList.add("styled-button");
        loginButton.onclick = () => loginUser(inputId, pinInputId, config);

        const registerButton = document.createElement("button");
        registerButton.textContent = "Register";
        registerButton.classList.add("styled-button");
        registerButton.onclick = () => registerUser(inputId, pinInputId, config);

        const handleEnterKey = (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                loginButton.click(); 
            }
        };
        usernameInput.addEventListener('keydown', handleEnterKey);
        pinInput.addEventListener('keydown', handleEnterKey);
        
        // Append the new login elements to the container.
        container.appendChild(usernameInput);
        container.appendChild(pinInput);
        container.appendChild(loginButton);
        container.appendChild(registerButton);
        
        window.currentUsername = null;
        usernameSet = false;
    }
}

function populateModalHints() {
    const hintsContainer = document.getElementById('modal-hints-container');
    // ✅ This line was changed to only include hints 1, 2, and 3
    const hints = [customHint1, customHint2, customHint3]
        .filter(h => h && h.trim() !== "");

    hintsContainer.innerHTML = ''; // Clear previous content

    if (hints.length > 0) {
        const title = document.createElement('h2');
        title.textContent = "Hints for This Word:";
        hintsContainer.appendChild(title);

        // Loop through the hints in pairs
        for (let i = 0; i < hints.length; i += 2) {
            const hint1 = hints[i];
            const hint2 = hints[i + 1];

            const rowElement = document.createElement('p');
            
            let rowText = hint1;

            if (hint2) {
                rowText += ` - ${hint2}`;
            }

            rowElement.textContent = rowText;
            hintsContainer.appendChild(rowElement);
        }
    }
}

// This helper function displays the game-over modal with the correct information.
async function showGameOverModal(isSolved, guessHistory, colorHistory, hintStatus, funFactText) {
const overlay = document.getElementById("game-over-overlay");
    
    // Set win/loss message
    if (isSolved) {
        document.getElementById("modal-message").innerHTML = `You win! 🎉<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
    } else {
        document.getElementById("modal-message").innerHTML = `Game over!<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
    }

    // Generate and display the shareable summary
    document.getElementById("modal-summary").textContent = generateResultText(true, guessHistory, colorHistory, isSolved, hintStatus);

    // --- UPDATED LOGIC ---
    // First, always remove any fun fact from a previous game.
    const existingFunFact = document.querySelector("#game-over-modal .fun-fact-section");
    if (existingFunFact) existingFunFact.remove();

    // Now, display the new fun fact ONLY if one was provided for THIS game.
    if (funFactText && funFactText.trim() !== "") {
        const funFactDiv = document.createElement('div');
        funFactDiv.classList.add('fun-fact-section');
        funFactDiv.innerHTML = `<h2>Fun fact about today's Wørtle:</h2><p style="margin:0;">${funFactText}</p>`;
        document.querySelector("#game-over-modal .modal-content").appendChild(funFactDiv);
    }

    populateModalHints();
    bindModalButtons(guessHistory, colorHistory, isSolved, hintStatus);
    overlay.classList.add('show');
}
// --- Account Sidebar Logic ---
const accountBtn = document.getElementById('accountBtn');
const accountSidebar = document.getElementById('account-sidebar');
const accountOverlay = document.getElementById('account-overlay');
const closeAccountBtn = document.getElementById('closeAccountBtn');
const hostedGamesList = document.getElementById('hosted-games-list');
const playedGamesList = document.getElementById('played-games-list');
let resolveHostedGames = null;
let resolvePlayedGames = null;

// Define references in a higher scope to manage them across open/close actions
let hostedGamesRef = null;
let playedGamesRef = null;

function renderHostedGames(snapshot) {
    hostedGamesList.innerHTML = '';
    const titleElement = document.getElementById('hosted-games-title');

    if (!snapshot.exists()) {
        if (titleElement) titleElement.textContent = 'Hosted Games (0)';
        hostedGamesList.innerHTML = '<p style="padding: 10px;">You have not created any games.</p>';
        if (resolveHostedGames) {
            resolveHostedGames();
            resolveHostedGames = null;
        }
        return;
    }

    const gamesObject = snapshot.val();
    const games = [];
    for (const word in gamesObject) {
        games.push({ word: word, ...gamesObject[word] });
    }
    
    if (titleElement) titleElement.textContent = `Hosted Games (${games.length})`;

    games.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));
    const metaPromises = games.map(game => database.ref(`games/${game.word}/metadata`).once('value'));

    Promise.all(metaPromises).then(metaSnapshots => {
        const fragment = document.createDocumentFragment();
        metaSnapshots.forEach((metaSnap, idx) => {
            if (metaSnap.exists()) {
                const meta = metaSnap.val();
                const listItem = document.createElement('div');
                listItem.className = 'game-list-item';
                const gameLink = document.createElement('a');
                const fullUrl = generateShareURL(meta.word, meta.hint1, meta.hint2, meta.hint3, meta.hint4, meta.funFact);
                gameLink.href = fullUrl;
                gameLink.textContent = meta.word;
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'game-item-actions';
                
                const scoreboardBtn = document.createElement('button');
                scoreboardBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line></svg>`;
                scoreboardBtn.title = 'View Scoreboard';
                scoreboardBtn.onclick = (event) => {
                    event.stopPropagation(); 
                    showGameScoreboard(meta.word);
                };

                const copyBtn = document.createElement('button');
                const linkIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>`;
                const checkIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
                
                copyBtn.innerHTML = linkIconSVG;
                copyBtn.title = 'Copy Link';
                
                copyBtn.onclick = (event) => {
                    event.stopPropagation();

                    // --- ✅ NEW DATE-BASED LOGIC ---
                    const cutoffDate = new Date('2025-09-06T00:00:00Z'); // Midnight UTC on Sep 6th, 2025
                    const gameData = games[idx];
                    const gameCreationDate = new Date(gameData.createdDate);
                    
                    let urlToCopy;
                    if (gameCreationDate < cutoffDate) {
                        // Game is old, so copy the full URL
                        urlToCopy = fullUrl;
                    } else {
                        // Game is new, so prefer the short URL
                        urlToCopy = meta.shortUrl || fullUrl;
                    }
                    // --- END OF NEW LOGIC ---

                    navigator.clipboard.writeText(urlToCopy).then(() => {
                        copyBtn.innerHTML = checkIconSVG;
                        setTimeout(() => {
                            copyBtn.innerHTML = linkIconSVG;
                        }, 2000);
                    });
                };

                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
                deleteBtn.title = 'Delete Game';
                deleteBtn.onclick = (event) => {
                    event.stopPropagation();
                    deleteGame(meta.word);
                };
                
                actionsDiv.appendChild(scoreboardBtn);
                actionsDiv.appendChild(copyBtn);
                actionsDiv.appendChild(deleteBtn);
                
                listItem.appendChild(gameLink);
                listItem.appendChild(actionsDiv);
                fragment.appendChild(listItem);
            }
        });
        hostedGamesList.appendChild(fragment);

        if (resolveHostedGames) {
            resolveHostedGames();
            resolveHostedGames = null;
        }
    });
}

// Replace your existing closeAccountSidebar function
function closeAccountSidebar() {
    isModalOpen = false;
    accountSidebar.classList.remove('show');
    accountOverlay.classList.remove('show');
    mainContent.inert = false;

    // Detach all real-time Firebase listeners
    if (hostedGamesRef) {
        hostedGamesRef.off('value', renderHostedGames);
    }
    if (playedGamesRef) {
        playedGamesRef.off('value', renderPlayedGames);
    }
    if (statsRef && statsListener) {
        statsRef.off('value', statsListener);
    }
    if (badgesRef && badgesListener) {
        badgesRef.off('value', badgesListener);
    }
    if (langRef && langListener) { // ADD THIS BLOCK
        langRef.off('value', langListener);
    }
}

let statsRef = null;
let statsListener = null;

// This is the improved openAccountSidebar function
// REPLACE your existing openAccountSidebar function with this one

async function openAccountSidebar() {
    isModalOpen = true;
    const username = localStorage.getItem("gerNordleUsername");
    if (!username) {
        showToast("Please log in to view your account.", "error");
        return;
    }

    const usernameText = document.getElementById('account-username-text');
    const sidebarFlag = document.getElementById('account-sidebar-flag');
    const sidebarLoader = document.getElementById('sidebar-loader');
    const sidebarContent = document.getElementById('sidebar-content');

    accountSidebar.classList.add('show');
    accountOverlay.classList.add('show');
    mainContent.inert = true;
    sidebarLoader.style.display = 'block';
    sidebarContent.classList.remove('loaded');

    if (usernameText) usernameText.textContent = username.toUpperCase();

    try {
        const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');

        // --- START: MODIFIED FLAG/EMOJI LOGIC ---
        // This now listens for language changes in real-time
        langRef = database.ref(`userProfiles/${sanitizedUsername}/nativeLanguage`);
        langListener = langRef.on('value', (langSnapshot) => {
            const nativeLanguage = langSnapshot.val();

            if (nativeLanguage) {
                // If language exists, show the flag
                const countryCode = languageToCountryCode[nativeLanguage.toLowerCase()];
                if (countryCode && sidebarFlag) {
                    sidebarFlag.textContent = getFlagEmoji(countryCode);
                    sidebarFlag.onclick = null; // Make it not clickable
                    sidebarFlag.style.cursor = 'default';
                    sidebarFlag.title = '';
                }
            } else {
                // If language does NOT exist, show a clickable emoji
                if (sidebarFlag) {
                    sidebarFlag.textContent = '✏️';
                    sidebarFlag.style.cursor = 'pointer';
                    sidebarFlag.title = 'Set your native language';
                    sidebarFlag.onclick = () => {
                        showLanguagePopup(username); // Opens the popup
                    };
                }
            }
        });
        
        // (The rest of the function remains the same)
        const badgesRef = database.ref(`userProfiles/${sanitizedUsername}/badges`);
        badgesRef.on('value', (badgesSnapshot) => {
            const badgesContainer = document.getElementById('account-badges-container');
            badgesContainer.innerHTML = '';
            if (badgesSnapshot.exists()) {
                const earnedBadges = badgesSnapshot.val();
                for (const badgeId in earnedBadges) {
                    if (earnedBadges[badgeId] === true && BADGE_DEFINITIONS[badgeId]) {
                        const badgeInfo = BADGE_DEFINITIONS[badgeId];
                        const badgeElement = document.createElement('div');
                        badgeElement.className = 'badge';
                        badgeElement.textContent = badgeInfo.name;
                        badgeElement.title = badgeInfo.description;
                        badgesContainer.appendChild(badgeElement);
                    }
                }
            }
        });

        const hostedGamesLoaded = new Promise(resolve => { resolveHostedGames = resolve; });
        const playedGamesLoaded = new Promise(resolve => { resolvePlayedGames = resolve; });

        hostedGamesRef = database.ref(`userProfiles/${sanitizedUsername}/hostedGames`);
        hostedGamesRef.on('value', renderHostedGames);

        playedGamesRef = database.ref(`userProfiles/${sanitizedUsername}/playedGames`);
        playedGamesRef.on('value', renderPlayedGames);
                
        statsRef = database.ref(`userProfiles/${sanitizedUsername}`); 
        statsListener = statsRef.on('value', renderAccountStats);
        
        await Promise.all([hostedGamesLoaded, playedGamesLoaded]);

        sidebarLoader.style.display = 'none';
        sidebarContent.classList.add('loaded');

    } catch (error) {
        sidebarLoader.style.display = 'none';
        sidebarContent.classList.add('loaded');
        console.error("Error loading account sidebar:", error);
    }
}
accountBtn.addEventListener('click', openAccountSidebar);
closeAccountBtn.addEventListener('click', closeAccountSidebar);
accountOverlay.addEventListener('click', closeAccountSidebar);

// This function starts listening for changes to the current user's record
function listenForUserDeletion(username) {
    stopUserDeletionListener(); // Stop any previous listeners first

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const userRef = database.ref('users/' + sanitizedUsername);

    const listener = userRef.on('value', (snapshot) => {
        // If snapshot.exists() is false, the user was deleted from the database
        if (!snapshot.exists()) {
            console.log("Current user was deleted from the database. Logging out.");
            
            // Stop the listener before we reload
            stopUserDeletionListener();

            // Clear local session and refresh the page
            localStorage.removeItem("gerNordleUsername");
            localStorage.removeItem("gerNordleUserPin");
            window.location.reload();
        }
    });

    // Store the reference and the listener so we can detach it later
    userListener = { ref: userRef, listener: listener };
}

// This function stops the listener to prevent memory leaks
function stopUserDeletionListener() {
    if (userListener.ref && userListener.listener) {
        userListener.ref.off('value', userListener.listener);
        userListener = { ref: null, listener: null };
    }
}
async function saveCompletedGameData(won) {
    const username = localStorage.getItem("gerNordleUsername");
    if (!username || !secret) return;

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const guesses = won ? (currentRow + 1) : -1;
    const userProfileRef = database.ref(`userProfiles/${sanitizedUsername}`);

    const today = new Date();
    const todayString = today.toDateString();

    try {
        if (isDailyGame) {
            const finalScoreData = {
                username: username,
                guesses: guesses,
                timestamp: new Date().toISOString(),
                hintCount: 0, // Daily games don't have hints
                wasHardMode: !hardModeWasDisabled
            };
            const dailyScoreRef = database.ref(`/games/${secret}/${sanitizedUsername}`);
            await dailyScoreRef.set(finalScoreData);
            // --- LOGIC FOR DAILY WØRTLE ---
            const finalPlayedGameData = {
                status: won ? 'won' : 'lost',
                guesses: guesses,
                createdDate: new Date().toISOString(),
                guessHistory: guessHistory,
                colorHistory: colorHistory,
                hintStatus: { hintUsed1: false, hintUsed2: false, hintUsed3: false, hintUsed4: false },
                wasHardMode: !hardModeWasDisabled,
                host: "WØRTLE"
            };
            await userProfileRef.child('playedGames').child(secret).set(finalPlayedGameData);

            await updateStats(username, won, guesses);
            const profileSnapshot = await userProfileRef.once('value');
            const userProfile = profileSnapshot.val() || {};

            const lastPlayed = userProfile.lastPlayedDate;
            if (lastPlayed !== todayString) {
                let playStreak = userProfile.playStreak || 0;
                if (isConsecutiveDay(lastPlayed, today) || isFridayToMondayJump(lastPlayed, today)) {
                    playStreak++;
                } else {
                    playStreak = 1;
                }
                userProfileRef.child('playStreak').set(playStreak);
                userProfileRef.child('lastPlayedDate').set(todayString);
            }
            if ((userProfile.playStreak || 0) >= 7) {
                awardBadge(username, 'daily_dedication');
            }

            if (won) {
                // CORRECTLY UPDATE GUESS DISTRIBUTION
                const guessCount = guessHistory.length;
                const guessDistRef = userProfileRef.child('stats/guessDistribution').child(String(guessCount));
                await guessDistRef.transaction(currentCount => (currentCount || 0) + 1);

                // CORRECTLY UPDATE WIN STREAK
                const lastWin = userProfile.lastWinDate;
                if (lastWin !== todayString) {
                    let winStreak = userProfile.winStreak || 0;
                    if (isConsecutiveDay(lastWin, today) || isFridayToMondayJump(lastWin, today)) {
                        winStreak++;
                    } else {
                        winStreak = 1;
                    }
                    userProfileRef.child('winStreak').set(winStreak);
                    userProfileRef.child('lastWinDate').set(todayString);
                }
                
                // BADGE CHECKS
                if ((userProfile.winStreak || 0) >= 3) awardBadge(username, 'on_a_roll');
                if ((userProfile.winStreak || 0) >= 10) awardBadge(username, 'dominating');
            
                // For daily games, find the language by checking the client-side word lists
                const dailyGameLanguage = findWordLanguages(secret.toLowerCase())[0];
                if (dailyGameLanguage) {
                    const lang = dailyGameLanguage;
                    if (SUPPORTED_LANGUAGES.includes(lang)) {
                        await userProfileRef.child('playedLanguages').child(lang).set(true);
                        if (!userProfile.playedLanguages) userProfile.playedLanguages = {};
                        userProfile.playedLanguages[lang] = true;

                        // Check language badges
                        if (userProfile.playedLanguages) {
                            const solvedLangs = new Set(Object.keys(userProfile.playedLanguages));
                            if (solvedLangs.size >= 5) awardBadge(username, 'polyglot');
                            const nativeLang = userProfile.nativeLanguage ? userProfile.nativeLanguage.toLowerCase() : null;
                            if (nativeLang) {
                                const nonNativeLangs = SUPPORTED_LANGUAGES.filter(lang => lang !== nativeLang);
                                if (nonNativeLangs.length >= 4 && nonNativeLangs.every(lang => solvedLangs.has(lang))) {
                                    awardBadge(username, 'globetrotter');
                                }
                            }
                        }
                    }
                }
                
                // Other non-hint/host related badges
                if (guessHistory.length === 1) awardBadge(username, 'prodigy');
                if (guessHistory.length <= 2) awardBadge(username, 'genius');
                if (currentRow === rows - 1) awardBadge(username, 'clutch_victory');
                if (!colorHistory.flat().includes('absent')) awardBadge(username, 'flawless');
                if (/[ÄÖÜ]/.test(secret)) awardBadge(username, 'umlaut_enthusiast');
                if (/[ÆØÅ]/.test(secret)) awardBadge(username, 'nordic_explorer');
                const uniqueVowels = new Set(secret.toUpperCase().match(/[AEIOU]/g));
                if (uniqueVowels && uniqueVowels.size >= 4) awardBadge(username, 'vowel_virtuoso');
                const currentHour = new Date().getHours();
                if (currentHour >= 0 && currentHour <= 4) awardBadge(username, 'night_owl');
                if (currentHour >= 5 && currentHour <= 8) awardBadge(username, 'early_bird');
                const vowels = new Set(['A', 'E', 'I', 'O', 'U', 'Y', 'Ä', 'Ö', 'Ü', 'Æ', 'Ø', 'Å']);
                if (new Set([...secret].filter(char => !vowels.has(char.toUpperCase()))).size >= 4) {
                    awardBadge(username, 'consonant_crusher');
                }
            } else {
                userProfileRef.child('winStreak').set(0);
            }
            
            const encodedSecret = base64Encode(secret);
            const allGameData = JSON.parse(localStorage.getItem("gerNordleGameData") || "{}");
            if (!allGameData[username]) allGameData[username] = {};
            const finalGameRecord = { ...finalPlayedGameData, keyColors: keyColors };
            delete finalGameRecord.ongoingState;
            allGameData[username][encodedSecret] = finalGameRecord;
            localStorage.setItem("gerNordleGameData", JSON.stringify(allGameData));
            await database.ref(`userProfiles/${sanitizedUsername}/ongoingDailyGame`).remove();

        } else {
            // --- LOGIC FOR CUSTOM GAMES ---
            const hostNameRef = database.ref(`games/${secret}/metadata/host`);
            const hostSnapshot = await hostNameRef.once('value');
            const hostName = hostSnapshot.val();

            const finalPlayedGameData = {
                status: won ? 'won' : 'lost',
                guesses: guesses,
                createdDate: new Date().toISOString(),
                guessHistory: guessHistory,
                colorHistory: colorHistory,
                hintStatus: { hintUsed1, hintUsed2, hintUsed3, hintUsed4 },
                wasHardMode: !hardModeWasDisabled,
                host: hostName
            };
            await userProfileRef.child('playedGames').child(secret).set(finalPlayedGameData);

            const encodedSecret = base64Encode(secret);
            const allGameData = JSON.parse(localStorage.getItem("gerNordleGameData") || "{}");
            if (!allGameData[username]) allGameData[username] = {};
            const finalGameRecord = { ...finalPlayedGameData, keyColors: keyColors };
            delete finalGameRecord.ongoingState;
            allGameData[username][encodedSecret] = finalGameRecord;
            localStorage.setItem("gerNordleGameData", JSON.stringify(allGameData));

            if (username !== hostName) {
                const finalScoreData = {
                    username: username,
                    guesses: guesses,
                    timestamp: new Date().toISOString(),
                    hintCount: (hintUsed1 ? 1:0) + (hintUsed2 ? 1:0) + (hintUsed3 ? 1:0) + (hintUsed4 ? 1:0),
                    wasHardMode: !hardModeWasDisabled
                };
                const publicScoreUpdates = {};
                publicScoreUpdates[`/games/${secret}/${sanitizedUsername}`] = finalScoreData;
                publicScoreUpdates[`/games/${secret}/players/${sanitizedUsername}`] = null;
                await database.ref().update(publicScoreUpdates);

                await updateStats(username, won, guesses);

                const profileSnapshot = await userProfileRef.once('value');
                const userProfile = profileSnapshot.val() || {};
                
                const lastPlayed = userProfile.lastPlayedDate;
                if (lastPlayed !== todayString) {
                    let playStreak = userProfile.playStreak || 0;
                    if (isConsecutiveDay(lastPlayed, today) || isFridayToMondayJump(lastPlayed, today)) {
                        playStreak++;
                    } else {
                        playStreak = 1;
                    }
                    userProfileRef.child('playStreak').set(playStreak);
                    userProfileRef.child('lastPlayedDate').set(todayString);
                }
                if ((userProfile.playStreak || 0) >= 7) {
                    awardBadge(username, 'daily_dedication');
                }

                if (won) {
                    const guessCount = guessHistory.length;
                    const guessDistRef = userProfileRef.child('stats/guessDistribution').child(String(guessCount));
                    await guessDistRef.transaction(currentCount => (currentCount || 0) + 1);

                    const lastWin = userProfile.lastWinDate;
                    if (lastWin !== todayString) {
                        let winStreak = userProfile.winStreak || 0;
                        if (isConsecutiveDay(lastWin, today) || isFridayToMondayJump(lastWin, today)) {
                            winStreak++;
                        } else {
                            winStreak = 1;
                        }
                        userProfileRef.child('winStreak').set(winStreak);
                        userProfileRef.child('lastWinDate').set(todayString);
                    }
                    
                    if ((userProfile.winStreak || 0) >= 3) awardBadge(username, 'on_a_roll');
                    if ((userProfile.winStreak || 0) >= 10) awardBadge(username, 'dominating');
                
                    if (customHint1) {
                        const lang = customHint1.trim().toLowerCase();
                        if (SUPPORTED_LANGUAGES.includes(lang)) {
                            await userProfileRef.child('playedLanguages').child(lang).set(true);
                            if (!userProfile.playedLanguages) userProfile.playedLanguages = {};
                            userProfile.playedLanguages[lang] = true;
                        }
                    }

                    if (userProfile.playedLanguages) {
                        const solvedLangs = new Set(Object.keys(userProfile.playedLanguages));
                        if (solvedLangs.size >= 5) awardBadge(username, 'polyglot');
                        const nativeLang = userProfile.nativeLanguage ? userProfile.nativeLanguage.toLowerCase() : null;
                        if (nativeLang) {
                            const nonNativeLangs = SUPPORTED_LANGUAGES.filter(lang => lang !== nativeLang);
                            if (nonNativeLangs.length >= 4 && nonNativeLangs.every(lang => solvedLangs.has(lang))) {
                                awardBadge(username, 'globetrotter');
                            }
                        }
                    }

                    if (guessHistory.length === 1) awardBadge(username, 'prodigy');
                    if (guessHistory.length <= 2) awardBadge(username, 'genius');
                    if (currentRow === rows - 1) awardBadge(username, 'clutch_victory');
                    if (!colorHistory.flat().includes('absent')) awardBadge(username, 'flawless');
                    const hintsAvailable = customHint1 || customHint2 || customHint3 || customHint4;
                    if (hintsAvailable && !(hintUsed1 || hintUsed2 || hintUsed3 || hintUsed4)) awardBadge(username, 'natural_talent');
                    if (/[ÄÖÜ]/.test(secret)) awardBadge(username, 'umlaut_enthusiast');
                    if (/[ÆØÅ]/.test(secret)) awardBadge(username, 'nordic_explorer');
                    const uniqueVowels = new Set(secret.toUpperCase().match(/[AEIOU]/g));
                    if (uniqueVowels && uniqueVowels.size >= 4) awardBadge(username, 'vowel_virtuoso');
                    const currentHour = new Date().getHours();
                    if (currentHour >= 0 && currentHour <= 4) awardBadge(username, 'night_owl');
                    if (currentHour >= 5 && currentHour <= 8) awardBadge(username, 'early_bird');
                    const vowels = new Set(['A', 'E', 'I', 'O', 'U', 'Y', 'Ä', 'Ö', 'Ü', 'Æ', 'Ø', 'Å']);
                    if (new Set([...secret].filter(char => !vowels.has(char.toUpperCase()))).size >= 4) {
                        awardBadge(username, 'consonant_crusher');
                    }
                } else {
                    userProfileRef.child('winStreak').set(0);
                }

                if (hostName && hostName !== username) {
                    const playedHostsRef = userProfileRef.child('playedHosts').child(hostName);
                    await playedHostsRef.set(true);
                    const playedHostsSnapshot = await userProfileRef.child('playedHosts').once('value');
                    if (playedHostsSnapshot.numChildren() >= 10) awardBadge(username, 'wortle_wanderer');
                    const gamePlayersRef = database.ref(`games/${secret}`);
                    const gamePlayersSnapshot = await gamePlayersRef.once('value');
                    const data = gamePlayersSnapshot.val() || {};
                    const playerCount = Object.keys(data).filter(key => key !== 'metadata' && key !== 'players').length;
                    if (playerCount >= 10) awardBadge(hostName, 'crowd_pleaser');
                }
            }
        }
    } catch (error) {
        console.error("Failed to save final game data:", error);
        throw error;
    }
}

async function deleteGame(wordToDelete) {
    if (!confirm(`Are you sure you want to permanently delete the game "${wordToDelete}"? This will remove it from every player's history and stats.`)) {
        return;
    }

    const hostUsername = localStorage.getItem("gerNordleUsername");
    if (!hostUsername) {
        alert("Could not verify user. Deletion failed.");
        return;
    }
    const sanitizedHostUsername = hostUsername.replace(/[.#$[\]]/g, '_');

    try {
        const gameSnapshot = await database.ref('games/' + wordToDelete).once('value');
        const gameData = gameSnapshot.val();

        const allPlayerNames = new Set();

        // --- FIX START ---
        // Unconditionally add the host to the list of players to be cleaned up.
        // This ensures the game is removed from the host's "playedGames" list
        // even if data is inconsistent.
        allPlayerNames.add(sanitizedHostUsername);

        // Now, find all OTHER players from the central game record.
        if (gameData) {
            Object.keys(gameData).forEach(key => {
                if (key !== 'metadata' && key !== 'players') {
                    allPlayerNames.add(key);
                }
            });
            if (gameData.players) {
                Object.keys(gameData.players).forEach(playerName => {
                    allPlayerNames.add(playerName);
                });
            }
        }
        // --- FIX END ---

        const updates = {};
        updates[`/games/${wordToDelete}`] = null;
        updates[`/userProfiles/${sanitizedHostUsername}/hostedGames/${wordToDelete}`] = null;

        allPlayerNames.forEach(sanitizedPlayerName => {
            updates[`/userProfiles/${sanitizedPlayerName}/playedGames/${wordToDelete}`] = null;
        });

        await database.ref().update(updates);

        // This check is needed because we might not have gameData if the record was already partially deleted.
        if (gameData) {
            const statPromises = [];
            allPlayerNames.forEach(sanitizedPlayerName => {
                const scoreData = gameData[sanitizedPlayerName];
                if (scoreData) {
                    const wasWin = scoreData.guesses > 0;
                    const guessesInGame = wasWin ? scoreData.guesses : 0;

                    const statRef = database.ref(`/userProfiles/${sanitizedPlayerName}/stats`);
                    const statPromise = statRef.transaction(currentStats => {
                        if (currentStats) {
                            currentStats.gamesPlayed = (currentStats.gamesPlayed || 0) - 1;
                            if (currentStats.gamesPlayed < 0) currentStats.gamesPlayed = 0;

                            if (wasWin) {
                                currentStats.wins = (currentStats.wins || 0) - 1;
                                if (currentStats.wins < 0) currentStats.wins = 0;

                                currentStats.totalGuesses = (currentStats.totalGuesses || 0) - guessesInGame;
                                if (currentStats.totalGuesses < 0) currentStats.totalGuesses = 0;
                                
                                // ✅ ADD THIS BLOCK TO UPDATE THE GUESS DISTRIBUTION
                                const guessCountKey = String(guessesInGame);
                                if (
                                    currentStats.guessDistribution &&
                                    currentStats.guessDistribution[guessCountKey] &&
                                    currentStats.guessDistribution[guessCountKey] > 0
                                ) {
                                    currentStats.guessDistribution[guessCountKey]--;
                                }
                            }
                        }
                        return currentStats;
                    });
                    statPromises.push(statPromise);
                }
            });

            if (statPromises.length > 0) {
                await Promise.all(statPromises);
            }
        }

        if (wordToDelete === secret) {
            window.location.reload();
        }

    } catch (error) {
        console.error("Comprehensive deletion failed:", error);
        alert("An error occurred while trying to delete the game. Please try again.");
    }
}

// This function handles closing the popup when the user starts typing a guess.
function handleTypingToClose(event) {
    // Check if the key pressed is a valid letter for the game.
    if (/^[a-zA-ZÄÖÜäöüßẞÆØÅæøå]$/.test(event.key)) {
        hideHintPopup();
    }
}

async function loadCompletedGame(playedGameData) {
    const savedUsername = localStorage.getItem("gerNordleUsername");
    if (!savedUsername) return;

    const headerSetup = document.getElementById("header-setup");
    const gameElement = document.getElementById("game");

    setupUsernameInterface({
        isGamePage: true,
        containerId: 'setup-username-area',
        inputId: 'usernameInputGame',
        placeholder: 'Enter username'
    });

    initBoard();
    initKeyboard();

    const isSolved = playedGameData.status === 'won';
    document.getElementById("message").textContent = isSolved ? "You already solved this Wørtle! 🥳" : "You have already played this Wørtle.";

    const reconstructedKeyColors = {};
    if (playedGameData.guessHistory && playedGameData.colorHistory) {
        for (let i = 0; i < playedGameData.guessHistory.length; i++) {
            const guess = playedGameData.guessHistory[i];
            const colors = playedGameData.colorHistory[i];
            for (let j = 0; j < guess.length; j++) {
                const letter = guess[j];
                const color = colors[j];
                if (!reconstructedKeyColors[letter] || (color === 'correct') || (color === 'present' && reconstructedKeyColors[letter] === 'absent')) {
                    reconstructedKeyColors[letter] = color;
                }
            }
        }
    }
    keyColors = reconstructedKeyColors;
    updateKeyboardColors();

    // --- ADD THIS BLOCK TO RESTORE HINT STATUS ---
    // Read the saved hint status and set the global variables.
    const hintStatus = playedGameData.hintStatus || {};
    hintUsed1 = hintStatus.hintUsed1 || false;
    hintUsed2 = hintStatus.hintUsed2 || false;
    hintUsed3 = hintStatus.hintUsed3 || false;
    hintUsed4 = hintStatus.hintUsed4 || false;
    // Set expanded state for the UI to correctly show the hint text
    hintExpanded1 = hintUsed1;
    hintExpanded2 = hintUsed2;
    hintExpanded3 = hintUsed3;
    hintExpanded4 = hintUsed4;
    // --- END OF NEW BLOCK ---

    updateHintButtons(); // Now this will show the correct used hints

    const board = document.getElementById('board');
    board.innerHTML = generateGuessHistoryHTML(playedGameData.guessHistory, playedGameData.colorHistory);
    board.style.gridTemplateRows = 'none';
    
    const toggle = document.getElementById('hard-mode-toggle');
    if (toggle) {
        // --- THIS IS THE CORRECTED LINE ---
        // If 'wasHardMode' is missing (undefined), this check will be true, keeping the toggle on.
        // It will only be turned off if the value is explicitly false.
        toggle.checked = playedGameData.wasHardMode !== false;
        toggle.disabled = true;
    }

    let funFactForModal = "";
    try {
        const metadataRef = database.ref(`games/${secret}/metadata`);
        const metaSnapshot = await metadataRef.once('value');
        if (metaSnapshot.exists()) {
            funFactForModal = metaSnapshot.val().funFact || "";
        }
    } catch (error) {
        console.error("Could not fetch metadata for modal:", error);
    }
    
    showGameOverModal(isSolved, playedGameData.guessHistory, playedGameData.colorHistory, playedGameData.hintStatus, funFactForModal);
    disableKeyboard();  

    headerSetup.style.display = 'flex';
    gameElement.style.display = 'flex';
}

function loadOngoingGame(playedGameData) {
    const savedUsername = localStorage.getItem("gerNordleUsername");
    if (!savedUsername) return;

    const headerSetup = document.getElementById("header-setup");
    const gameElement = document.getElementById("game");

    // Use the new unified header logic
    setupUsernameInterface({
        isGamePage: true,
        containerId: 'setup-username-area',
        inputId: 'usernameInputGame',
        placeholder: 'Enter username'
    });

    isHardMode = playedGameData.isHardMode !== false;
    hardModeWasDisabled = playedGameData.hardModeWasDisabled || false;
         const toggle = document.getElementById('hard-mode-toggle');
    if (toggle) {
        toggle.checked = isHardMode;

        // --- ADD THIS LOGIC ---
        // If hard mode was ever disabled in this saved game,
        // make sure the toggle is disabled when the page loads.
        if (hardModeWasDisabled) {
            toggle.disabled = true;
        }
    }

    initBoard();
    initKeyboard();

    // Restore all game variables from the passed-in Firebase data.
    usernameSet = true;
    grid = playedGameData.grid;
    currentRow = playedGameData.currentRow;
    guessHistory = playedGameData.guessHistory || [];
    colorHistory = playedGameData.colorHistory || [];
    keyColors = playedGameData.keyColors || {};
    
    const hintStatus = playedGameData.hintStatus || {};
    hintUsed1 = hintStatus.hintUsed1;
    hintUsed2 = hintStatus.hintUsed2;
    hintUsed3 = hintStatus.hintUsed3;
    hintUsed4 = hintStatus.hintUsed4;
    hintExpanded1 = hintStatus.hintExpanded1 || false;
    hintExpanded2 = hintStatus.hintExpanded2 || false;
    hintExpanded3 = hintStatus.hintExpanded3 || false;
    hintExpanded4 = hintStatus.hintExpanded4 || false;
    currentCol = 0;
    
    // Apply the restored state to the UI.
    updateBoard();
    if (Array.isArray(colorHistory)) {
        for (let r = 0; r < colorHistory.length; r++) {
            const colors = colorHistory[r];
            const rowDiv = document.getElementById("board").children[r];
            if (Array.isArray(colors) && rowDiv) {
                for (let c = 0; c < cols; c++) {
                    if (rowDiv.children[c] && typeof colors[c] === 'string') {
                        rowDiv.children[c].classList.add(colors[c]);
                    }
                }
            }
        }
    }
    updateKeyboardColors();
    updateHintButtons();
    
    gameElement.classList.remove("dimmed");
    headerSetup.style.display = 'flex';
    gameElement.style.display = 'flex';
}

function renderAccountStats(snapshot) {
    const statsSection = document.getElementById('account-stats-section');
    const graphContainer = document.getElementById('account-graph-container');
    if (!statsSection || !graphContainer) return;

    const userProfile = snapshot.val() || {};
    const stats = userProfile.stats || {}; // Get the stats object from the profile.
    const winStreak = userProfile.winStreak || 0; // Get the winStreak from the top level.

    const winPct = (stats.gamesPlayed > 0) ? ((stats.wins / stats.gamesPlayed) * 100).toFixed(1) : "0.0";
    const avgGuesses = (stats.wins > 0) ? (stats.totalGuesses / stats.wins).toFixed(2) : "-";
    
    // Render the main stats (Played, Wins, etc.)
    statsSection.innerHTML = `
        <div class="stat-item">
            <span class="stat-value">${stats.gamesPlayed || 0}</span>
            <span class="stat-label">Played</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${winPct}%</span>
            <span class="stat-label">Win %</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${winStreak}</span>
            <span class="stat-label">Win Streak</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${avgGuesses}</span>
            <span class="stat-label">Avg. Guesses</span>
        </div>
    `;
    
    // ✅ 1. Get the current user's name
    const currentUsername = localStorage.getItem("gerNordleUsername");
    
    const playedGames = userProfile.playedGames || {};
    const calculatedDistribution = {};

    for (const gameId in playedGames) {
        const gameData = playedGames[gameId];
        
        // ✅ 2. Add a check to ensure the current user is NOT the host
        if (gameData.status === 'won' && gameData.guesses > 0 && gameData.host !== currentUsername) {
            const guessCount = gameData.guesses;
            calculatedDistribution[guessCount] = (calculatedDistribution[guessCount] || 0) + 1;
        }
    }
    renderGuessDistribution(graphContainer, calculatedDistribution, null);
}

function showToast(message, type = '') {
    const container = document.getElementById('toast-container');
    if (!container) return;

    // Create the toast element
    const toastElement = document.createElement('div');
    toastElement.className = 'toast';
    if (type) {
        toastElement.classList.add(type);
    }
    toastElement.textContent = message;

    // Add it to the container
    container.appendChild(toastElement);

    // Set a timer to remove the toast after its animation finishes
    setTimeout(() => {
        toastElement.remove();
    }, 3000); // 3000ms = 3 seconds
}
async function displayHostCredit() {
    const creditElement = document.getElementById('host-credit');
    if (!secret || !creditElement) return;

    try {
        const metadataRef = database.ref(`games/${secret}/metadata`);
        const snapshot = await metadataRef.once('value');

        if (snapshot.exists()) {
            const metadata = snapshot.val();
            const hostName = metadata.host;
            const gameNum = metadata.gameNumber; // Get the game number from metadata
            const shortUrl = metadata.shortUrl;

            creditElement.innerHTML = '';

            // Construct the new credit text, including the game number if it exists
            creditElement.textContent = gameNum
                ? `Wørtle #${gameNum} by: ${hostName}`
                : `Wørtle by: ${hostName}`;

            if (shortUrl) {
                const urlElement = document.createElement('div');
                urlElement.style.marginTop = '5px';
                urlElement.innerHTML = `Share this game: <a href="${shortUrl}" target="_blank" style="color: #5c7a98;">${shortUrl}</a>`;
                creditElement.appendChild(urlElement);
            }
        }
    } catch (error) {
        console.error("Could not fetch host credit:", error);
    }
}
/**
 * Awards a badge to a user if they haven't already earned it.
 * @param {string} username The user who earned the badge.
 * @param {string} badgeId The ID of the badge (e.g., 'genius').
 */
async function awardBadge(username, badgeId) {
    if (!username || !BADGE_DEFINITIONS[badgeId]) return;

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const badgeRef = database.ref(`userProfiles/${sanitizedUsername}/badges/${badgeId}`);

    try {
        const snapshot = await badgeRef.once('value');
        if (!snapshot.exists()) {
            await badgeRef.set(true);
            // Show a notification to the user!
            const badgeName = BADGE_DEFINITIONS[badgeId].name;
            showToast(`Badge Unlocked: ${badgeName}`);
        }
    } catch (error) {
        console.error(`Could not award badge ${badgeId}:`, error);
    }
}
/**
 * Renders a Wordle-style guess distribution graph inside a given container.
 * @param {HTMLElement} containerElement - The div where the graph should be drawn.
 * @param {object} distributionData - The user's guessDistribution stats.
 * @param {number|null} highlightRow - The row number (1-8) to highlight (optional).
 */
function renderGuessDistribution(containerElement, distributionData, highlightRow = null) {
    if (!containerElement) return;

    containerElement.innerHTML = '<h3>My Guesses</h3>';

    const distribution = distributionData || {};
    const values = Object.values(distribution);
    const maxValue = values.length > 0 ? Math.max(...values) : 1;

    for (let i = 1; i <= rows; i++) {
        const count = distribution[i] || 0;
        const row = document.createElement('div');
        row.className = 'graph-row';

        let barHtml = '';
        if (count > 0) {
            const percentage = (count / maxValue) * 100;
            const highlightClass = (i === highlightRow) ? 'highlight' : '';
            barHtml = `<div class="graph-bar ${highlightClass}" style="width: ${percentage}%">${count}</div>`;
        } else {
            barHtml = `<div class="zero-count">0</div>`;
        }

        row.innerHTML = `<div class="graph-label">${i}</div>${barHtml}`;
        containerElement.appendChild(row);
    }
}
function handleGiveUp() {
    if (isAnimating) return;

    // ✅ This new block checks if a guess has been made
    if (guessHistory.length === 0) {
        showToast("You must make at least one guess before giving up.", "error");
        return; // Stop the function here
    }

    // This part now only runs if the player has made a guess
    if (window.confirm("Are you sure you want to end the game?")) {
        endGame(false);
    }
}

/**
 * Shows a popup to collect the user's native language after registration.
 * @param {string} username The newly registered user's name.
 */
function showLanguagePopup(username, shouldReload = false) {
    const overlay = document.getElementById('language-popup-overlay');
    const popup = document.getElementById('language-popup');
    const title = document.getElementById('language-popup-title');
    const saveBtn = document.getElementById('language-popup-save-btn');
    const languageInput = document.getElementById('language-popup-input');

    languageInput.value = "";
    setInputsDisabled(true);
    isModalOpen = true;
    title.textContent = `Welcome, ${username}!`;
    
    overlay.classList.add('show');
    popup.classList.add('show');
    languageInput.focus();
    
    saveBtn.onclick = async () => {
        const selectedValue = languageInput.value;
        
        if (!selectedValue) {
            showToast('Please select an option from the list.', 'error');
            return;
        }
        
        // --- START: MODIFIED SAVE LOGIC ---
        // Only save to Firebase if the user selected a specific language.
        if (selectedValue !== 'other') {
            const formattedLanguage = selectedValue.charAt(0).toUpperCase() + selectedValue.slice(1);
            const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
            const profileRef = database.ref(`userProfiles/${sanitizedUsername}`);
            try {
                await profileRef.update({ nativeLanguage: formattedLanguage });
                showToast('Profile updated!', 'success');
            } catch (error) {
                console.error("Could not save native language:", error);
                showToast('Could not save language.', 'error');
            }
        }
        // If "Other" is selected, this block is skipped, and nothing is saved.
        // --- END: MODIFIED SAVE LOGIC ---
        
        closeLanguagePopup();
        
        if (shouldReload) {
            window.location.reload();
        }
    };
}
/**
 * Converts a two-letter country code into a flag emoji.
 * @param {string} countryCode The uppercase, two-letter country code (e.g., "US").
 * @returns {string} The flag emoji.
 */
function getFlagEmoji(countryCode) {
  const codePoints = countryCode
    .toUpperCase()
    .split('')
    .map(char => 127397 + char.charCodeAt());
  return String.fromCodePoint(...codePoints);
}

/**
 * Cycles through the available languages for the secret word.
 */
function switchLanguage() {
  if (availableLanguagesForWord.length <= 1) {
    return;
  }

  // Move to the next language, looping back to the start if needed
  currentLanguageIndex = (currentLanguageIndex + 1) % availableLanguagesForWord.length;

  const newLanguage = availableLanguagesForWord[currentLanguageIndex];
  const langInput = document.getElementById('hintInput');

  // Update the input field with the new language
  langInput.value = newLanguage.charAt(0).toUpperCase() + newLanguage.slice(1);

  // Save the new state to local storage
  saveSetupState();
}

// ADD THESE NEW FUNCTIONS TO YOUR MAIN SCRIPT

function showGameScoreboard(word) {
    isModalOpen = true;
    document.getElementById('game-scoreboard-overlay').classList.add('show');
    document.getElementById('game-scoreboard-popup').classList.add('show');
    
    const title = document.getElementById('game-scoreboard-title');
    title.innerHTML = `Scoreboard for <span style="color:var(--accent-color);">${word}</span>`;

    populateGameScoreboard(word);
}

function closeGameScoreboard() {
    isModalOpen = false;
    document.getElementById('game-scoreboard-overlay').classList.remove('show');
    document.getElementById('game-scoreboard-popup').classList.remove('show');
}

async function populateGameScoreboard(word) {
    const container = document.getElementById('game-scoreboard-content');
    container.innerHTML = '<div class="spinner"></div>';

    try {
        const gameRef = database.ref('games/' + word);
        const snapshot = await gameRef.once('value');
        const scoresData = snapshot.val();

        if (!scoresData) {
            container.innerHTML = '<p>No scores found for this game yet.</p>';
            return;
        }

        const playerScores = Object.keys(scoresData)
            .filter(key => key !== 'metadata' && key !== 'players')
            .map(key => scoresData[key]);

        if (playerScores.length === 0) {
            container.innerHTML = '<p>No one has played this Wørtle yet.</p>';
            return;
        }
        
        playerScores.sort((a, b) => {
            if (a.guesses === -1) return 1; // Move losses to the bottom
            if (b.guesses === -1) return -1;
            return a.guesses - b.guesses || (a.hintCount || 0) - (b.hintCount || 0);
        });

        let tableHTML = `<table class="scoreboard-table" style="width:100%; font-size:11pt;"><thead><tr><th>Rank</th><th>Player</th><th>Guesses</th><th>Hints</th></tr></thead><tbody>`;

        playerScores.forEach((score, index) => {
            const guessDisplay = score.guesses > 0 ? score.guesses : 'X';
            tableHTML += `<tr>
                <td>${index + 1}</td>
                <td>${score.username}</td>
                <td>${guessDisplay}</td>
                <td>${score.hintCount || 0}</td>
            </tr>`;
        });

        tableHTML += `</tbody></table>`;
        container.innerHTML = tableHTML;

    } catch (error) {
        console.error("Error loading game scoreboard:", error);
        container.innerHTML = '<p>Could not load scores for this game.</p>';
    }
}
function closeLanguagePopup() {
    isModalOpen = false;
    document.getElementById('language-popup-overlay').classList.remove('show');
    document.getElementById('language-popup').classList.remove('show');
    // Re-enable all inputs on the main page
    setInputsDisabled(false);
}

/**
 * Populates the language dropdown menu from the validLanguages Set.
 */
function populateLanguageDropdown() {
    const dropdown = document.getElementById('language-popup-input');
    if (!dropdown) return;

    // Sort languages alphabetically
    const sortedLanguages = [...validLanguages].sort();

    sortedLanguages.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang; // e.g., "danish"
        // Capitalize the first letter for display
        option.textContent = lang.charAt(0).toUpperCase() + lang.slice(1);
        dropdown.appendChild(option);
    });

    // --- ADD THIS PART ---
    // Add the "Other" option at the end of the list
    const otherOption = document.createElement('option');
    otherOption.value = 'other';
    otherOption.textContent = 'None of the above';
    dropdown.appendChild(otherOption);
    // ---------------------
}

// Call the function once when the script loads
populateLanguageDropdown();

// --- START: CLICK-OUTSIDE-TO-CLOSE LOGIC ---

/**
 * Attaches event listeners to an overlay to close its corresponding popup.
 * Also prevents clicks inside the popup from closing it.
 * @param {string} overlayId The ID of the overlay element.
 * @param {string} popupId The ID of the popup/modal element.
 * @param {Function} closeFunction The function to call to close the popup.
 */
function setupPopupCloseEvents(overlayId, popupId, closeFunction) {
    const overlay = document.getElementById(overlayId);
    const popup = document.getElementById(popupId);

    if (overlay) {
        // When the overlay is clicked, call the close function.
        overlay.addEventListener('click', closeFunction);
    }
    
    if (popup) {
        // This stops a click on the popup itself from "bubbling up"
        // to the overlay and closing the popup unintentionally.
        popup.addEventListener('click', (event) => {
            event.stopPropagation();
        });
    }
}

// Set up the "click outside" functionality for all your popups and sidebars
setupPopupCloseEvents('game-over-overlay', 'game-over-modal', closeGameOverModal);
setupPopupCloseEvents('language-popup-overlay', 'language-popup', closeLanguagePopup);
setupPopupCloseEvents('game-scoreboard-overlay', 'game-scoreboard-popup', closeGameScoreboard);

// --- END: CLICK-OUTSIDE-TO-CLOSE LOGIC ---

// --- ADD THIS BLOCK TO THE END OF YOUR SCRIPT ---
const hardModeToggle = document.getElementById('hard-mode-toggle');
if (hardModeToggle) {
    hardModeToggle.addEventListener('change', (event) => {
        const isEnabling = event.target.checked;
        if (isEnabling) {
            isHardMode = true;
        } else {
            // If turning off, ask for confirmation
            if (window.confirm("Are you sure you want to turn off hard mode? This cannot be undone for this game.")) {
                isHardMode = false;
                hardModeWasDisabled = true;
                event.target.disabled = true;

                // NEW: Disable the toggle to make the choice permanent
                event.target.disabled = true;

            } else {
                event.target.checked = true; // User cancelled, revert the toggle
            }
        }
        if (window.currentUsername && secret) {
            saveOngoingGame(window.currentUsername, base64Encode(secret));
        }
    });
}

/**
 * Checks if a new game date is exactly one day after the last one.
 * @param {string} lastDateString The last play/win date from the database.
 * @param {Date} todayDate The current date object.
 * @returns {boolean}
 */
function isConsecutiveDay(lastDateString, todayDate) {
    if (!lastDateString) return false;
    const lastDate = new Date(lastDateString);
    const expectedNextDay = new Date(lastDate);
    expectedNextDay.setDate(lastDate.getDate() + 1);
    return expectedNextDay.toDateString() === todayDate.toDateString();
}

/**
 * Checks for the special case of a streak continuing from a Friday to a Monday.
 * @param {string} lastDateString The last play/win date from the database.
 * @param {Date} todayDate The current date object.
 * @returns {boolean}
 */
function isFridayToMondayJump(lastDateString, todayDate) {
    if (!lastDateString) return false;
    const lastDate = new Date(lastDateString);
    // Check if last play was a Friday (day #5) and today is a Monday (day #1)
    if (lastDate.getDay() === 5 && todayDate.getDay() === 1) {
        const expectedMonday = new Date(lastDate);
        expectedMonday.setDate(lastDate.getDate() + 3);
        return expectedMonday.toDateString() === todayDate.toDateString();
    }
    return false;
}

// Add this with your other button event listeners
const dailyWordleBtn = document.getElementById('dailyWordleBtn');
if (dailyWordleBtn) {
    dailyWordleBtn.addEventListener('click', () => {
        // Navigate to the special URL for the daily game
        window.location.href = window.location.pathname + '?daily=true';
    });
}
function displayLetterPattern(word) {
  const patternContainer = document.getElementById('letter-pattern-container');
  const hintsContainer = document.getElementById('daily-hints-container');
  if (!patternContainer || !hintsContainer) return;

  // --- SETUP PATTERN BUTTON AND SHAPES (No change) ---
  patternContainer.innerHTML = '';
  const showPatternButton = document.createElement('button');
  showPatternButton.id = 'show-pattern-btn';
  showPatternButton.textContent = 'Show pattern';
  
  const shapesWrapper = document.createElement('div');
  shapesWrapper.id = 'pattern-shapes-wrapper';
  
  patternContainer.appendChild(showPatternButton);
  patternContainer.appendChild(shapesWrapper);
  
  // (The shape and color generation logic is unchanged)
  // ... (omitted for brevity, no changes here) ...
  const shapes = [
    '<svg viewBox="0 0 100 100" class="pattern-shape"><rect x="10" y="10" width="80" height="80"/></svg>',
    '<svg viewBox="0 0 100 100" class="pattern-shape"><circle cx="50" cy="50" r="40"/></svg>',
    '<svg viewBox="0 0 100 100" class="pattern-shape"><polygon points="50,10 90,90 10,90"/></svg>',
    '<svg viewBox="0 0 100 100" class="pattern-shape"><polygon points="50,10 61,35 90,35 68,55 78,85 50,70 22,85 32,55 10,35 39,35"/></svg>',
    '<svg viewBox="0 0 100 100" class="pattern-shape"><polygon points="50,10 90,50 50,90 10,50"/></svg>'
  ];
  const colors = ["var(--shape-color-1)", "var(--shape-color-2)", "var(--shape-color-3)", "var(--shape-color-4)", "var(--shape-color-5)"];
  for (let i = shapes.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shapes[i], shapes[j]] = [shapes[j], shapes[i]]; }
  for (let i = colors.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [colors[i], colors[j]] = [colors[j], colors[i]]; }
  const letterToShapeMap = new Map();
  let shapeIndex = 0;
  for (const letter of word) {
    if (!letterToShapeMap.has(letter)) {
      const shapeSvg = shapes[shapeIndex % shapes.length];
      const color = colors[shapeIndex % colors.length];
      const coloredShapeSvg = shapeSvg.replace('class="pattern-shape"', `class="pattern-shape" style="fill: ${color};"`);
      letterToShapeMap.set(letter, coloredShapeSvg);
      shapeIndex++;
    }
  }
  for (const letter of word) {
    const shapeHtml = letterToShapeMap.get(letter);
    const shapeDiv = document.createElement('div');
    shapeDiv.innerHTML = shapeHtml;
    shapesWrapper.appendChild(shapeDiv);
  }

  // --- HINT BUTTON LOGIC ---
  hintsContainer.innerHTML = ''; 
  
  const langWrapper = document.createElement('div');
  langWrapper.className = 'hint-wrapper';
  const langButton = document.createElement('button');
  langButton.className = 'daily-hint-btn custom-tooltip';
  langButton.dataset.tooltip = 'Reveal Language';
  langButton.textContent = '🏳️';
  langButton.onclick = (event) => {
      event.stopPropagation();
      closeAllTooltips();      
      langButton.disabled = true;
      const languages = findWordLanguages(word.toLowerCase());
      const langText = languages.map(l => l.charAt(0).toUpperCase() + l.slice(1)).join(', ');
      
      const tooltip = document.createElement('span');
      tooltip.className = 'hint-tooltip';
      tooltip.textContent = langText;
      langWrapper.appendChild(tooltip);

      setTimeout(() => { tooltip.classList.add('is-visible'); }, 10);
  };
  langWrapper.appendChild(langButton);
  
  const specialCharWrapper = document.createElement('div');
  specialCharWrapper.className = 'hint-wrapper';
  const specialCharButton = document.createElement('button');
  specialCharButton.className = 'daily-hint-btn custom-tooltip';
  specialCharButton.dataset.tooltip = 'Reveal Special Characters';
  specialCharButton.textContent = '💬';
  specialCharButton.onclick = (event) => {
      event.stopPropagation();
      closeAllTooltips();
      specialCharButton.disabled = true;
      const specialChars = ['J', 'Q', 'X', 'Z', 'Æ', 'Ø', 'Å', 'Ö', 'Ä', 'Ü', 'ẞ'];
      const foundChars = [...new Set(word)].filter(char => specialChars.includes(char));
      
      const tooltip = document.createElement('span');
      tooltip.className = 'hint-tooltip';
      tooltip.textContent = foundChars.length > 0 ? foundChars.join(', ') : 'No special characters';
      specialCharWrapper.appendChild(tooltip);

      setTimeout(() => { tooltip.classList.add('is-visible'); }, 10);
  };
  specialCharWrapper.appendChild(specialCharButton);
  
  // ✅ UPDATED: Similar Word Hint
  const similarWordWrapper = document.createElement('div');
  similarWordWrapper.className = 'hint-wrapper';
  const similarWordButton = document.createElement('button');
  similarWordButton.className = 'daily-hint-btn custom-tooltip';
  similarWordButton.dataset.tooltip = 'Reveal Similar Word';
  similarWordButton.textContent = '🤝';
  similarWordButton.onclick = (event) => {
    event.stopPropagation();
    closeAllTooltips();
    similarWordButton.disabled = true;
    
    // Call the new helper function to get a similar word
    const similarWord = findSimilarWord(word, allWordsSet);
    
    const tooltip = document.createElement('span');
    tooltip.className = 'hint-tooltip';
    tooltip.textContent = similarWord;
    similarWordWrapper.appendChild(tooltip);

    setTimeout(() => { tooltip.classList.add('is-visible'); }, 10);
  };
  similarWordWrapper.appendChild(similarWordButton);

  hintsContainer.appendChild(langWrapper);
  hintsContainer.appendChild(specialCharWrapper);
  hintsContainer.appendChild(similarWordWrapper); // Add the new button to the container

  // --- MAIN ONCLICK HANDLER ---
  showPatternButton.onclick = () => {
    showPatternButton.disabled = true;
    showPatternButton.style.opacity = '0';
    setTimeout(() => {
      showPatternButton.style.display = 'none';
      shapesWrapper.style.display = 'flex';
      
      const shapeDivs = shapesWrapper.querySelectorAll('div');
      shapeDivs.forEach((shape, index) => {
        setTimeout(() => {
          shape.classList.add('is-flipping');
        }, index * 100);
      });
    }, 300);
  };

  patternContainer.style.display = 'flex';
  hintsContainer.style.display = 'flex';
}
function closeAllTooltips() {
  // Find and remove all visible tooltips
  document.querySelectorAll('.hint-tooltip').forEach(tooltip => tooltip.remove());
  
  // Find and re-enable all hint buttons
  document.querySelectorAll('.daily-hint-btn').forEach(button => button.disabled = false);
}
function findSimilarWord(secretWord, allWordsSet) {
  const lowercasedSecret = secretWord.toLowerCase();
  const similarWords = [];

  // Iterate through the entire dictionary
  for (const word of allWordsSet) {
    // Skip the secret word itself
    if (word === lowercasedSecret) {
      continue;
    }

    let matchCount = 0;
    // Compare each word letter-by-letter to the secret word
    for (let i = 0; i < 5; i++) {
      if (word[i] === lowercasedSecret[i]) {
        matchCount++;
      }
    }

    // If it has exactly 3 matching letters in the same positions, add it
    if (matchCount === 3) {
      similarWords.push(word);
    }
  }

  if (similarWords.length > 0) {
    // Return a random word from the list of matches
    return similarWords[Math.floor(Math.random() * similarWords.length)].toUpperCase();
  } else {
    return "No similar word found";
  }
}
</script>
</body>
</html>
