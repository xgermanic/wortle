<!DOCTYPE html>
<html lang="en">
<head>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
<script src="definitions.js"></script>
<script src="theme.js"></script>
<link rel="icon" type="image/x-icon" href="/wortle/images/favicon.ico">
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Sansita:ital,wght@1,700&display=swap" rel="stylesheet">
<title>WÃ˜RTLE</title>

  <link id="theme-stylesheet" rel="stylesheet" href="style-light.css">
  <style>
    #mainContent { visibility: hidden; }
    /* ADD THIS RULE FOR DISABLED INPUTS */
  input:disabled {
    opacity: 1;
    cursor: not-allowed;
  }
  .disabled-container, .disabled-container * {
  opacity: 1;
  cursor: not-allowed !important;
}
/* ADD THESE RULES FOR THE MINI-KEYBOARD */
  .mini-keyboard {
    margin: 2px 0 !important;
    max-width: 500px; /* Limit width */
    align-self: center; /* Center it */
  }
  .mini-keyboard .key {
    width: 22px; /* Adjust key size */
    height: 28px;
    font-size: 11pt;
    padding: 0;
    background-color: var(--bg-keyboard);
    border: 0px solid var(--border-subtle);
  }
  /* This container allows us to position the '?' icon relative to the input */
  .input-with-tooltip-container {
    position: relative;
    display: flex;
    justify-content: center;
    width: 100%;
    padding:0;
    margin: 4px 0;
    max-width: 500px; /* Ensures it matches other inputs */
  }

  /* The '?' icon itself */
  .tooltip-trigger {
    position: absolute;
    top: 50%;
    right: 23%; /* Position it just outside the container */
    transform: translateY(-50%);
    background-color: #888;
    color: white;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: bold;
    cursor: help;
    user-select: none; /* Prevents selecting the '?' text */
  }

  /* The tooltip text box (hidden by default) */
  .tooltip-trigger .tooltip-text {
    visibility: hidden;
    opacity: 0;
    width: 240px;
    background-color: #333;
    color: #fff;
    text-align: center;
    border-radius: 6px;
    padding: 10px;
    position: absolute;
    z-index: 10;
    bottom: 150%; /* Position it above the '?' */
    left: 50%;
    transform: translateX(-50%);
    transition: opacity 0.2s;
    font-weight: normal;
    line-height: 1.4;
  }

  /* Creates the small arrow pointing down from the tooltip */
  .tooltip-trigger .tooltip-text::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: #333 transparent transparent transparent;
  }

  /* Show the tooltip when hovering over the '?' icon */
  .tooltip-trigger:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
  }

  /* Make the label a container for our custom checkbox */
  label.custom-checkbox-label {
    position: relative;
    padding-left: 0px; /* Leave space for the custom checkbox */
    line-height: 18px;  /* Align text vertically */
  }

  /* Hide the default browser checkbox */
  label.custom-checkbox-label .specialCharCheckbox {
    position: absolute;
    opacity: 0;
    height: 0;
    width: 0;
  }

  /* Create a new, stylable checkbox box */
  .custom-checkmark {
    position: absolute;
    top: 0;
    left: 35%;
    height: 16px;
    width: 16px;
    background-color: #eee;
    border: 1px solid #888888;
    border-radius: 3px;
  }
  
  /* When the hidden checkbox is checked, color our custom box blue */
  label.custom-checkbox-label .specialCharCheckbox:checked ~ .custom-checkmark {
    background-color: #2196F3; /* This is our blue color */
    border-color: #2196F3;
  }

  /* Create the checkmark (hidden by default) */
  .custom-checkmark:after {
    content: "";
    position: absolute;
    display: none;
  }

  /* Show the checkmark when the box is checked */
  label.custom-checkbox-label .specialCharCheckbox:checked ~ .custom-checkmark:after {
    display: block;
  }

  /* Style the checkmark itself */
  label.custom-checkbox-label .custom-checkmark:after {
    left: 5px;
    top: 2px;
    width: 4px;
    height: 8px;
    border: solid white;
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }
/* The dark background overlay */
.language-popup-overlay {
  visibility: hidden;
  opacity: 0;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 10000;
  transition: opacity 0.3s ease;
}
.language-popup .close-btn {
  top:-28px;
}

/* The popup window itself */
.language-popup {
    width:300px;
    max-height: 500px;
    background-color: var(--bg-panel);
    border-top:20px solid var(--present-bg);
    border-radius:10px;
    padding: 30px;
    color: var(--text-primary);
    box-shadow: 0 5px 15px var(--shadow);
  visibility: hidden;
  opacity: 0;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.9);
  z-index: 10001;
  text-align: center;
  transition: opacity 0.3s ease, transform 0.3s ease;
}

/* The class that makes the popup visible */
.language-popup-overlay.show,
.language-popup.show {
  visibility: visible;
  opacity: 1;
}
.language-popup.show {
    transform: translate(-50%, -50%) scale(1);
}


/* Styling for elements inside the popup */
.language-popup-title {
  color: var(--text-primary);
  font-size: 16pt;
  font-weight:400;
  margin-top:0;
  font-family:monospace;
}
.language-popup-text {
    color: var(--text-primary);
    font-size: 11pt;
  margin-bottom: 20px;
  font-family:monospace;
}
.language-popup-input {
  width: 80%;
  padding:5px;
  border-radius:10px;
  font-family:monospace;
  border:2px solid var(--border-subtle);
  box-sizing: border-box; /* Important for padding */
}
.language-popup-button {
  margin-top: 20px;
  cursor: pointer;
  transition: background-color 0.2s;
}
.scoreboard-content-container {
  max-height: 400px;
  overflow:scroll;
}
/* REPLACE your old #account-sidebar-header and #account-sidebar-flag rules with these */
/* REPLACE your old #account-sidebar-title and #account-sidebar-flag rules with these */

/* This container is still just for alignment */
#account-sidebar-header {
  text-align: center;
}

/* Make the title the positioning container */
#account-sidebar-title {
  position: relative;
  display: inline-block;
  /* Add padding on BOTH sides to make space for the flag while keeping the text centered */
  padding: 0; 
}

/* Position the flag absolutely within the right padding of the title */
#account-sidebar-flag {
  position: absolute;
  right: -35px; /* Position inside the right padding */
    top: 60%;
    transform: translateY(-50%);
    font-size: 1.4rem;
}
/* ADD THIS RULE FOR THE NEW HINT MESSAGE */
  .hint-popup p, #hint-unlock-next-message {
    font-size: 0.9rem;
    font-style: italic;
    opacity: 0.8;
    margin-top: 15px;
    color: var(--text-secondary);
  }
/* ADD THESE RULES FOR THE LANGUAGE SWITCHER */
  .language-input-container {
    position: relative;
    display: flex;
    justify-content: center;
    width: 100%;
    max-width: 500px; /* Ensures it matches other inputs */
  }

  #switch-language-btn {
    display: none; /* Hidden by default */
    position: absolute;
    top: 48%;
    right: 23.5%;
    transform: translateY(-50%);
    background-color: transparent;
    border: none;
    color: #888888;
    width: 22px;
    height: 22px;
    border-radius: 50%;
    font-size: 26px;
    font-weight: bold;
    line-height: 15px;
    vertical-align: middle;
    cursor: pointer;
    transition: color 0.2s;
  }
  #switch-language-btn:hover {
    color: #555555;
  }
  #word-status-indicator.valid, #word-status-indicator.invalid {
    font-weight:bold;
  }
  .hard-mode-toggle-container {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  margin: 10px 0 0 0;
  letter-spacing: 1px;
  font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
  font-size: 12pt;
  color: var(--text-primary);
}
.toggle-switch {
  position: relative;
  display: inline-block;
  width: 44px;
  height: 24px;
}
.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 34px;
}
.slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}
input:checked + .slider {
  background-color: var(--correct-bg); /* Use your theme's 'correct' color */
}
input:checked + .slider:before {
  transform: translateX(20px);
}


  </style>
  
</head>
<body>
<div id="toast-container"></div>

<div id="language-popup-overlay" class="language-popup-overlay"></div>

<div id="language-popup" class="language-popup" role="dialog" aria-modal="true" aria-labelledby="language-popup-title">
  <h2 id="language-popup-title" class="language-popup-title">Welcome!</h2>
  <p class="language-popup-text">To finish setting up your profile, can you tell us what your native language is?</p>
    <select id="language-popup-input" class="language-popup-input">
      <option value="" disabled selected>Select your language...</option>
      </select>
  <button id="language-popup-save-btn" class="language-popup-button">Save and Continue</button>
</div>

<div id="game-scoreboard-overlay" class="language-popup-overlay"></div>

<div id="game-scoreboard-popup" class="language-popup" role="dialog" aria-modal="true" aria-labelledby="game-scoreboard-title">
  <button class="close-btn" onclick="closeGameScoreboard()">&times;</button>
  <h2 id="game-scoreboard-title" class="language-popup-title">Scoreboard</h2>
  <div id="game-scoreboard-content" class="scoreboard-content-container">
    <p>Loading scores...</p>
  </div>
</div>

<h1>
  <div class="h1-button-group-left">
    <!-- <button id="practiceBtn" aria-label="Practice Mode" class="help-button custom-tooltip" data-tooltip="Practice Mode">ğŸ¯</button>-->
    <button id="globalScoreboardBtn" aria-label="Global Scoreboard" class="help-button custom-tooltip" data-tooltip="Global Scoreboard">ğŸŒ</button>
    <button id="themeToggleBtn" aria-label="Toggle Theme" class="help-button custom-tooltip" data-tooltip="Switch Theme">ğŸŒ™</button>
  </div>
  <p><span style="color:var(--accent-color);">Cross-Germanic</span> WÃ˜RTLE</p>
  <div class="h1-button-group-right">
    <button id="newGameBtn" aria-label="Create New Game" class="help-button custom-tooltip" data-tooltip="New WÃ¸rtle">+</button>
    <button id="helpBtn" aria-label="Show Help" data-tooltip="Info" class="help-button custom-tooltip">?</button>
    <button id="accountBtn" aria-label="My Account" class="help-button custom-tooltip" data-tooltip="My Account">U</button>
  </div>
</h1>
<div id="loader">Loading WÃ¸rtle...</div>

<div id="mainContent">

<div id="header-setup">
    <div class="header-content-wrapper">
      <div id="setup-username-area" class="user-info-area"></div>
    </div>
</div>

<div id="setup" style="padding-bottom:10px;">
  <div id="setup-form-content">
  <p style="margin-bottom:20px;">Enter a secret word, hints and an optional fun fact</p>
      <div class="input-with-indicator">
    <input type="text" id="secretInput" maxlength="5" placeholder="Secret word" class="word-host-input"/>
    <span id="word-status-indicator"></span>
  </div>
    <button id="generateWordBtn" style="margin:5px 0 7px 0;">Pick Random Word</button>
    <!-- 
    <div id="special-char-keyboard" class="keyboard mini-keyboard">
    <div class="key-row">
      <button class="key" onclick="insertSpecialChar('Ã„')">Ã„</button>
      <button class="key" onclick="insertSpecialChar('Ã–')">Ã–</button>
      <button class="key" onclick="insertSpecialChar('Ãœ')">Ãœ</button>
      <button class="key" onclick="insertSpecialChar('áº')">áº</button>
      <button class="key" onclick="insertSpecialChar('Ã†')">Ã†</button>
      <button class="key" onclick="insertSpecialChar('Ã˜')">Ã˜</button>
      <button class="key" onclick="insertSpecialChar('Ã…')">Ã…</button>
    </div>
  </div>
  -->

<div class="language-input-container">
  <input type="text" id="hintInput" placeholder="Language" class="host-input is-auto-populated" disabled/>
  <button id="switch-language-btn" onclick="switchLanguage()">â€º</button>
</div>


  <input type="text" id="hintInput2" placeholder="Part of speech" class="host-input"/>

    <div class="input-with-tooltip-container">
    <input type="text" id="hintInput3" placeholder="Context clue" style="margin:0px;" class="host-input"/>
    <span class="tooltip-trigger">?
      <span class="tooltip-text">
        Guessing a word from another language is difficult! 
        Provide a helpful clue, such as a sentence that uses the secret word, replacing the word itself with underscores (e.g., "A Viking longship is powered by a large rectangular ____.").
      </span>
    </span>
  </div>

  <div id="hintInput4Container" class="disabled-container">
  <p>Special character(s)</p>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Ã„" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Ã„</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Ã–" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Ã–</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Ãœ" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Ãœ</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="áº" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>áº</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Ã†" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Ã†</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Ã˜" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Ã˜</label>
  <label style="display:block; margin-bottom:4px;" class="custom-checkbox-label">
  <input type="checkbox" value="Ã…" class="specialCharCheckbox is-auto-populated" disabled>
  <span class="custom-checkmark"></span>Ã…</label>
</div>
  <textarea id="funFactInput" placeholder="Fun fact about the word (to be shown after the game is over)"></textarea>
  <button onclick="startGame()" style="margin:10px;">Create Game</button>
</div>
</div>

  
  <p id="message"></p>

<div id="game">

  <div id="board" class="board"></div>

<div id="hintButtons" style="display: none;">
  <div id="hintTitle" style="cursor:pointer;">Need a hint?</div>
</div>

  <div id="keyboard" class="keyboard"></div>
    <div class="hard-mode-toggle-container">
    <label for="hard-mode-toggle" class="hard-mode-label">Hard Mode</label>
    <label class="toggle-switch">
      <input type="checkbox" id="hard-mode-toggle" checked>
      <span class="slider"></span>
    </label>
  </div>
  <button id="giveUpBtn">I Give Up</button>
  <p id="host-credit"></p>
</div>

<div id="game-over-overlay" class="modal-overlay">

  <div id="game-over-modal" class="modal">

    <div id="scoreboard-panel" class="side-panel">
      <div class="side-panel-content">
        <h2 style="font-size:14pt;">Scoreboard for <span id="scoreboard-word"></span></h2>
        <div id="scoreboard-summary-container"></div>
        <div id="scoreboard-container"></div>
      </div>
    </div>

      <button id="closeModalBtn" class="close-btn">&times;</button>
    <div class="modal-content">
      <p id="modal-message"></p>
      <pre id="modal-summary"></pre>

      <div class="modal-button-container">
        <button id="modalCopyBtn">Copy Result</button>
        <button id="showStatsBtn">Show My Stats</button>
        <div id="modal-stats-container"></div>
        <button id="showScoreboardBtn">View Scoreboard</button>
      </div>
    </div>

  </div>
</div>

<div id="share-modal" class="share-popup">
  <div class="modal-content">
    <p style="font-weight:600;margin-bottom:5px;font-size: 12pt;width:auto;font-family:monospace;">Share with others:</p>
    <textarea id="share-message-box" readonly></textarea>
    <div class="button-group">
      <button id="copy-url-btn">Copy Text</button>
      <button id="start-playing-btn">Start Playing</button>
    </div>
  </div>
</div>
</div>

<div id="helpOverlay" class="overlay"></div>
<div id="helpPopup" class="help-popup" role="dialog" aria-modal="true" aria-labelledby="helpTitle" tabindex="-1" hidden>
  <div class="help-popup-content">
    <button id="closeHelpBtn" aria-label="Close help" class="close-help-btn">&times;</button>
    <h2 id="helpTitle">How to WÃ¸rtle</h2>
    <p>Enter or generate a secret word, as well as hints for the user to reveal. If the word is not accepted, it is either not in the word list or has already been used. Share the URL with players.</p>
    <hr>
    <p>WÃ˜RTLE is currently enabled for:<br>
    German &mdash; 3902 words<br>
    Norwegian &mdash; 15651 words<br>
    Swedish &mdash; 4585 words<br>
    Danish &mdash; 4548 words<br>
    English &mdash; 14849 words</p>
    <p>Each language utilises a limited word list, which vary in how extensive they are.</p>
    <hr>
    <p><i>Created by lokke@ and bicks@<br>Original idea by aottl@</i></p>
    <p>Find a bug? Want to add a word to the word list? Or have any other suggestions for improvement?<br>Please write to lokke@google.com</p>
  </div>
</div>

<div id="hintPopup" class="hint-popup" role="dialog" aria-modal="true" aria-labelledby="hintPopupTitle">
    <button id="closeHintPopupBtn" aria-label="Close hint popup" class="close-hint-btn">&times;</button>
    <p id="hint-unlock-message" style="display: none;"></p>
    <div id="hintButtonsContainer">
        <button id="hintBtn1" class="hint-button" onclick="showHint(1)">
            <span class="hint-label">Language</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn2" class="hint-button" onclick="showHint(2)">
            <span class="hint-label">Part Of Speech</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn3" class="hint-button" onclick="showHint(3)">
            <span class="hint-label">Context</span>
            <span class="hint-text"></span>
        </button>
        <button id="hintBtn4" class="hint-button" onclick="showHint(4)">
            <span class="hint-label">Special Character(s)</span>
            <span class="hint-text"></span>
        </button>
    </div>
    <p id="hint-unlock-next-message" style="display: none;"></p>
</div>

<div id="account-overlay" class="overlay"></div>
<div id="account-sidebar">
  <button id="closeAccountBtn" class="close-help-btn">&times;</button>
<div id="account-sidebar-header">
  <h2 id="account-sidebar-title">
    <span id="account-username-text">My Account</span>
    <span id="account-sidebar-flag"></span>
  </h2>
</div>
  <div id="account-badges-container"></div>
  <div id="sidebar-loader">
    <div class="spinner"></div>
    Loading account...
  </div>
  <div id="sidebar-content">
    <div id="account-stats-section" class="account-section"></div>
    <div id="account-graph-container" class="account-section"></div>
    <div class="account-section">
        <h3 id="hosted-games-title" class="user-games-title">Hosted Games</h3>
        <div id="hosted-games-list" class="games-list"></div>
    </div>
    <div class="account-section">
        <h3 id="played-games-title" class="user-games-title">Played Games</h3>
        <div id="played-games-list" class="games-list"></div>
    </div>
  </div>
</div>

<div id="hintPopupOverlay" class="popup-overlay"></div>

<script>
let secret = "";
let customHint1 = "";
let customHint2 = "";
let customHint3 = "";
let customHint4 = "";
let customFunFact = "";
let hintUsed1 = false;
let hintUsed2 = false;
let hintUsed3 = false;
let hintUsed4 = false;
let currentRow = 0;
let currentCol = 0;
const rows = 8;
const cols = 5;
let grid = [];
let keyColors = {};
let guessHistory = [];
let colorHistory = [];
let usernameSet = false;
let isAnimating = false;
let isHardMode = true; // Hard mode is on by default
let hardModeWasDisabled = false;
let gameCreatedDate = null;
let hintExpanded1 = false;
let hintExpanded2 = false;
let hintExpanded3 = false;
let hintExpanded4 = false;
let scoreboardListener = null;
let badgesRef = null;      // <-- Ensure this line exists
let badgesListener = null;
let langRef = null;      // ADD THIS
let langListener = null; // ADD THIS
// Near the top of your script with other global variables
let gameNumber = null;
let hostUsername = null;
let isModalOpen = false;
let userListener = { ref: null, listener: null };
let availableLanguagesForWord = [];
let currentLanguageIndex = 0;
const hintTitle = document.getElementById("hintTitle");
const hintPopup = document.getElementById("hintPopup");
const hintPopupOverlay = document.getElementById("hintPopupOverlay");
const closeHintPopupBtn = document.getElementById("closeHintPopupBtn");
const game = document.getElementById("game");
const validLanguages = new Set([
    'bulgarian', 'croatian', 'czech', 'danish', 'dutch', 'english', 
    'estonian', 'finnish', 'french', 'german', 'greek', 'hungarian', 
    'irish', 'italian', 'latvian', 'lithuanian', 'polish', 
    'portuguese', 'romanian', 'slovak', 'slovenian', 'spanish', 
    'swedish', 'norwegian', 'russian', 'turkish'
]);
const languageToCountryCode = {
  bulgarian: 'BG', croatian: 'HR', czech: 'CZ', danish: 'DK',
  dutch: 'NL', english: 'GB', estonian: 'EE', finnish: 'FI',
  french: 'FR', german: 'DE', greek: 'GR', hungarian: 'HU',
  irish: 'IE', italian: 'IT', latvian: 'LV', lithuanian: 'LT',
  polish: 'PL', portuguese: 'PT', romanian: 'RO',
  slovak: 'SK', slovenian: 'SI', spanish: 'ES', swedish: 'SE',
  norwegian: 'NO', russian: 'RU', turkish: 'TR'
};
const SUPPORTED_LANGUAGES = ['german', 'norwegian', 'english', 'swedish', 'danish']; // <-- Add all your file names here (without .txt)
const wordLists = new Map();
const practiceBtn = document.getElementById('practiceBtn');
if (practiceBtn) {
    practiceBtn.addEventListener('click', () => {
        // This will take the user to your new practice page
        window.location.href = 'practice.html';
    });
}
const globalScoreboardBtn = document.getElementById('globalScoreboardBtn');
if (globalScoreboardBtn) {
    globalScoreboardBtn.addEventListener('click', () => {
        // This will take the user to your new scoreboard page
        window.location.href = 'scoreboard.html';
    });
}

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyDGepZP9hu3hHAL1wfrp4gjIurEPLPUbaw",
  authDomain: "woertle-7dc73.firebaseapp.com",
  databaseURL: "https://woertle-7dc73-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "woertle-7dc73",
  storageBucket: "woertle-7dc73.firebasestorage.app",
  messagingSenderId: "97063588719",
  appId: "1:97063588719:web:dc734f9c0772d49e5b0e9a"
};

// Initialize Firebase using the global firebase object
firebase.initializeApp(firebaseConfig);

// Create a database reference for your other functions to use
const database = firebase.database();

// --- NEW: Debounce timer for live validation ---
let debounceTimer;

/**
Â * Converts a string to uppercase, correctly handling the German Eszett (ÃŸ -> áº).
Â * The standard .toUpperCase() converts 'ÃŸ' to 'SS'.
Â * @param {string} str The string to convert.
Â * @returns {string} The uppercased string.
Â */
function germanFriendlyUpperCase(str) {
    return str.replace(/ÃŸ/g, 'áº').toUpperCase();
}

/**
 * Inserts a special character into the secret word input field.
 * @param {string} char The character to insert.
 */
function insertSpecialChar(char) {
    const secretInput = document.getElementById('secretInput');
    const maxLength = parseInt(secretInput.maxLength, 10);
    
    // Do nothing if the input is already full
    if (secretInput.value.length >= maxLength) {
        return;
    }

    const currentPos = secretInput.selectionStart;
    const currentValue = secretInput.value;

    // Insert the character at the current cursor position
    const newValue = currentValue.slice(0, currentPos) + char + currentValue.slice(currentPos);
    secretInput.value = newValue;

    // Move the cursor to after the inserted character
    secretInput.selectionStart = secretInput.selectionEnd = currentPos + 1;

    // Trigger the input event to run validation and auto-population
    secretInput.dispatchEvent(new Event('input', { bubbles: true }));

    // Return focus to the input field
    secretInput.focus();
}
/**
 * Validates the secret word in the input field.
 * Checks length, dictionary, and database availability.
 * Updates the UI with a status indicator (âœ…, âŒ, or loading spinner).
 * @returns {Promise<boolean>} - True if the word is valid and available, otherwise false.
 */
async function validateSecretWord() {
    const secretInput = document.getElementById('secretInput');
    const indicator = document.getElementById('word-status-indicator');
    const switchBtn = document.getElementById('switch-language-btn');
    const langInput = document.getElementById('hintInput');
    const word = germanFriendlyUpperCase(secretInput.value.trim());

    // --- Reset state on every validation check ---
    indicator.innerHTML = '';
    indicator.className = '';
    switchBtn.style.display = 'none';
    availableLanguagesForWord = [];
    currentLanguageIndex = 0;

    if (!word) {
        langInput.value = ''; // Clear language if word is cleared
        return false;
    }

    if (word.length !== 5 || !/^[A-ZÃ„Ã–ÃœÃŸáºÃ†Ã˜Ã…]+$/i.test(word)) {
        indicator.innerHTML = 'X';
        indicator.className = 'invalid';
        langInput.value = ''; // Clear language if word is invalid
        return false;
    }

    if (!isValidWord(word)) {
        indicator.innerHTML = 'X';
        indicator.className = 'invalid';
        langInput.value = ''; // Clear language if word is not in list
        return false;
    }

    indicator.className = 'loading';

    try {
        const gameRef = database.ref('games/' + word);
        const snapshot = await gameRef.once('value');

        if (snapshot.exists()) {
            indicator.innerHTML = 'X';
            indicator.className = 'invalid';
            langInput.value = ''; // Clear language if word is taken
            return false;
        } else {
            indicator.innerHTML = 'Y';
            indicator.className = 'valid';

            // --- START: MODIFIED LANGUAGE LOGIC ---
            const languages = findWordLanguages(word.toLowerCase());
            availableLanguagesForWord = languages; // Store all found languages

                        if (languages.length > 0) {
                // --- START: MODIFIED LOGIC ---
                // This block now prevents the language from being reset if the
                // current selection is still valid for the entered word.
                const currentLangValue = langInput.value.trim().toLowerCase();
                const isCurrentLangValid = languages.includes(currentLangValue);

                if (!langInput.value || !isCurrentLangValid) {
                    // Only auto-populate if the input is empty or the language is no longer valid
                    const displayLanguage = languages[0];
                    langInput.value = displayLanguage.charAt(0).toUpperCase() + displayLanguage.slice(1);
                    currentLanguageIndex = 0; // Reset index to the start
                }
                // --- END: MODIFIED LOGIC ---

                if (languages.length > 1) {
                    switchBtn.style.display = 'block';
                }
            }

            // Auto-populate special characters
            const specialCharsInWord = new Set([...word].filter(c => "Ã„Ã–ÃœáºÃ†Ã˜Ã…".includes(c)));
            document.querySelectorAll(".specialCharCheckbox").forEach(cb => {
                cb.checked = specialCharsInWord.has(cb.value);
            });
            updateHintContainerBackground();
            saveSetupState();

            return true;
        }
    } catch (error) {
        console.error("Firebase check failed:", error);
        indicator.innerHTML = 'âš ï¸';
        indicator.className = 'invalid';
        langInput.value = '';
        return false;
    }
}

// Base64 helpers
function base64Encode(str) { return btoa(unescape(encodeURIComponent(str))); }
function base64Decode(str) { try { return decodeURIComponent(escape(atob(str))); } catch { return null; } }

function getSecretFromURL() {
  const params = new URLSearchParams(window.location.search);
  const encodedWord = params.get("w");
  const encodedHint1 = params.get("h1");
  const encodedHint2 = params.get("h2");
  const encodedHint3 = params.get("h3");
  const encodedHint4 = params.get("h4");

  if (!encodedWord) return null;
  const decodedWord = base64Decode(encodedWord);

  customHint1 = encodedHint1 ? base64Decode(encodedHint1) : "";
  customHint2 = encodedHint2 ? base64Decode(encodedHint2) : "";
  customHint3 = encodedHint3 ? base64Decode(encodedHint3) : "";
  customHint4 = encodedHint4 ? base64Decode(encodedHint4) : "";

  const encodedFunFact = params.get("ff");
  customFunFact = encodedFunFact ? base64Decode(encodedFunFact) : "";

  // âœ… Parse and store creation date ONLY if not already set
  if (!gameCreatedDate) {
    const encodedDate = params.get("d");
    if (encodedDate) {
      const decodedDateStr = base64Decode(encodedDate);
      const parsedDate = new Date(decodedDateStr);
      if (!isNaN(parsedDate)) {
        gameCreatedDate = parsedDate;
      }
    }
  }

  if (decodedWord && /^[A-ZÃ†Ã˜Ã…Ã„Ã–Ãœáº]{5}$/.test(decodedWord)) {
    return decodedWord.toUpperCase();
  }
  return null;
}

const hintContainer = document.getElementById("hintInput4Container");
const specialCharBoxes = document.querySelectorAll(".specialCharCheckbox");

function updateHintContainerBackground() {
  const anyChecked = Array.from(specialCharBoxes).some(cb => cb.checked);
  hintContainer.classList.toggle("darkened", anyChecked);
}

specialCharBoxes.forEach(cb => {
  cb.addEventListener("change", updateHintContainerBackground);
});

function saveSetupState() {
  const setupState = {
    secret: document.getElementById('secretInput').value,
    hint1: document.getElementById('hintInput').value,
    hint2: document.getElementById('hintInput2').value,
    hint3: document.getElementById('hintInput3').value,
    funFact: document.getElementById('funFactInput').value,
    // Save an array of the values of all checked boxes
    specialChars: Array.from(document.querySelectorAll('.specialCharCheckbox:checked')).map(cb => cb.value)
  };
  // Convert the object to a string and save it
  localStorage.setItem('wurtleSetupState', JSON.stringify(setupState));
}

function loadSetupState() {
  const savedStateJSON = localStorage.getItem('wurtleSetupState');
  if (savedStateJSON) {
    const savedState = JSON.parse(savedStateJSON);
    
    // Repopulate all the text fields
    document.getElementById('secretInput').value = savedState.secret || '';
    document.getElementById('hintInput').value = savedState.hint1 || '';
    document.getElementById('hintInput2').value = savedState.hint2 || '';
    document.getElementById('hintInput3').value = savedState.hint3 || '';
    document.getElementById('funFactInput').value = savedState.funFact || '';

    // Re-check all the necessary checkboxes
    if (savedState.specialChars && savedState.specialChars.length > 0) {
      document.querySelectorAll('.specialCharCheckbox').forEach(cb => {
        if (savedState.specialChars.includes(cb.value)) {
          cb.checked = true;
        }
      });
    }
  }
}

function generateShareURL(word, hint1, hint2, hint3, hint4, funFact) {
  const url = new URL(window.location);
  url.searchParams.set("w", base64Encode(word));
  if (hint1) url.searchParams.set("h1", base64Encode(hint1));
  if (hint2) url.searchParams.set("h2", base64Encode(hint2));
  if (hint3) url.searchParams.set("h3", base64Encode(hint3));
  if (hint4) url.searchParams.set("h4", base64Encode(hint4));
  if (funFact) url.searchParams.set("ff", base64Encode(funFact));
  const today = new Date().toISOString();
  url.searchParams.set("d", base64Encode(today));
  return url.href;
}

async function updateStats(username, won, guesses) {
    if (!username) return;

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const statsRef = database.ref(`userProfiles/${sanitizedUsername}/stats`);

    try {
        await statsRef.transaction(currentStats => {
            // If stats object doesn't exist at all, create a default one.
            if (currentStats === null) {
                currentStats = { gamesPlayed: 0, wins: 0, totalGuesses: 0 };
            }

            // âœ… ADD THIS BLOCK: This is the key fix.
            // It ensures each property is a number before we use it.
            currentStats.gamesPlayed = currentStats.gamesPlayed || 0;
            currentStats.wins = currentStats.wins || 0;
            currentStats.totalGuesses = currentStats.totalGuesses || 0;

            // Now we can safely do the math
            currentStats.gamesPlayed++;
            if (won) {
                currentStats.wins++;
                currentStats.totalGuesses += guesses;
            }
            currentStats.lastGameTrend = won ? "up" : "down";

            return currentStats;
        });

        // The badge check can remain here, it's correct.
        const newStatsSnapshot = await statsRef.once('value');
        const newStats = newStatsSnapshot.val();
        if (newStats && newStats.gamesPlayed >= 25) {
            awardBadge(username, 'social_butterfly');
        }

    } catch (error) {
        // This will now catch the NaN error if it ever happens again.
        console.error("Could not update stats in Firebase:", error);
    }
}

async function displayStats(username) {
    const user = username || "Player";
    const defaultStats = { gamesPlayed: 0, wins: 0, totalGuesses: 0 };
    let stats = { ...defaultStats }; // Use a copy

    if (username) {
        try {
            const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
            const statsRef = database.ref(`userProfiles/${sanitizedUsername}/stats`);
            const snapshot = await statsRef.once('value');
            if (snapshot.exists()) {
                stats = snapshot.val();
            }
        } catch (error) {
            console.error("Could not fetch stats from Firebase:", error);
        }
    }

    // Calculate the derived stats
    const winPct = stats.gamesPlayed > 0 ? ((stats.wins / stats.gamesPlayed) * 100).toFixed(1) : "0.0";
    const avgGuesses = stats.wins > 0 ? (stats.totalGuesses / stats.wins).toFixed(2) : "-";
    
    // Return a proper JavaScript object with key: value pairs
    return {
        username: user,
        gamesPlayed: stats.gamesPlayed,
        wins: stats.wins,
        totalGuesses: stats.totalGuesses,
        winPct: winPct,
        avgGuesses: avgGuesses
    };
}

async function startGame() {
    // 1. Get the username from localStorage just ONCE.
    const localHost = localStorage.getItem("gerNordleUsername");

    // 2. Check if it exists.
    if (!localHost) {
        showToast("You must be logged in to host a game.", "error");
        return;
    }

    // 3. Set the global 'hostUsername' variable for use in other functions (like generateResultText).
    //    The 'localHost' const will be used within this function.
    hostUsername = localHost;
    
    const isWordAvailable = await validateSecretWord();
    if (!isWordAvailable) {
        const secretInput = document.getElementById('secretInput');
        if (secretInput) {
            secretInput.classList.add('shake');
            setTimeout(() => secretInput.classList.remove('shake'), 500);
        }
        return;
    }

        // --- START: MODIFIED LOGIC TO GET GAME NUMBER ---
    let newGameNumber;
    try {
        const counterRef = database.ref('metadata/totalGames');
        const transactionResult = await counterRef.transaction(currentCount => {
            // If the counter doesn't exist, start it at 1. Otherwise, increment it.
            return (currentCount || 0) + 1;
        });

        if (!transactionResult.committed) {
            throw new Error("Failed to get a new game number from the database.");
        }
        newGameNumber = transactionResult.snapshot.val();
        gameNumber = newGameNumber; // Set the global variable for the current session

    } catch (error) {
        console.error("Could not generate game number:", error);
        showToast("Error creating game. Please try again.", "error");
        return;
    }

    const setupDiv = document.getElementById("setup");
    const headerSetup = document.getElementById("header-setup");
    const inputWord = germanFriendlyUpperCase(document.getElementById("secretInput").value.trim());
    const inputHint1 = document.getElementById("hintInput").value.trim();
    const inputHint2 = document.getElementById("hintInput2").value.trim();
    const inputHint3 = document.getElementById("hintInput3").value.trim();
    if (!inputHint1 || !inputHint2 || !inputHint3) {
        showToast("Hints must be filled out.", "error");
        return; // Stop the function if any required hints are missing
    }
    const inputHint4 = Array.from(document.querySelectorAll(".specialCharCheckbox:checked")).map(cb => cb.value).join(", ");
    const inputFunFact = document.getElementById("funFactInput").value.trim();

    secret = inputWord;
    customHint1 = inputHint1;
    customHint2 = inputHint2;
    customHint3 = inputHint3;
    customHint4 = inputHint4;
    customFunFact = inputFunFact;

    const metadataRef = database.ref('games/' + secret + '/metadata');
    try {
        const metadataToSave = {
            word: secret,
            hint1: customHint1, hint2: customHint2, hint3: customHint3,
            hint4: customHint4, funFact: customFunFact, host: localHost,
            gameNumber: newGameNumber
        };
        await metadataRef.set(metadataToSave);

        const sanitizedUsername = hostUsername.replace(/[.#$[\]]/g, '_');
        // 1. Check for 'Master Hintsmith' badge
        if (inputHint1 && inputHint2 && inputHint3 && inputHint4 && inputFunFact) {
            awardBadge(hostUsername, 'master_hintsmith');
        }

        // 2. Check for 'Prolific Host' and 'Community Pillar' badges
        const hostedGamesRef = database.ref(`userProfiles/${sanitizedUsername}/hostedGames`);
        const hostedSnapshot = await hostedGamesRef.once('value');
        const hostedCount = hostedSnapshot.numChildren();

        if (hostedCount + 1 >= 10) {
            awardBadge(hostUsername, 'prolific_host');
        }
        if (hostedCount + 1 >= 25) {
            awardBadge(hostUsername, 'community_pillar');
        }
        // --- END OF NEW LOGIC ---

        const userProfileRef = database.ref('userProfiles/' + sanitizedUsername);
        const newGameData = {};
        // Use the current date for the hosted game entry
        newGameData[`/hostedGames/${secret}`] = { createdDate: new Date().toISOString() };
        await userProfileRef.update(newGameData);

    } catch (error) {
        console.error("Firebase save failed:", error);
        return;
    }
    
    localStorage.removeItem('wurtleSetupState');

    const longUrl = generateShareURL(secret, customHint1, customHint2, customHint3, customHint4, customFunFact);
    const shareModal = document.getElementById("share-modal");
    const shareMessageBox = document.getElementById("share-message-box");
    const copyBtn = document.getElementById("copy-url-btn");
    const startBtn = document.getElementById("start-playing-btn");

    shareMessageBox.value = "Creating short link...";
    copyBtn.disabled = true;
    startBtn.disabled = true;
    shareModal.classList.add("show");
    setupDiv.inert = true;

    try {
        const response = await fetch(`https://tinyurl.com/api-create.php?url=${encodeURIComponent(longUrl)}`);
        if (!response.ok) throw new Error('TinyURL service is not available.');
        const shortUrl = await response.text();
        shareMessageBox.value = `Hi! Play my WÃ˜RTLE: ${shortUrl}`;
        await metadataRef.update({ shortUrl: shortUrl });
    } catch (error) {
        console.error("Could not shorten URL:", error);
        shareMessageBox.value = `Hi! Play my WÃ˜RTLE: ${longUrl}`;
    } finally {
        copyBtn.disabled = false;
        startBtn.disabled = false;
    }

    copyBtn.onclick = () => {
        shareMessageBox.select();
        navigator.clipboard.writeText(shareMessageBox.value).then(() => {
            copyBtn.textContent = "Copied!";
            setTimeout(() => { copyBtn.textContent = "Copy Text"; }, 2000);
        });
    };

Â  Â  startBtn.onclick = () => {
Â  Â  Â  Â  shareModal.classList.remove("show");
Â  Â  Â  Â  window.history.replaceState({}, "", longUrl);
Â  Â  Â  Â Â 
Â  Â  Â  Â  const gameDiv = document.getElementById("game");
Â  Â  Â  Â  const setupDiv = document.getElementById("setup");
Â  Â  Â  Â  
Â  Â  Â  Â  // The setup header is already visible, so we just hide the setup form.
Â  Â  Â  Â  setupDiv.style.display = "none";
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Show the game board. The header remains visible.
Â  Â  Â  Â  gameDiv.style.display = "flex";
Â  Â  Â  Â  gameDiv.style.flexDirection = "column";

Â  Â  Â  Â  // This will initialize the game state and ensure the header has the correct content.
Â  Â  Â  Â  checkUserStatus();
Â  Â  };
}

async function checkUserStatus() {
    let savedUsername = localStorage.getItem("gerNordleUsername");
    const gameElement = document.getElementById("game");
    displayHostCredit();

    if (!savedUsername) {
        window.currentUsername = null;
        loadGameFromStorage();
        return;
    }

    window.currentUsername = savedUsername;
    listenForUserDeletion(savedUsername);

    try {
        const sanitizedUsername = savedUsername.replace(/[.#$[\]]/g, '_');
        const playedGameRef = database.ref(`userProfiles/${sanitizedUsername}/playedGames/${secret}`);
        const playedGameSnapshot = await playedGameRef.once('value');

        if (playedGameSnapshot.exists()) {
            const playedGameData = playedGameSnapshot.val();
            const gameStatus = playedGameData.status;

            if (gameStatus === 'won' || gameStatus === 'lost') {
                gameElement.classList.add("dimmed");
                loadCompletedGame(playedGameData);
                return;
            } 
            // âœ… NEW: If the game is found in Firebase with 'ongoing' status, load it.
            else if (gameStatus === 'ongoing') {
                loadOngoingGame(playedGameData);
                return;
            }
        }
        
        // If no game is found in Firebase, start a fresh game.
        loadGameFromStorage();

    } catch (error) {
        console.error("Firebase completion check failed:", error);
        loadGameFromStorage();
    }
}

function loadGameFromStorage() {
Â  Â  let savedUsername = localStorage.getItem("gerNordleUsername");
Â  Â  const gameElement = document.getElementById("game");
Â  Â  const headerSetup = document.getElementById("header-setup");
Â  Â Â 
Â  Â  const savedPin = localStorage.getItem("gerNordleUserPin");
Â  Â  if (savedUsername && !savedPin) {
Â  Â  Â  Â  localStorage.removeItem("gerNordleUsername");
Â  Â  Â  Â  savedUsername = null;
Â  Â  }

Â  Â  initBoard();
Â  Â  initKeyboard();

Â  Â  if (savedUsername) {
Â  Â  Â  Â  // Setup for a brand new game for a logged-in user
Â  Â  Â  Â  usernameSet = true;
Â  Â  Â  Â  grid = Array(rows).fill(null).map(() => Array(cols).fill(""));
Â  Â  Â  Â  guessHistory = [];
Â  Â  Â  Â  colorHistory = [];
Â  Â  Â  Â  keyColors = {};
Â  Â  Â  Â  currentRow = 0;
Â  Â  Â  Â  currentCol = 0;
Â  Â  Â  Â  isAnimating = false;
        hardModeWasDisabled = false;
Â  Â  Â  Â Â 
Â  Â  Â  Â  setupUsernameInterface({
Â  Â  Â  Â  Â  Â  isGamePage: true,
Â  Â  Â  Â  Â  Â  containerId: 'setup-username-area',
Â  Â  Â  Â  Â  Â  inputId: 'usernameInputGame',
Â  Â  Â  Â  Â  Â  placeholder: 'Enter username'
Â  Â  Â  Â  });
Â  Â  Â  Â  updateBoard();
Â  Â  Â  Â  updateKeyboardColors();
Â  Â  Â  Â  updateHintButtons();
Â  Â  Â  Â  gameElement.classList.remove("dimmed");
Â  Â  Â  Â  headerSetup.style.display = 'flex'; // Show the setup header
Â  Â  Â  Â  gameElement.style.display = 'flex';
Â  Â Â 
Â  Â  } else {
Â  Â  Â  Â  // Setup for a logged-out user
Â  Â  Â  Â  updateHintButtons();
Â  Â  Â  Â  setupUsernameInterface({
Â  Â  Â  Â  Â  Â  isGamePage: true,
Â  Â  Â  Â  Â  Â  containerId: 'setup-username-area', // Target the setup header's container
Â  Â  Â  Â  Â  Â  inputId: 'usernameInputGame',
Â  Â  Â  Â  Â  Â  placeholder: 'Enter username'
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  headerSetup.style.display = 'flex'; // Show the setup header
Â  Â  Â  Â  gameElement.style.display = 'flex';
Â  Â  Â  Â  gameElement.classList.add("dimmed");
Â  Â  }
}

function updateBoard() {
  const board = document.getElementById("board");
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      board.children[r].children[c].textContent = grid[r][c];
    }
  }
}

function handleKeyPress(key) {
    if (!usernameSet || isAnimating) {
        return;
    }

    const msgEl = document.getElementById("message");
    if (msgEl.textContent.trim().startsWith("You win! ğŸ‰") || msgEl.textContent.trim().startsWith("Game over!")) return;

    // Animate the on-screen keyboard button if it exists
    const keyButton = document.querySelector(`.key[data-key="${key.toUpperCase()}"], .key[data-key="áº"][data-key-lower="ÃŸ"]`);
    if (keyButton) {
        keyButton.classList.add("key-pop");
        setTimeout(() => {
            keyButton.classList.remove("key-pop");
        }, 100);
    }

    if (/^[a-zA-ZÃ„Ã–ÃœÃ¤Ã¶Ã¼ÃŸáºÃ†Ã˜Ã…Ã¦Ã¸Ã¥]$/.test(key) && currentCol < cols) {
        let letter = key;
        // This logic now correctly handles ÃŸ -> áº before any other uppercasing
        if (key === "ÃŸ") {
            letter = "áº";
        } else {
            letter = key.toUpperCase();
        }

        grid[currentRow][currentCol] = letter;
        currentCol++;
        updateBoard();
    } else if (key === "Backspace" && currentCol > 0) {
        currentCol--;
        grid[currentRow][currentCol] = "";
        updateBoard();
    } else if (key === "Enter" && currentCol === cols) {
        submitGuess();
    }
}

window.addEventListener("keydown", (e) => {
    if (isModalOpen) return;
    if (!usernameSet || isAnimating) return;
    if (document.getElementById("game").style.display !== "flex") return;

    const key = e.key; // Get the key without changing its case

    if (key === "Backspace") {
        handleKeyPress("Backspace");
    } else if (key === "Enter") {
        handleKeyPress("Enter");
    } else if (/^[a-zA-ZÃ„Ã–ÃœÃ¤Ã¶Ã¼ÃŸáºÃ†Ã˜Ã…Ã¦Ã¸Ã¥]$/.test(key)) { // Check for any valid letter
        handleKeyPress(key); // Pass the original, unaltered key
    }
});

function validateHardMode(guess) {
Â  for (let i = 0; i < guessHistory.length; i++) {
    const prevGuess = guessHistory[i];
    const colors = colorHistory[i];
Â  Â Â 
    for (let j = 0; j < cols; j++) {
    Â  if (colors[j] === "correct" && guess[j] !== prevGuess[j]) {
        return `Hard mode violation: Letter '${prevGuess[j]}' must be in position ${j+1}`;
    Â  }
    }

    const presentLetters = {};
    for (let j = 0; j < cols; j++) {
    Â  if (colors[j] === "present") {
        presentLetters[prevGuess[j]] = (presentLetters[prevGuess[j]] || 0) + 1;
    Â  }
    }
    for (const letter in presentLetters) {
    Â  const countInGuess = [...guess].filter(l => l === letter).length;
    Â  if (countInGuess < presentLetters[letter]) {
        return `Hard mode violation: Guess must include letter '${letter}' at least ${presentLetters[letter]} time(s)`;
    Â  }
    }

    for (let j = 0; j < cols; j++) {
    Â  if (colors[j] === "absent") {
        const absentLetter = prevGuess[j];
        const isElsewherePresentOrCorrect = colors.some((color, idx) =>Â 
        Â  (color === "correct" || color === "present") && prevGuess[idx] === absentLetter);
        if (!isElsewherePresentOrCorrect) {
        Â  if (guess.includes(absentLetter)) {
            return `Hard mode violation: Letter '${absentLetter}' cannot be used`;
        Â  }
        }
    Â  }
    }
Â  }
Â  return true;
}

async function loadAllWordLists() {
    console.log("Loading all word lists...");

    const promises = SUPPORTED_LANGUAGES.map(lang => {
        const filePath = `${lang}.txt`; // e.g., "german.txt"
        return fetch(filePath)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${filePath}`);
                }
                return response.text();
            })
            .then(text => ({ lang, text })); // Pass language name along with text
    });

    try {
        const results = await Promise.all(promises);

        results.forEach(({ lang, text }) => {
            const words = text.split(/\s+/);
            const wordSet = new Set();
            words.forEach(word => {
                if (word) {
                    wordSet.add(word.trim().toLowerCase());
                }
            });
            wordLists.set(lang, wordSet); // Add the language-specific set to our Map
        });

        const totalWords = Array.from(wordLists.values()).reduce((sum, set) => sum + set.size, 0);
        console.log(`All word lists loaded! Total valid words: ${totalWords}`);

    } catch (error) {
        console.error("Could not load one or more word lists:", error);
    }
}

// ADD these two new functions right after 'loadAllWordLists'

/**
 * Finds the language a given word belongs to.
 * @param {string} word The word to search for (should be lowercase).
 * @returns {string|null} The name of the language or null if not found.
 */
function findWordLanguages(word) {
    const foundLanguages = []; // Initialize an empty array
    // Loop through all languages without stopping at the first match
    for (const [language, wordSet] of wordLists.entries()) {
        if (wordSet.has(word)) {
            foundLanguages.push(language); // Add every match to the array
        }
    }
    return foundLanguages; // Return the array of all languages found
}

function isValidWord(word) {
    // A word is valid if the array of languages is not empty.
    return findWordLanguages(word.toLowerCase()).length > 0;
}

async function submitGuess() {
    const guess = grid[currentRow].join("");
    const currentRowDiv = document.getElementById("board").children[currentRow];

    // This handles all validation checks before proceeding
    if (guess.length !== cols) {
        if (currentRowDiv) {
            currentRowDiv.classList.add("shake");
            setTimeout(() => { currentRowDiv.classList.remove("shake"); }, 500);
        }
        showToast("Not enough letters", "error");
        return;
    }

    if (!isValidWord(guess)) {
        if (currentRowDiv) {
            currentRowDiv.classList.add("shake");
            setTimeout(() => { currentRowDiv.classList.remove("shake"); }, 500);
        }
        showToast("Not in word list", "error");
        return;
    }

    // âœ… FIX: The hard mode validation and its toast message are now handled correctly.
      if (isHardMode) {
        const hardModeViolation = validateHardMode(guess);
        if (hardModeViolation !== true) { // Check if it returned a string message
            if (currentRowDiv) {
                currentRowDiv.classList.add("shake");
                setTimeout(() => { currentRowDiv.classList.remove("shake"); }, 500);
            }
            showToast(hardModeViolation, "error"); // Use the returned message directly
            return;
        }
    }

    isAnimating = true;
    document.getElementById("message").textContent = "";

    guessHistory.push(guess);
    
    // ...The rest of the function is correct and remains the same...

    const colors = Array(cols).fill("absent");
    const secretLetters = secret.split("");
    for (let i = 0; i < cols; i++) {
        if (guess[i] === secret[i]) {
            colors[i] = "correct";
            secretLetters[i] = null;
        }
    }
    for (let i = 0; i < cols; i++) {
        if (colors[i] === "correct") continue;
        const index = secretLetters.indexOf(guess[i]);
        if (index !== -1) {
            colors[i] = "present";
            secretLetters[index] = null;
        }
    }
    for (let i = 0; i < cols; i++) {
        const letter = guess[i];
        const color = colors[i];
        if (!keyColors[letter] || (color === "correct") || (color === "present" && keyColors[letter] === "absent")) {
            keyColors[letter] = color;
        }
    }

    colorHistory.push(colors);
    updateKeyboardColors();

    const board = document.getElementById("board");
    for (let i = 0; i < cols; i++) {
        const tile = board.children[currentRow].children[i];
        setTimeout(() => {
            tile.classList.add(colors[i]);
        }, i * 200);
    }

    setTimeout(async () => {
        if (guess === secret) {
            endGame(true);
        } else if (currentRow === rows - 1) {
            endGame(false);
        } else {
            currentRow++;
            currentCol = 0;
            updateHintButtons(); 
            isAnimating = false;
            await saveOngoingGame(window.currentUsername, base64Encode(secret));
        }
    }, (cols * 200) + 250);
}

async function endGame(won) {
    hideHintPopup();

    // Fetch the definitive fun fact from the database
    let definitiveFunFact = "";
    try {
        const metadataRef = database.ref(`games/${secret}/metadata`);
        const metaSnapshot = await metadataRef.once('value');
        if (metaSnapshot.exists()) {
            definitiveFunFact = metaSnapshot.val().funFact || "";
        }
    } catch (error) {
        console.error("Could not fetch metadata for final popup:", error);
        definitiveFunFact = customFunFact;
    }

    const gameResult = {
        isSolved: won,
        history: guessHistory,
        colors: colorHistory,
        hints: { hintUsed1, hintUsed2, hintUsed3, hintUsed4 },
        funFact: definitiveFunFact
    };

    // First, save the game data.
    try {
        await saveCompletedGameData(won);
    } catch (error) {
        console.error("Failed to save game results to Firebase:", error);
    }

    // Then, show the results modal.
    await showGameOverModal(
        gameResult.isSolved,
        gameResult.history,
        gameResult.colors,
        gameResult.hints,
        gameResult.funFact
    );

    // This block updates the underlying game board to the finished state
    setTimeout(() => {
        const gameContainer = document.getElementById('game');
        const messageEl = document.getElementById('message');
        const board = document.getElementById('board');

        // 1. Display the "You win!" or "Game over!" message on the board
        if (won) {
            messageEl.textContent = "You win! ğŸ‰";
        } else {
            messageEl.textContent = `Game over! The word was ${secret}.`;
        }
        messageEl.classList.add('visible');

        // 2. Replace the interactive board with a static summary of the guesses
        board.innerHTML = generateGuessHistoryHTML(gameResult.history, gameResult.colors);

        // --- ADD THIS LINE ---
        // This removes the fixed grid layout, allowing the board to shrink to fit the content.
        board.style.gridTemplateRows = 'none';

        // 3. Dim and disable the game container
        gameContainer.style.opacity = '0.5';
        gameContainer.style.pointerEvents = 'none';

        // 4. Disable the keyboard
        disableKeyboard();

        // --- ADD THIS BLOCK ---
        // Visually update the toggle to reflect the game's true hard mode status.
        const toggle = document.getElementById('hard-mode-toggle');
        if (toggle) {
            // '!hardModeWasDisabled' is the final truth for whether the game was hard mode.
            toggle.checked = !hardModeWasDisabled;
            toggle.disabled = true; // Also ensure it's not clickable
        }
        // --- END OF NEW BLOCK ---

    }, 400);
}

function disableKeyboard() {
  // Disable all on-screen keys
  document.querySelectorAll('.key').forEach(keyBtn => {
    keyBtn.disabled = true;
  });
  document.getElementById('giveUpBtn').disabled = true;
  // Use the existing isAnimating flag to block physical keyboard input
  isAnimating = true; 
}

function initBoard() {
  const board = document.getElementById("board");
  board.innerHTML = "";
  for (let r = 0; r < rows; r++) {
    const rowDiv = document.createElement("div");
    rowDiv.classList.add("row");
    for (let c = 0; c < cols; c++) {
      const tileDiv = document.createElement("div");
      tileDiv.classList.add("tile");
      rowDiv.appendChild(tileDiv);
    }
    board.appendChild(rowDiv);
  }
}

function initKeyboard() {
  const keyboardDiv = document.getElementById("keyboard");
  keyboardDiv.innerHTML = "";
  const keysLayout = [
    ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "Ã…"],
    ["A", "S", "D", "F", "G", "H", "J", "K", "L", "Ã–", "Ã„", "Ã˜"],
    ["Enter", "Z", "X", "C", "V", "B", "N", "M", "Ãœ", "áº", "Ã†", "Backspace"]
  ];

  keysLayout.forEach(row => {
    const rowDiv = document.createElement("div");
    rowDiv.classList.add("key-row");
    row.forEach(key => {
      const keyBtn = document.createElement("button");
      keyBtn.textContent = key;
      keyBtn.classList.add("key");
      keyBtn.dataset.key = key;
      keyBtn.onclick = () => handleKeyPress(key);
      rowDiv.appendChild(keyBtn);
    });
    keyboardDiv.appendChild(rowDiv);
  });
}

function updateKeyboardColors() {
    for (const key in keyColors) {
        const keyBtn = document.querySelector(`.key[data-key="${key}"]`);
        if (keyBtn) {
            keyBtn.classList.remove("present", "absent", "correct"); // Clear old colors
            keyBtn.classList.add(keyColors[key]);
        }
    }
}

function showHint(hintNumber) {
    let btn, hintText, hintContent;
    
    switch(hintNumber) {
        case 1:
            btn = document.getElementById('hintBtn1');
            hintContent = customHint1;
            if (hintUsed1) return; 
            hintUsed1 = true; 
            hintExpanded1 = true;
            break;
        case 2:
            btn = document.getElementById('hintBtn2');
            hintContent = customHint2;
            if (hintUsed2) return; 
            hintUsed2 = true; 
            hintExpanded2 = true;
            break;
        case 3:
            btn = document.getElementById('hintBtn3');
            hintContent = customHint3;
            if (hintUsed3) return; 
            hintUsed3 = true; 
            hintExpanded3 = true;
            break;
        case 4:
            btn = document.getElementById('hintBtn4');
            hintContent = customHint4;
            if (hintUsed4) return; 
            hintUsed4 = true; 
            hintExpanded4 = true;
            break;
    }

    if (btn && !btn.classList.contains('expanded')) {
        hintText = btn.querySelector('.hint-text');
        hintText.textContent = hintContent;
        btn.classList.add('expanded');
        hintText.classList.add('visible');
        btn.classList.add('clicked-hint');
        btn.disabled = true;
    }
    
    // âœ… Add this line to save the game state immediately
    if (window.currentUsername && secret) {
        saveOngoingGame(window.currentUsername, base64Encode(secret));
    }
}

function generateResultText(isForDisplay, history, colors, won, hintStatus) {
    // Get and format the current date
    const dateToUse = gameCreatedDate || new Date();
    const options = { year: 'numeric', month: 'short', day: 'numeric' };
    const dateString = dateToUse.toLocaleDateString('en-GB', options);

    let headerLine = `WÃ˜RTLE ${won ? history.length : 'X'}/${rows}`;
    if (gameNumber) {
        headerLine = `WÃ˜RTLE #${gameNumber} (${won ? history.length : 'X'}/${rows})`;
    }

    let text = headerLine + '\n'; // Add extra newline for spacing
    // --- ADD THIS BLOCK ---
    // Add the "Created by" line if the host's name is known
    if (hostUsername) {
        text += `Created by ${hostUsername}\n`;
    }
    // --- END OF NEW BLOCK ---

    // Count the total number of hints used
    let hintCount = 0;
    if (hintStatus.hintUsed1) hintCount++;
    if (hintStatus.hintUsed2) hintCount++;
    if (hintStatus.hintUsed3) hintCount++;
    if (hintStatus.hintUsed4) hintCount++;

    // Add the emoji grid (this part remains the same)
    const colorMap = {
        correct: 'ğŸŸ©',
        present: 'ğŸŸ¨',
        absent: 'â¬›'
    };

    for (let i = 0; i < colors.length; i++) {
        let rowText = colors[i].map(color => colorMap[color] || 'â¬›').join('');
        text += rowText + '\n';
    }

    // Add the hint summary sentence if any hints were used, followed by a blank line
    if (hintCount === 1) {
        text += "1 hint used\n";
    } else if (hintCount > 1) {
        text += `${hintCount} hints used\n`;
    } else {
        // If no hints were used, just add a blank line for spacing
        text += "\n";
    }

    return text;
}

function resetHints() {
    hintUsed1 = hintUsed2 = hintUsed3 = hintUsed4 = false;
    hintExpanded1 = hintExpanded2 = hintExpanded3 = hintExpanded4 = false; // Reset new variables
    ['hintBtn1', 'hintBtn2', 'hintBtn3', 'hintBtn4'].forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            btn.classList.remove('expanded', 'clicked-hint');
            btn.disabled = false;
            const hintTextSpan = btn.querySelector('.hint-text');
            if(hintTextSpan) {
              hintTextSpan.classList.remove('visible');
              hintTextSpan.textContent = '';
            }
            const hintLabel = btn.querySelector('.hint-label');
            if (hintLabel) {
                hintLabel.classList.remove('hidden');
            }
        }
    });
}
window.onload = async () => {
    await loadAllWordLists();

    const loader = document.getElementById('loader');
    const mainContent = document.getElementById('mainContent');
    
    secret = getSecretFromURL();
    const setupDiv = document.getElementById("setup");
    const gameDiv = document.getElementById("game");
    const messageEl = document.getElementById("message");
    const headerSetup = document.getElementById("header-setup");

    // Default state
    gameDiv.style.display = "none";
    headerSetup.style.display = "none";
    setupDiv.style.display = "none";
    loader.style.display = 'block';

    const params = new URLSearchParams(window.location.search);

    if (secret) {
        // This is the normal game-playing logic
        const gameRef = database.ref('games/' + secret);
        const snapshot = await gameRef.once('value');

        loader.style.display = 'none';

        if (snapshot.exists()) {
            // --- ADD THIS ---
            // Fetch the game number from the metadata
            const metadata = snapshot.val().metadata;
            if (metadata && metadata.gameNumber) {
                gameNumber = metadata.gameNumber;
            }
            hostUsername = metadata.host;
            headerSetup.style.display = "flex";
            gameDiv.style.display = "flex";
            gameDiv.style.flexDirection = "column"; 
            checkUserStatus();
        } else {
            messageEl.innerHTML = `The game you are looking for does not exist or has been deleted.<br><br><a href="/wortle" style="text-decoration: underline;">Create a new game</a>`;
            messageEl.style.marginTop = '50px';
        }

    } else {
        // This is the normal setup/host page logic
        loader.style.display = 'none';
        headerSetup.style.display = "flex";
        setupDiv.style.display = "block";
    
        const savedUsername = localStorage.getItem("gerNordleUsername");
        if (savedUsername) {
            listenForUserDeletion(savedUsername);
        }
        
        setupUsernameInterface({
            isGamePage: false,
            containerId: 'setup-username-area',
            inputId: 'usernameInputHost',
            placeholder: 'Enter username'
        });

        loadSetupState();
        validateSecretWord();
        
        const setupInputs = [
            document.getElementById('secretInput'),
            document.getElementById('hintInput'),
            document.getElementById('hintInput2'),
            document.getElementById('hintInput3'),
            document.getElementById('funFactInput')
        ];
        setupInputs.forEach(input => input.addEventListener('input', saveSetupState));
        // --- THIS LINE IS NOW CORRECTED ---
        document.querySelectorAll('.specialCharCheckbox').forEach(cb => cb.addEventListener('change', saveSetupState));
    }

    loader.style.display = 'none';
    mainContent.classList.add('loaded');

    const secretInput = document.getElementById('secretInput');
if (secretInput) {
    secretInput.addEventListener('input', () => {
        // --- START: Real-time uppercase conversion ---
        const selectionStart = secretInput.selectionStart;
        const selectionEnd = secretInput.selectionEnd;
        // Use the German-friendly function to correctly uppercase the input value
        secretInput.value = germanFriendlyUpperCase(secretInput.value);
        // Restore the cursor position
        secretInput.setSelectionRange(selectionStart, selectionEnd);
        // --- END: Real-time uppercase conversion ---
            clearTimeout(debounceTimer);
            const indicator = document.getElementById('word-status-indicator');
            indicator.innerHTML = ''; 
            indicator.className = 'loading'; 
            debounceTimer = setTimeout(() => {
                validateSecretWord();
            }, 500); 
        });
    }
};
function renderPlayedGames(snapshot) {
    playedGamesList.innerHTML = '';
    const titleElement = document.getElementById('played-games-title');

    if (!snapshot.exists()) {
        if (titleElement) titleElement.textContent = 'Played Games (0)';
        playedGamesList.innerHTML = '<p style="padding: 10px;">You have not played any games.</p>';
        if (resolvePlayedGames) {
            resolvePlayedGames();
            resolvePlayedGames = null;
        }
        return;
    }

    const gamesObject = snapshot.val();
    const games = [];
    for (const word in gamesObject) {
        games.push({ word: word, ...gamesObject[word] });
    }

    if (titleElement) titleElement.textContent = `Played Games (${games.length})`;

    if (games.length === 0) {
        playedGamesList.innerHTML = '<p style="padding: 10px;">You have not played any games.</p>';
        if (resolvePlayedGames) {
            resolvePlayedGames();
            resolvePlayedGames = null;
        }
        return;
    }
    
    const currentUsername = localStorage.getItem("gerNordleUsername");

    games.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));
    const metaPromises = games.map(game => database.ref(`games/${game.word}/metadata`).once('value'));

    Promise.all(metaPromises).then(metaSnapshots => {
        const fragment = document.createDocumentFragment();
        metaSnapshots.forEach((metaSnap, idx) => {
            if (metaSnap.exists()) {
                const meta = metaSnap.val();
                const gameData = games[idx];
                const gameLink = document.createElement('a');
                gameLink.href = generateShareURL(meta.word, meta.hint1, meta.hint2, meta.hint3, meta.hint4, meta.funFact);
                
                const wordSpan = document.createElement('span');
                let wordText = (gameData.status === 'won' || gameData.status === 'lost') ? meta.word : '?????';

                if (meta.host && meta.host === currentUsername) {
                    wordText += ` <span style="color: #951414; font-weight: bold;">H</span>`;
                }
                wordSpan.innerHTML = wordText;

                const statusSpan = document.createElement('span');
                statusSpan.className = 'game-status';
                if (gameData.status === 'won') statusSpan.textContent = `Won (${gameData.guesses}/${rows})`;
                else if (gameData.status === 'lost') statusSpan.textContent = 'Lost';
                else statusSpan.textContent = 'In progress';
                
                gameLink.appendChild(wordSpan);
                gameLink.appendChild(statusSpan);
                fragment.appendChild(gameLink);
            }
        });
        playedGamesList.appendChild(fragment);

        if (resolvePlayedGames) {
            resolvePlayedGames();
            resolvePlayedGames = null;
        }
    });
}
async function saveOngoingGame(username, encodedSecret) {
    if (!username || !encodedSecret) return;
    
    const word = base64Decode(encodedSecret);
    if (!word) return;

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const playedGameRef = database.ref(`userProfiles/${sanitizedUsername}/playedGames/${word}`);

    // First, check for an existing record to preserve the original createdDate
    const snapshot = await playedGameRef.once('value');
    const existingData = snapshot.val();
    const createdDate = existingData?.createdDate || new Date().toISOString();

    // Package the entire current game state
    const ongoingStateForFirebase = {
        status: 'ongoing',
        createdDate: createdDate,
        lastPlayedDate: new Date().toISOString(), // Useful for sorting later
        grid: grid,
        currentRow: currentRow,
        guessHistory: guessHistory,
        colorHistory: colorHistory,
        keyColors: keyColors,
        isHardMode: isHardMode,
        hardModeWasDisabled: hardModeWasDisabled,
        hintStatus: { hintUsed1, hintUsed2, hintUsed3, hintUsed4, hintExpanded1, hintExpanded2, hintExpanded3, hintExpanded4 }
    };

    // Use .set() to save the complete ongoing state to Firebase
    await playedGameRef.set(ongoingStateForFirebase);

    // The logic to add a player to the central /games list on their first guess remains
    const isFirstGuess = guessHistory.length === 1;
    if (isFirstGuess) {
        const centralPlayerListRef = database.ref(`games/${word}/players/${sanitizedUsername}`);
        await centralPlayerListRef.set(true);
    }
    
    // We still save to local storage for quick refreshes on the same device
    const allGameData = JSON.parse(localStorage.getItem("gerNordleGameData") || "{}");
    if (!allGameData[username]) allGameData[username] = {};
    allGameData[username][encodedSecret] = {
        ongoingState: ongoingStateForFirebase, // Save the same object
        createdDate: createdDate
    };
    localStorage.setItem("gerNordleGameData", JSON.stringify(allGameData));
}

const helpBtn = document.getElementById("helpBtn");
const helpPopup = document.getElementById("helpPopup");
const closeHelpBtn = document.getElementById("closeHelpBtn");
const helpOverlay = document.getElementById("helpOverlay");
const mainContent = document.getElementById("mainContent");
// Add this to your script
const giveUpBtn = document.getElementById('giveUpBtn');
if (giveUpBtn) {
    giveUpBtn.addEventListener('click', handleGiveUp);
}

function showHelpPopup() {
  isModalOpen = true;
  helpPopup.hidden = false;
  helpOverlay.classList.add('show');
  mainContent.inert = true;
  mainContent.setAttribute('aria-hidden', 'true');
  setInputsDisabled(true);
  helpPopup.focus();
}

function hideHelpPopup() {
  isModalOpen = false;
  helpPopup.hidden = true;
  helpOverlay.classList.remove('show');
  mainContent.inert = false;
  mainContent.removeAttribute('aria-hidden');
  setInputsDisabled(false);
}

// Find the new button in the document
const newGameBtn = document.getElementById("newGameBtn");

// This function navigates to the base URL of your site
function goToHostPage() {
  // window.location.origin provides the base URL (e.g., "https://your-site.com")
  window.location.href = window.location.origin + window.location.pathname;
}

// Attach the function to the button's click event
if (newGameBtn) {
  newGameBtn.addEventListener("click", goToHostPage);
}

helpBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  if (helpPopup.hidden) {
    showHelpPopup();
  } else {
    hideHelpPopup();
  }
});

closeHelpBtn.addEventListener("click", () => {
  hideHelpPopup();
});

helpOverlay.addEventListener("click", () => {
  hideHelpPopup();
});

// Global keydown: block all keys except Ctrl/Meta shortcuts and Escape when popup is visible
document.addEventListener("keydown", (event) => {
  if (!helpPopup.hidden) {
    // Allow Escape to close popup
    if (event.key === "Escape") {
      return;
    }

    // For Cmd/Ctrl + key combos like Cmd+C:
    if (event.ctrlKey || event.metaKey) {
      // Stop propagation to prevent Wordle input, but allow native shortcut
      event.stopImmediatePropagation();
      // Don't preventDefault here so native shortcut works
      return;
    }

    // Block all other keys completely (typing)
    event.preventDefault();
    event.stopImmediatePropagation();
  }
}, true);

// Also block typing on Wordle input elements specifically except shortcuts and Escape
const wordleInputs = mainContent.querySelectorAll('input, textarea, [contenteditable="true"]');
wordleInputs.forEach(input => {
  input.addEventListener('keydown', (event) => {
    if (!helpPopup.hidden) {
      if (event.ctrlKey || event.metaKey || event.key === "Escape") {
        return; // allow shortcuts and Escape
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    }
  }, true);
});

// Optional: allow Escape to close popup (already handled above, but keep if needed)
document.addEventListener("keydown", (event) => {
  if (!helpPopup.hidden && event.key === "Escape") {
    hideHelpPopup();
  }
});

// Prevent clicks inside popup from closing it
helpPopup.addEventListener("click", (event) => {
  event.stopPropagation();
});

function setInputsDisabled(state) {
    const inputs = mainContent.querySelectorAll('input, textarea, [contenteditable="true"], button, select');
    inputs.forEach(el => {
        if (state === true) {
            // When disabling, disable everything.
            el.disabled = true;
            el.setAttribute('aria-disabled', 'true');
            el.blur();
        } else {
            // When re-enabling, ONLY enable elements that are NOT auto-populated.
            if (!el.classList.contains('is-auto-populated')) {
                el.disabled = false;
                el.removeAttribute('aria-disabled');
            }
        }
    });
}

function updateHintButtons() {
    const hintButtons = [
        document.getElementById("hintBtn1"),
        document.getElementById("hintBtn2"),
        document.getElementById("hintBtn3"),
        document.getElementById("hintBtn4")
    ];
    const hintUnlockMessage = document.getElementById('hint-unlock-message');
    const hintUnlockNextMessage = document.getElementById('hint-unlock-next-message'); // Get the new message element
    const hintButtonsContainer = document.getElementById('hintButtonsContainer');

    const hints = [customHint1, customHint2, customHint3, customHint4];
    const hintUsedFlags = [hintUsed1, hintUsed2, hintUsed3, hintUsed4];
    const hintExpandedFlags = [hintExpanded1, hintExpanded2, hintExpanded3, hintExpanded4];

    const guessCount = guessHistory.length;
    let hasAnyAvailableHints = hints.some(hint => hint && hint.trim() !== "");
    
    document.getElementById("hintButtons").style.display = hasAnyAvailableHints ? "block" : "none";

    if (guessCount < 2) {
        hintUnlockMessage.textContent = "Enter at least 2 guesses to start unlocking hints.";
        hintUnlockMessage.style.display = 'block';
        hintButtonsContainer.style.display = 'none';
        hintUnlockNextMessage.style.display = 'none'; // Ensure next-hint message is hidden
        return;
    }

    hintUnlockMessage.style.display = 'none';
    hintButtonsContainer.style.display = 'flex';

    const unlockThresholds = [2, 3, 4, 5];

    for (let i = 0; i < 4; i++) {
        const btn = hintButtons[i];
        const hintContent = hints[i];
        const isUnlocked = guessCount >= unlockThresholds[i];
        
        if (!hintContent || hintContent.trim() === "") {
            btn.style.display = "none";
            continue;
        }

        btn.style.display = isUnlocked ? "inline-flex" : "none";

        if (isUnlocked) {
            const used = hintUsedFlags[i];
            const expanded = hintExpandedFlags[i];

            if (used) {
                btn.classList.add('clicked-hint');
                btn.disabled = true;

                if (expanded) {
                    const hintTextSpan = btn.querySelector('.hint-text');
                    if (hintTextSpan) {
                        hintTextSpan.textContent = hintContent;
                        hintTextSpan.classList.add('visible');
                    }
                    btn.classList.add('expanded');
                    btn.querySelector('.hint-label').classList.add('hidden');
                }
            } else {
                btn.disabled = false;
                btn.classList.remove('clicked-hint', 'expanded');
                const hintTextSpan = btn.querySelector('.hint-text');
                if (hintTextSpan) {
                    hintTextSpan.classList.remove('visible');
                    hintTextSpan.textContent = "";
                }
                btn.querySelector('.hint-label').classList.remove('hidden');
            }
        }
    }

    // --- START: NEW LOGIC FOR "UNLOCK NEXT" MESSAGE ---
    hintUnlockNextMessage.style.display = 'none'; // Hide by default

    // Determine if the *next* potential hint exists
    let nextHintExists = false;
    if (guessCount === 2 && hints[1] && hints[1].trim() !== "") nextHintExists = true;
    if (guessCount === 3 && hints[2] && hints[2].trim() !== "") nextHintExists = true;
    if (guessCount === 4 && hints[3] && hints[3].trim() !== "") nextHintExists = true;

    // Show the message if appropriate
    if (guessCount >= 2 && guessCount < 5 && nextHintExists) {
        hintUnlockNextMessage.textContent = "Enter one more guess to unlock another hint.";
        hintUnlockNextMessage.style.display = 'block';
    }
    // --- END: NEW LOGIC FOR "UNLOCK NEXT" MESSAGE ---
}

function bindModalButtons(savedGuessHistory, savedColorHistory, isSolved, savedHintStatus) {
    const modalCopyBtn = document.getElementById("modalCopyBtn");
    const showStatsBtn = document.getElementById("showStatsBtn");
    const showScoreboardBtn = document.getElementById("showScoreboardBtn");
    const closeModalBtn = document.getElementById("closeModalBtn"); // --- Find the new button

    // --- ADD THIS BLOCK ---
    if (closeModalBtn) {
        closeModalBtn.onclick = closeGameOverModal;
    }

    // --- 1. Copy Result Button ---
    if (modalCopyBtn) {
        modalCopyBtn.onclick = () => {
            const resultText = generateResultText(false, savedGuessHistory, savedColorHistory, isSolved, savedHintStatus);
            navigator.clipboard.writeText(resultText).then(() => {
                modalCopyBtn.innerHTML = "<i>Copied!</i>";
                modalCopyBtn.disabled = true;
                setTimeout(() => {
                    modalCopyBtn.innerHTML = "Copy Result";
                    modalCopyBtn.disabled = false;
                }, 1500);
            });
        };
    }

    // --- 2. Stats Toggle Button ---
    if (showStatsBtn) {
        showStatsBtn.onclick = () => {
            const statsContainer = document.getElementById("modal-stats-container");
            statsContainer.classList.toggle('expanded');
            showStatsBtn.textContent = statsContainer.classList.contains('expanded') ? "Hide My Stats" : "Show My Stats";
        };
    }

    // --- 3. View/Hide Scoreboard Button (MODIFIED) ---
    if (showScoreboardBtn) {
        // Set initial text
        showScoreboardBtn.textContent = "View Scoreboard";
        
        showScoreboardBtn.onclick = () => {
            const scoreboardPanel = document.getElementById('scoreboard-panel');
            // Check if the panel is already visible
            if (scoreboardPanel.classList.contains('show')) {
                hideScoreboard(); // If yes, hide it
            } else {
                showScoreboard(); // If no, show it
            }
        };
    }
}

function showHintPopup() {
  hintPopup.classList.add("show");
  document.addEventListener("keydown", handleTypingToClose);
}

function hideHintPopup() {
  hintPopup.classList.remove("show");
  document.removeEventListener("keydown", handleTypingToClose);
}
// Event listeners for the hint popup
if (hintTitle) {
  hintTitle.addEventListener("click", showHintPopup);
}
if (closeHintPopupBtn) {
  closeHintPopupBtn.addEventListener("click", hideHintPopup);
}

// This handles the "click outside" functionality
if (hintPopupOverlay) {
  hintPopupOverlay.addEventListener("click", hideHintPopup);
}

// This prevents clicks *inside* the popup from closing it
if (hintPopup) {
  hintPopup.addEventListener("click", (event) => {
    event.stopPropagation();
  });
}
// --- Add this new function to your script ---

async function generateRandomWord() {
    const generateBtn = document.getElementById("generateWordBtn");
    const secretInput = document.getElementById("secretInput");
    const indicator = document.getElementById("word-status-indicator");

    // CHANGED: Check the new wordLists Map instead of the old Set.
    if (wordLists.size === 0) {
        showToast("Word lists are still loading. Please wait a moment and try again.", "error");
        return;
    }

    // Set the UI to a "loading" state
    if (generateBtn) generateBtn.disabled = true;
    secretInput.value = '';
    indicator.innerHTML = '';
    indicator.className = 'loading';

    // CHANGED: Create a flat array of all words from all languages in the Map.
    const allWordsArray = [...wordLists.values()].flatMap(wordSet => [...wordSet]);
    let foundWord = null;
    let attempts = 0;
    const maxAttempts = 50; // Safety limit to prevent an infinite loop
    let hadError = false;

    while (!foundWord && attempts < maxAttempts) {
        attempts++;
        const randomIndex = Math.floor(Math.random() * allWordsArray.length);
        const randomWord = allWordsArray[randomIndex].toUpperCase();

        try {
            const gameRef = database.ref('games/' + randomWord);
            const snapshot = await gameRef.once('value');
            if (!snapshot.exists()) {
                foundWord = randomWord; // We found an available word!
            }
        } catch (error) {
            console.error("Database error while finding a random word:", error);
            hadError = true;
            break; // Exit the loop on a database error
        }
    }

    // --- Final UI update after the search is complete ---

    // Always remove the loading spinner
    indicator.className = '';
    indicator.innerHTML = '';

    if (foundWord) {
        secretInput.value = foundWord;
        // ADDED: Call validateSecretWord() to trigger the check mark AND auto-populate hints.
        validateSecretWord();
    } else {
        // If we failed, show an error icon briefly
        console.warn("Could not find an available random word after several attempts.");
        if (hadError) {
            indicator.innerHTML = 'âš ï¸';
            indicator.className = 'invalid';
            // Clear the error icon after a few seconds
            setTimeout(() => { indicator.innerHTML = ''; indicator.className = ''; }, 2500);
        }
    }

    // Always re-enable the button
    if (generateBtn) generateBtn.disabled = false;
}

// --- Add this event listener to make the button work ---

// Find the new button in the document
const generateBtn = document.getElementById("generateWordBtn");

// Attach the function to the button's click event
if (generateBtn) {
  generateBtn.addEventListener("click", generateRandomWord);
}

// --- Find the new scoreboard elements ---
const scoreboardPanel = document.getElementById('scoreboard-panel');

function showScoreboard() {
  const showScoreboardBtn = document.getElementById('showScoreboardBtn');
  // First, fetch the data and populate the panel
  fetchAndDisplayScoreboard();
  // Then, slide the panel into view
  scoreboardPanel.classList.add('show');
  // Update button text
  if (showScoreboardBtn) {
    showScoreboardBtn.textContent = 'Hide Scoreboard';
  }
}

// This function now hides the side panel
function hideScoreboard() {
  const showScoreboardBtn = document.getElementById('showScoreboardBtn');
  scoreboardPanel.classList.remove('show');
  
  // Reset the button text
  if (showScoreboardBtn) {
    showScoreboardBtn.textContent = 'View Scoreboard';
  }
  
  // Clean up the real-time listener to prevent memory leaks
  if (scoreboardListener && secret) {
      const gameRef = database.ref('games/' + secret);
      gameRef.off('value', scoreboardListener);
      scoreboardListener = null; // Clear the variable
  }
}

function fetchAndDisplayScoreboard() {
    if (!secret) return;

    const container = document.getElementById('scoreboard-container');
    const wordDisplay = document.getElementById('scoreboard-word');
    const summaryContainer = document.getElementById('scoreboard-summary-container');
    
    if (!container || !wordDisplay || !summaryContainer) {
        console.error("Scoreboard HTML elements not found! Check your element IDs.");
        return; 
    }

    const gameRef = database.ref('games/' + secret);

    wordDisplay.textContent = secret;
    container.innerHTML = '<p>Loading scores...</p>';
    summaryContainer.innerHTML = '';

    if (scoreboardListener) {
        gameRef.off('value', scoreboardListener);
    }
    
    scoreboardListener = gameRef.on('value', (snapshot) => {
        const scoresData = snapshot.val();

        if (!scoresData) {
            container.innerHTML = '<p>Be the first to set a score!</p>';
            return;
        }

        // âœ… Step 1: Get the host's name from the game's metadata.
        const hostName = scoresData.metadata ? scoresData.metadata.host : null;

        const playerScores = Object.keys(scoresData)
            .filter(key => key !== 'metadata' && key !== 'players') 
            .map(key => scoresData[key]);

        if (playerScores.length === 0) {
            container.innerHTML = '<p>Be the first to set a score!</p>';
            summaryContainer.innerHTML = ''; 
            return;
        }
        
        const totalPlayers = playerScores.length;
        const winners = playerScores.filter(score => score.guesses > 0);
        const totalWinners = winners.length;
        const solveRate = totalPlayers > 0 ? (totalWinners / totalPlayers) * 100 : 0;
        const totalGuesses = winners.reduce((sum, player) => sum + player.guesses, 0);
        const avgGuesses = totalWinners > 0 ? totalGuesses / totalWinners : 0;

        summaryContainer.innerHTML = `
            <div class="summary-stat">
                <span class="stat-label">Solve Rate</span>
                <div class="stat-bar-container">
                    <div class="stat-bar" style="width: ${solveRate.toFixed(1)}%;">${solveRate.toFixed(1)}%</div>
                </div>
            </div>
            <div class="summary-stat">
                <span class="stat-label">Avg. Guesses</span>
                <div class="stat-bar-container">
                    <div class="stat-bar" style="width: ${(avgGuesses / rows) * 100}%;">${avgGuesses.toFixed(1)}</div>
                </div>
            </div>
        `;

        winners.sort((a, b) => {
            const guessDifference = a.guesses - b.guesses;
            if (guessDifference !== 0) return guessDifference;
            return (a.hintCount || 0) - (b.hintCount || 0);
        });

        const losers = playerScores.filter(score => score.guesses <= 0);
        const sortedScores = [...winners, ...losers];

        let tableHTML = `
            <table>
                <thead><tr><th>Rank</th><th>Player</th><th>Guesses</th><th>Hints</th></tr></thead>
                <tbody>`;

        sortedScores.forEach((score, index) => {
            const guessDisplay = score.guesses > 0 ? score.guesses : 'X';

            // âœ… Step 2: Check if the current player is the host and prepare the display name.
            let nameDisplay = score.username;
            if (hostName && score.username === hostName) {
                nameDisplay += ` <span style="color: #951414; font-weight: bold;">H</span>`;
            }

            // âœ… Step 3: Use the new display name in the table row.
            tableHTML += `
                <tr>
                    <td>${index + 1}</td>
                    <td>${nameDisplay}</td>
                    <td>${guessDisplay}</td>
                    <td>${score.hintCount || 0}</td>
                </tr>`;
        });

        tableHTML += '</tbody></table>';
        container.innerHTML = tableHTML;

    }, (error) => {
        console.error("Firebase listener error:", error);
        container.innerHTML = '<p>Could not load scores due to an error.</p>';
        summaryContainer.innerHTML = '<p style="text-align:center;">Could not load stats.</p>';
    });
}

function closeGameOverModal() {
    isModalOpen = false;
    // Check the URL to see if we are in the special scoreboard view
    const params = new URLSearchParams(window.location.search);
    const isScoreboardView = params.get('view') === 'scoreboard';

    if (isScoreboardView) {
        // If we are in scoreboard view, navigate back to the main page.
        history.back();
    } else {
        // Otherwise, just hide the modal as usual.
        const overlay = document.getElementById('game-over-overlay');
        if (overlay) {
            overlay.classList.remove('show');
        }
        hideScoreboard();
    }
}

function generateGuessHistoryHTML(guessHistory, colorHistory) {
  let historyHtml = '';
  
  // Loop through each guess
  for (let i = 0; i < guessHistory.length; i++) {
    const guess = guessHistory[i];
    const colors = colorHistory[i];
    historyHtml += '<div class="row">';
    // Loop through each letter in the guess
    for (let j = 0; j < guess.length; j++) {
      const letter = guess[j];
      const colorClass = colors[j]; // 'correct', 'present', or 'absent'
      // Create a tile with the original classes for styling
      historyHtml += `<div class="tile ${colorClass}">${letter}</div>`;
    }
    historyHtml += '</div>';
  }
  return historyHtml;
}

async function loginUser(inputId, pinInputId, config) {
    const usernameInput = document.getElementById(inputId);
    const pinInput = document.getElementById(pinInputId);
    const username = usernameInput.value.trim().toUpperCase();
    const pin = pinInput.value.trim();

    if (!username || !pin) {
        showToast("Please enter both a username and a PIN.", "error");
        return;
    }
    if (username.length > 10) {
        showToast("Username cannot be more than 10 characters long.", "error");
        return;
    }

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const userRef = database.ref('users/' + sanitizedUsername);

    try {
        const snapshot = await userRef.once('value');
        if (snapshot.exists()) {
            const userData = snapshot.val();
            if (userData.pin === pin) {
                // PIN is correct! Log the user in.
                localStorage.setItem("gerNordleUsername", username);
                localStorage.setItem("gerNordleUserPin", pin); 
                window.location.reload();
                // Refresh the UI
                if (config.isGamePage) {
                    checkUserStatus();
                } else {
                    setupUsernameInterface(config);
                }
            } else {
                showToast("Incorrect PIN. Please try again.", "error");
            }
        } else {
            showToast(`Username "${username}" does not exist. Please register first.`, "error");
        }
    } catch (error) {
        console.error("Login error:", error);
        showToast("Could not log in. Please check your connection.", "error");
    }
}

async function registerUser(inputId, pinInputId, config) {
    const usernameInput = document.getElementById(inputId);
    const pinInput = document.getElementById(pinInputId);
    const username = usernameInput.value.trim().toUpperCase();
    const pin = pinInput.value.trim();

    if (!username || !pin) {
        showToast("Please enter both a username and a PIN.", "error");
        return;
    }
    if (username.length < 3) {
        showToast("Username must be at least 3 characters long.", "error");
        return;
    }
    if (username.length > 10) {
        showToast("Username cannot be more than 10 characters long.", "error");
        return;
    }
    if (pin.length !== 4 || isNaN(pin)) {
        showToast("Your PIN must be 4 digits.", "error");
        return;
    }

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const userRef = database.ref('users/' + sanitizedUsername);

    try {
        const snapshot = await userRef.once('value');
        if (snapshot.exists()) {
            showToast(`The username "${username}" is already taken. Please try logging in or choose another name.`, "error");
        } else {
            // Username is available, register it with the PIN.
            await userRef.set({
                original: username,
                pin: pin, // Store the PIN
                registeredAt: firebase.database.ServerValue.TIMESTAMP
            });

            // Automatically log the user in after registration.
            localStorage.setItem("gerNordleUsername", username);
            localStorage.setItem("gerNordleUserPin", pin);
          showLanguagePopup(username, true); 
        }
    } catch (error) {
        console.error("Registration error:", error);
        showToast("Could not register username. Please try again.", "error");
    }
}

function setupUsernameInterface(config) {
    const { isGamePage, containerId, inputId, placeholder } = config;
    const pinInputId = inputId + '-pin';
    const container = document.getElementById(containerId);
    if (!container) return;

    const savedUsername = localStorage.getItem("gerNordleUsername");
    
    // Clear the specific container we're working with.
    container.innerHTML = ''; 
    // Remove any special layout classes before we start
    container.classList.remove('login-prompt-container');

    if (savedUsername) {
Â  Â  Â  Â  // This block now correctly handles the display for a LOGGED-IN user on BOTH pages.
Â  Â  Â  Â  const displayMessage = document.createElement("p");
Â  Â  Â  Â  displayMessage.textContent = `Logged in as: ${savedUsername.toUpperCase()}`;

Â  Â  Â  Â  const changeButton = document.createElement("button");
Â  Â  Â  Â  changeButton.textContent = "Change User";
Â  Â  Â  Â  changeButton.onclick = () => {
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('game').classList.add('dimmed');
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('setup-form-content').classList.add('dimmed');
Â  Â  Â  Â  Â  Â  Â  Â  stopUserDeletionListener();
Â  Â  Â  Â  Â  Â  Â  Â  localStorage.removeItem("gerNordleUsername");
Â  Â  Â  Â  Â  Â  Â  Â  localStorage.removeItem("gerNordleUserPin");
Â  Â  Â  Â  Â  Â  Â  Â  setupUsernameInterface(config);
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  changeButton.classList.add("styled-button");

Â  Â  Â  Â  container.appendChild(displayMessage);
Â  Â  Â  Â  container.appendChild(changeButton);

Â  Â  Â  Â  // Only interact with the setup form if we are on the setup page.
Â  Â  Â  Â  if (!isGamePage) {
Â  Â  Â  Â  Â  Â  document.getElementById('setup-form-content').classList.remove('dimmed');
Â  Â  Â  Â  }
    } else {
        // This block handles the display for a LOGGED-OUT user.
        if (!isGamePage) {
            document.getElementById('setup-form-content').classList.add('dimmed');
        }

        // âœ¨ APPLY THE NEW CLASS to the container
        container.classList.add('login-prompt-container');
        
        const usernameInput = document.createElement("input");
        usernameInput.type = "text";
        usernameInput.id = inputId;
        usernameInput.placeholder = placeholder;
        usernameInput.maxLength = 10; 
        usernameInput.style.cssText = "padding: 3px 6px; border-radius: 6px; margin: 0px; width: 140px;";

        const pinInput = document.createElement("input");
        pinInput.type = "password";
        pinInput.id = pinInputId;
        pinInput.placeholder = "4-digit PIN";
        pinInput.maxLength = 4;
        pinInput.style.cssText = "padding: 3px 6px; border-radius: 6px; margin: 0px; width: 100px;";

        const loginButton = document.createElement("button");
        loginButton.textContent = "Login";
        loginButton.classList.add("styled-button");
        loginButton.onclick = () => loginUser(inputId, pinInputId, config);

        const registerButton = document.createElement("button");
        registerButton.textContent = "Register";
        registerButton.classList.add("styled-button");
        registerButton.onclick = () => registerUser(inputId, pinInputId, config);

        const handleEnterKey = (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                loginButton.click(); 
            }
        };
        usernameInput.addEventListener('keydown', handleEnterKey);
        pinInput.addEventListener('keydown', handleEnterKey);
        
        // Append the new login elements to the container.
        container.appendChild(usernameInput);
        container.appendChild(pinInput);
        container.appendChild(loginButton);
        container.appendChild(registerButton);
        
        window.currentUsername = null;
        usernameSet = false;
    }
}

// This helper function displays the game-over modal with the correct information.
async function showGameOverModal(isSolved, guessHistory, colorHistory, hintStatus, funFactText) {
const overlay = document.getElementById("game-over-overlay");
    
    // Set win/loss message
    if (isSolved) {
        document.getElementById("modal-message").innerHTML = `You win! ğŸ‰<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
    } else {
        document.getElementById("modal-message").innerHTML = `Game over!<br>The secret word was <span id="secretWordColor">${secret}</span>.`;
    }

    // Generate and display the shareable summary
    document.getElementById("modal-summary").textContent = generateResultText(true, guessHistory, colorHistory, isSolved, hintStatus);

    // --- UPDATED LOGIC ---
    // First, always remove any fun fact from a previous game.
    const existingFunFact = document.querySelector("#game-over-modal .fun-fact-section");
    if (existingFunFact) existingFunFact.remove();

    // Now, display the new fun fact ONLY if one was provided for THIS game.
    if (funFactText && funFactText.trim() !== "") {
        const funFactDiv = document.createElement('div');
        funFactDiv.classList.add('fun-fact-section');
        funFactDiv.innerHTML = `<h2>Fun fact about today's WÃ¸rtle:</h2><p style="margin:0;">${funFactText}</p>`;
        document.querySelector("#game-over-modal .modal-content").appendChild(funFactDiv);
    }

    // ... (The rest of the function for displaying stats and binding buttons remains the same)
    const statsContainer = document.getElementById("modal-stats-container");
    statsContainer.innerHTML = "";
    const username = localStorage.getItem("gerNordleUsername");
    const stats = await displayStats(username);
    const statsLines = [
        `Stats for ${username}`,
        `Games Played: ${stats.gamesPlayed}`,
        `Wins: ${stats.wins}`,
        `Win %: ${stats.winPct}%`,
        `Average Guesses: ${stats.avgGuesses}`
    ];

    statsLines.forEach(line => {
        const p = document.createElement("p");
        p.textContent = line;
        p.classList.add("stats-line");
        statsContainer.appendChild(p);
    });

    bindModalButtons(guessHistory, colorHistory, isSolved, hintStatus);
    overlay.classList.add('show');
}
// --- Account Sidebar Logic ---
const accountBtn = document.getElementById('accountBtn');
const accountSidebar = document.getElementById('account-sidebar');
const accountOverlay = document.getElementById('account-overlay');
const closeAccountBtn = document.getElementById('closeAccountBtn');
const hostedGamesList = document.getElementById('hosted-games-list');
const playedGamesList = document.getElementById('played-games-list');
let resolveHostedGames = null;
let resolvePlayedGames = null;

// Define references in a higher scope to manage them across open/close actions
let hostedGamesRef = null;
let playedGamesRef = null;

function renderHostedGames(snapshot) {
    hostedGamesList.innerHTML = '';
    const titleElement = document.getElementById('hosted-games-title');

    if (!snapshot.exists()) {
        if (titleElement) titleElement.textContent = 'Hosted Games (0)';
        hostedGamesList.innerHTML = '<p style="padding: 10px;">You have not created any games.</p>';
        if (resolveHostedGames) {
            resolveHostedGames();
            resolveHostedGames = null;
        }
        return;
    }

    const gamesObject = snapshot.val();
    const games = [];
    for (const word in gamesObject) {
        games.push({ word: word, ...gamesObject[word] });
    }
    
    if (titleElement) titleElement.textContent = `Hosted Games (${games.length})`;

    games.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));
    const metaPromises = games.map(game => database.ref(`games/${game.word}/metadata`).once('value'));

    Promise.all(metaPromises).then(metaSnapshots => {
        const fragment = document.createDocumentFragment();
        metaSnapshots.forEach((metaSnap, idx) => {
            if (metaSnap.exists()) {
                const meta = metaSnap.val();
                const listItem = document.createElement('div');
                listItem.className = 'game-list-item';
                const gameLink = document.createElement('a');
                const fullUrl = generateShareURL(meta.word, meta.hint1, meta.hint2, meta.hint3, meta.hint4, meta.funFact);
                gameLink.href = fullUrl;
                gameLink.textContent = meta.word;
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'game-item-actions';
                
                const scoreboardBtn = document.createElement('button');
                scoreboardBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line></svg>`;
                scoreboardBtn.title = 'View Scoreboard';
                scoreboardBtn.onclick = (event) => {
                    event.stopPropagation(); 
                    showGameScoreboard(meta.word);
                };

                const copyBtn = document.createElement('button');
                const linkIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>`;
                const checkIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
                
                copyBtn.innerHTML = linkIconSVG;
                copyBtn.title = 'Copy Link';
                
                // --- START: CORRECTED on-click LOGIC ---
                copyBtn.onclick = (event) => {
                    event.stopPropagation();
                    const urlToCopy = meta.shortUrl || fullUrl;
                    // The .then() block runs after the copy is successful
                    navigator.clipboard.writeText(urlToCopy).then(() => {
                        copyBtn.innerHTML = checkIconSVG; // Show checkmark
                        setTimeout(() => {
                            copyBtn.innerHTML = linkIconSVG; // Revert to link icon
                        }, 2000);
                    });
                };
                // --- END: CORRECTED on-click LOGIC ---

                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
                deleteBtn.title = 'Delete Game';
                deleteBtn.onclick = (event) => {
                    event.stopPropagation();
                    deleteGame(meta.word);
                };
                
                actionsDiv.appendChild(scoreboardBtn);
                actionsDiv.appendChild(copyBtn);
                actionsDiv.appendChild(deleteBtn);
                
                listItem.appendChild(gameLink);
                listItem.appendChild(actionsDiv);
                fragment.appendChild(listItem);
            }
        });
        hostedGamesList.appendChild(fragment);

        if (resolveHostedGames) {
            resolveHostedGames();
            resolveHostedGames = null;
        }
    });
}

// Replace your existing closeAccountSidebar function
function closeAccountSidebar() {
    isModalOpen = false;
    accountSidebar.classList.remove('show');
    accountOverlay.classList.remove('show');
    mainContent.inert = false;

    // Detach all real-time Firebase listeners
    if (hostedGamesRef) {
        hostedGamesRef.off('value', renderHostedGames);
    }
    if (playedGamesRef) {
        playedGamesRef.off('value', renderPlayedGames);
    }
    if (statsRef && statsListener) {
        statsRef.off('value', statsListener);
    }
    if (badgesRef && badgesListener) {
        badgesRef.off('value', badgesListener);
    }
    if (langRef && langListener) { // ADD THIS BLOCK
        langRef.off('value', langListener);
    }
}

let statsRef = null;
let statsListener = null;

// This is the improved openAccountSidebar function
// REPLACE your existing openAccountSidebar function with this one

async function openAccountSidebar() {
    isModalOpen = true;
    const username = localStorage.getItem("gerNordleUsername");
    if (!username) {
        showToast("Please log in to view your account.", "error");
        return;
    }

    const usernameText = document.getElementById('account-username-text');
    const sidebarFlag = document.getElementById('account-sidebar-flag');
    const sidebarLoader = document.getElementById('sidebar-loader');
    const sidebarContent = document.getElementById('sidebar-content');

    accountSidebar.classList.add('show');
    accountOverlay.classList.add('show');
    mainContent.inert = true;
    sidebarLoader.style.display = 'block';
    sidebarContent.classList.remove('loaded');

    if (usernameText) usernameText.textContent = username.toUpperCase();

    try {
        const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');

        // --- START: MODIFIED FLAG/EMOJI LOGIC ---
        // This now listens for language changes in real-time
        langRef = database.ref(`userProfiles/${sanitizedUsername}/nativeLanguage`);
        langListener = langRef.on('value', (langSnapshot) => {
            const nativeLanguage = langSnapshot.val();

            if (nativeLanguage) {
                // If language exists, show the flag
                const countryCode = languageToCountryCode[nativeLanguage.toLowerCase()];
                if (countryCode && sidebarFlag) {
                    sidebarFlag.textContent = getFlagEmoji(countryCode);
                    sidebarFlag.onclick = null; // Make it not clickable
                    sidebarFlag.style.cursor = 'default';
                    sidebarFlag.title = '';
                }
            } else {
                // If language does NOT exist, show a clickable emoji
                if (sidebarFlag) {
                    sidebarFlag.textContent = 'âœï¸';
                    sidebarFlag.style.cursor = 'pointer';
                    sidebarFlag.title = 'Set your native language';
                    sidebarFlag.onclick = () => {
                        showLanguagePopup(username); // Opens the popup
                    };
                }
            }
        });
        
        // (The rest of the function remains the same)
        const badgesRef = database.ref(`userProfiles/${sanitizedUsername}/badges`);
        badgesRef.on('value', (badgesSnapshot) => {
            const badgesContainer = document.getElementById('account-badges-container');
            badgesContainer.innerHTML = '';
            if (badgesSnapshot.exists()) {
                const earnedBadges = badgesSnapshot.val();
                for (const badgeId in earnedBadges) {
                    if (earnedBadges[badgeId] === true && BADGE_DEFINITIONS[badgeId]) {
                        const badgeInfo = BADGE_DEFINITIONS[badgeId];
                        const badgeElement = document.createElement('div');
                        badgeElement.className = 'badge';
                        badgeElement.textContent = badgeInfo.name;
                        badgeElement.title = badgeInfo.description;
                        badgesContainer.appendChild(badgeElement);
                    }
                }
            }
        });

        const hostedGamesLoaded = new Promise(resolve => { resolveHostedGames = resolve; });
        const playedGamesLoaded = new Promise(resolve => { resolvePlayedGames = resolve; });

        hostedGamesRef = database.ref(`userProfiles/${sanitizedUsername}/hostedGames`);
        hostedGamesRef.on('value', renderHostedGames);

        playedGamesRef = database.ref(`userProfiles/${sanitizedUsername}/playedGames`);
        playedGamesRef.on('value', renderPlayedGames);
        
        statsRef = database.ref(`userProfiles/${sanitizedUsername}/stats`);
        statsListener = statsRef.on('value', renderAccountStats);
        
        await Promise.all([hostedGamesLoaded, playedGamesLoaded]);

        sidebarLoader.style.display = 'none';
        sidebarContent.classList.add('loaded');

    } catch (error) {
        sidebarLoader.style.display = 'none';
        sidebarContent.classList.add('loaded');
        console.error("Error loading account sidebar:", error);
    }
}
accountBtn.addEventListener('click', openAccountSidebar);
closeAccountBtn.addEventListener('click', closeAccountSidebar);
accountOverlay.addEventListener('click', closeAccountSidebar);

// This function starts listening for changes to the current user's record
function listenForUserDeletion(username) {
    stopUserDeletionListener(); // Stop any previous listeners first

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const userRef = database.ref('users/' + sanitizedUsername);

    const listener = userRef.on('value', (snapshot) => {
        // If snapshot.exists() is false, the user was deleted from the database
        if (!snapshot.exists()) {
            console.log("Current user was deleted from the database. Logging out.");
            
            // Stop the listener before we reload
            stopUserDeletionListener();

            // Clear local session and refresh the page
            localStorage.removeItem("gerNordleUsername");
            localStorage.removeItem("gerNordleUserPin");
            window.location.reload();
        }
    });

    // Store the reference and the listener so we can detach it later
    userListener = { ref: userRef, listener: listener };
}

// This function stops the listener to prevent memory leaks
function stopUserDeletionListener() {
    if (userListener.ref && userListener.listener) {
        userListener.ref.off('value', userListener.listener);
        userListener = { ref: null, listener: null };
    }
}

async function saveCompletedGameData(won) {
    const username = localStorage.getItem("gerNordleUsername");
    if (!username || !secret) return;

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const guesses = won ? (currentRow + 1) : -1;
    const userProfileRef = database.ref(`userProfiles/${sanitizedUsername}`);

    try {
        const hostNameRef = database.ref(`games/${secret}/metadata/host`);
        const hostSnapshot = await hostNameRef.once('value');
        const hostName = hostSnapshot.val();

        // --- Step 1: ALWAYS save the result to the player's personal history ---
        // This applies to both the host and regular players.
        const creationDateToSave = new Date().toISOString();
        const finalPlayedGameData = {
            status: won ? 'won' : 'lost',
            guesses: guesses,
            createdDate: creationDateToSave,
            guessHistory: guessHistory,
            colorHistory: colorHistory,
            hintStatus: { hintUsed1, hintUsed2, hintUsed3, hintUsed4 },
            wasHardMode: !hardModeWasDisabled,
            host: hostName
        };
        await userProfileRef.child('playedGames').child(secret).set(finalPlayedGameData);

        // Also ALWAYS update localStorage to mark the game as finished
        const encodedSecret = base64Encode(secret);
        const allGameData = JSON.parse(localStorage.getItem("gerNordleGameData") || "{}");
        if (!allGameData[username]) allGameData[username] = {};
        const finalGameRecord = {
            ...finalPlayedGameData,
            keyColors: keyColors
        };
        delete finalGameRecord.ongoingState;
        allGameData[username][encodedSecret] = finalGameRecord;
        localStorage.setItem("gerNordleGameData", JSON.stringify(allGameData));


        // --- Step 2: ONLY if the player is NOT the host, update public stats and badges ---
        if (username !== hostName) {
            // A) Post score to the game's public scoreboard
            const finalScoreData = {
                username: username,
                guesses: guesses,
                timestamp: new Date().toISOString(),
                hintCount: (hintUsed1 ? 1:0) + (hintUsed2 ? 1:0) + (hintUsed3 ? 1:0) + (hintUsed4 ? 1:0),
                wasHardMode: !hardModeWasDisabled
            };
            const publicScoreUpdates = {};
            publicScoreUpdates[`/games/${secret}/${sanitizedUsername}`] = finalScoreData;
            publicScoreUpdates[`/games/${secret}/players/${sanitizedUsername}`] = null;
            await database.ref().update(publicScoreUpdates);

            // B) Update the user's global stats
            await updateStats(username, won, guesses);

            // C) Process all badge logic
            const profileSnapshot = await userProfileRef.once('value');
            const userProfile = profileSnapshot.val() || {};
            const today = new Date().toDateString();
            const yesterday = new Date(Date.now() - 864e5).toDateString();
            
            let playStreak = userProfile.playStreak || 0;
            let lastPlayed = userProfile.lastPlayedDate;
            if (lastPlayed !== today) {
                playStreak = (lastPlayed === yesterday) ? playStreak + 1 : 1;
                userProfileRef.child('playStreak').set(playStreak);
                userProfileRef.child('lastPlayedDate').set(today);
            }
            if (playStreak >= 7) awardBadge(username, 'daily_dedication');

            if (won) {
                const guessCount = guessHistory.length;
                const guessDistRef = userProfileRef.child('stats/guessDistribution').child(String(guessCount));
                await guessDistRef.transaction(currentCount => (currentCount || 0) + 1);
                
                let winStreak = userProfile.winStreak || 0;
                let lastWin = userProfile.lastWinDate;
                if (lastWin !== today) {
                    winStreak = (lastWin === yesterday) ? winStreak + 1 : 1;
                    userProfileRef.child('winStreak').set(winStreak);
                    userProfileRef.child('lastWinDate').set(today);
                }
                if (winStreak >= 3) awardBadge(username, 'on_a_roll');
                if (winStreak >= 10) awardBadge(username, 'dominating');

                if (customHint1) {
                    const lang = customHint1.trim().toLowerCase();
                    if (SUPPORTED_LANGUAGES.includes(lang)) {
                        await userProfileRef.child('playedLanguages').child(lang).set(true);
                        if (!userProfile.playedLanguages) userProfile.playedLanguages = {};
                        userProfile.playedLanguages[lang] = true;
                    }
                }

                if (userProfile.playedLanguages) {
                    const solvedLangs = new Set(Object.keys(userProfile.playedLanguages));
                    if (solvedLangs.size >= 5) awardBadge(username, 'polyglot');
                    const nativeLang = userProfile.nativeLanguage ? userProfile.nativeLanguage.toLowerCase() : null;
                    if (nativeLang) {
                        const nonNativeLangs = SUPPORTED_LANGUAGES.filter(lang => lang !== nativeLang);
                        if (nonNativeLangs.length >= 4 && nonNativeLangs.every(lang => solvedLangs.has(lang))) {
                            awardBadge(username, 'globetrotter');
                        }
                    }
                }

                if (guessHistory.length === 1) awardBadge(username, 'prodigy');
                if (guessHistory.length <= 2) awardBadge(username, 'genius');
                if (currentRow === rows - 1) awardBadge(username, 'clutch_victory');
                if (!colorHistory.flat().includes('absent')) awardBadge(username, 'flawless');
                const hintsAvailable = customHint1 || customHint2 || customHint3 || customHint4;
                if (hintsAvailable && !(hintUsed1 || hintUsed2 || hintUsed3 || hintUsed4)) awardBadge(username, 'natural_talent');
                if (/[Ã„Ã–Ãœ]/.test(secret)) awardBadge(username, 'umlaut_enthusiast');
                if (/[Ã†Ã˜Ã…]/.test(secret)) awardBadge(username, 'nordic_explorer');
                const uniqueVowels = new Set(secret.toUpperCase().match(/[AEIOU]/g));
                if (uniqueVowels && uniqueVowels.size >= 4) awardBadge(username, 'vowel_virtuoso');
                const currentHour = new Date().getHours();
                if (currentHour >= 0 && currentHour <= 4) awardBadge(username, 'night_owl');
                if (currentHour >= 5 && currentHour <= 8) awardBadge(username, 'early_bird');
                const vowels = new Set(['A', 'E', 'I', 'O', 'U', 'Y', 'Ã„', 'Ã–', 'Ãœ', 'Ã†', 'Ã˜', 'Ã…']);
                if (new Set([...secret].filter(char => !vowels.has(char.toUpperCase()))).size >= 4) {
                    awardBadge(username, 'consonant_crusher');
                }
            } else {
                userProfileRef.child('winStreak').set(0);
            }

            if (hostName && hostName !== username) {
                const playedHostsRef = userProfileRef.child('playedHosts').child(hostName);
                await playedHostsRef.set(true);
                const playedHostsSnapshot = await userProfileRef.child('playedHosts').once('value');
                if (playedHostsSnapshot.numChildren() >= 10) awardBadge(username, 'wortle_wanderer');
                const gamePlayersRef = database.ref(`games/${secret}`);
                const gamePlayersSnapshot = await gamePlayersRef.once('value');
                const data = gamePlayersSnapshot.val() || {};
                const playerCount = Object.keys(data).filter(key => key !== 'metadata' && key !== 'players').length;
                if (playerCount >= 10) awardBadge(hostName, 'crowd_pleaser');
            }
        }

    } catch (error) {
        console.error("Failed to save final game data:", error);
        throw error;
    }
}

async function deleteGame(wordToDelete) {
    if (!confirm(`Are you sure you want to permanently delete the game "${wordToDelete}"? This will remove it from every player's history and stats.`)) {
        return;
    }

    const hostUsername = localStorage.getItem("gerNordleUsername");
    if (!hostUsername) {
        alert("Could not verify user. Deletion failed.");
        return;
    }
    const sanitizedHostUsername = hostUsername.replace(/[.#$[\]]/g, '_');

    try {
        const gameSnapshot = await database.ref('games/' + wordToDelete).once('value');
        const gameData = gameSnapshot.val();

        const allPlayerNames = new Set();

        // --- FIX START ---
        // Unconditionally add the host to the list of players to be cleaned up.
        // This ensures the game is removed from the host's "playedGames" list
        // even if data is inconsistent.
        allPlayerNames.add(sanitizedHostUsername);

        // Now, find all OTHER players from the central game record.
        if (gameData) {
            Object.keys(gameData).forEach(key => {
                if (key !== 'metadata' && key !== 'players') {
                    allPlayerNames.add(key);
                }
            });
            if (gameData.players) {
                Object.keys(gameData.players).forEach(playerName => {
                    allPlayerNames.add(playerName);
                });
            }
        }
        // --- FIX END ---

        const updates = {};
        updates[`/games/${wordToDelete}`] = null;
        updates[`/userProfiles/${sanitizedHostUsername}/hostedGames/${wordToDelete}`] = null;

        allPlayerNames.forEach(sanitizedPlayerName => {
            updates[`/userProfiles/${sanitizedPlayerName}/playedGames/${wordToDelete}`] = null;
        });

        await database.ref().update(updates);

        // This check is needed because we might not have gameData if the record was already partially deleted.
        if (gameData) {
            const statPromises = [];
            allPlayerNames.forEach(sanitizedPlayerName => {
                const scoreData = gameData[sanitizedPlayerName];
                if (scoreData) {
                    const wasWin = scoreData.guesses > 0;
                    const guessesInGame = wasWin ? scoreData.guesses : 0;

                    const statRef = database.ref(`/userProfiles/${sanitizedPlayerName}/stats`);
                    const statPromise = statRef.transaction(currentStats => {
                        if (currentStats) {
                            currentStats.gamesPlayed = (currentStats.gamesPlayed || 0) - 1;
                            if (currentStats.gamesPlayed < 0) currentStats.gamesPlayed = 0;

                            if (wasWin) {
                                currentStats.wins = (currentStats.wins || 0) - 1;
                                if (currentStats.wins < 0) currentStats.wins = 0;

                                currentStats.totalGuesses = (currentStats.totalGuesses || 0) - guessesInGame;
                                if (currentStats.totalGuesses < 0) currentStats.totalGuesses = 0;
                                
                                // âœ… ADD THIS BLOCK TO UPDATE THE GUESS DISTRIBUTION
                                const guessCountKey = String(guessesInGame);
                                if (
                                    currentStats.guessDistribution &&
                                    currentStats.guessDistribution[guessCountKey] &&
                                    currentStats.guessDistribution[guessCountKey] > 0
                                ) {
                                    currentStats.guessDistribution[guessCountKey]--;
                                }
                            }
                        }
                        return currentStats;
                    });
                    statPromises.push(statPromise);
                }
            });

            if (statPromises.length > 0) {
                await Promise.all(statPromises);
            }
        }

        if (wordToDelete === secret) {
            window.location.reload();
        }

    } catch (error) {
        console.error("Comprehensive deletion failed:", error);
        alert("An error occurred while trying to delete the game. Please try again.");
    }
}

// This function handles closing the popup when the user starts typing a guess.
function handleTypingToClose(event) {
    // Check if the key pressed is a valid letter for the game.
    if (/^[a-zA-ZÃ„Ã–ÃœÃ¤Ã¶Ã¼ÃŸáºÃ†Ã˜Ã…Ã¦Ã¸Ã¥]$/.test(event.key)) {
        hideHintPopup();
    }
}

async function loadCompletedGame(playedGameData) {
    const savedUsername = localStorage.getItem("gerNordleUsername");
    if (!savedUsername) return;

    const headerSetup = document.getElementById("header-setup");
    const gameElement = document.getElementById("game");

    setupUsernameInterface({
        isGamePage: true,
        containerId: 'setup-username-area',
        inputId: 'usernameInputGame',
        placeholder: 'Enter username'
    });

    initBoard();
    initKeyboard();

    const isSolved = playedGameData.status === 'won';
    document.getElementById("message").textContent = isSolved ? "You already solved this WÃ¸rtle! ğŸ¥³" : "You have already played this WÃ¸rtle.";

    const reconstructedKeyColors = {};
    if (playedGameData.guessHistory && playedGameData.colorHistory) {
        for (let i = 0; i < playedGameData.guessHistory.length; i++) {
            const guess = playedGameData.guessHistory[i];
            const colors = playedGameData.colorHistory[i];
            for (let j = 0; j < guess.length; j++) {
                const letter = guess[j];
                const color = colors[j];
                if (!reconstructedKeyColors[letter] || (color === 'correct') || (color === 'present' && reconstructedKeyColors[letter] === 'absent')) {
                    reconstructedKeyColors[letter] = color;
                }
            }
        }
    }
    keyColors = reconstructedKeyColors;
    updateKeyboardColors();

    // --- ADD THIS BLOCK TO RESTORE HINT STATUS ---
    // Read the saved hint status and set the global variables.
    const hintStatus = playedGameData.hintStatus || {};
    hintUsed1 = hintStatus.hintUsed1 || false;
    hintUsed2 = hintStatus.hintUsed2 || false;
    hintUsed3 = hintStatus.hintUsed3 || false;
    hintUsed4 = hintStatus.hintUsed4 || false;
    // Set expanded state for the UI to correctly show the hint text
    hintExpanded1 = hintUsed1;
    hintExpanded2 = hintUsed2;
    hintExpanded3 = hintUsed3;
    hintExpanded4 = hintUsed4;
    // --- END OF NEW BLOCK ---

    updateHintButtons(); // Now this will show the correct used hints

    const board = document.getElementById('board');
    board.innerHTML = generateGuessHistoryHTML(playedGameData.guessHistory, playedGameData.colorHistory);
    board.style.gridTemplateRows = 'none';
    
    const toggle = document.getElementById('hard-mode-toggle');
    if (toggle) {
        // --- THIS IS THE CORRECTED LINE ---
        // If 'wasHardMode' is missing (undefined), this check will be true, keeping the toggle on.
        // It will only be turned off if the value is explicitly false.
        toggle.checked = playedGameData.wasHardMode !== false;
        toggle.disabled = true;
    }

    let funFactForModal = "";
    try {
        const metadataRef = database.ref(`games/${secret}/metadata`);
        const metaSnapshot = await metadataRef.once('value');
        if (metaSnapshot.exists()) {
            funFactForModal = metaSnapshot.val().funFact || "";
        }
    } catch (error) {
        console.error("Could not fetch metadata for modal:", error);
    }
    
    showGameOverModal(isSolved, playedGameData.guessHistory, playedGameData.colorHistory, playedGameData.hintStatus, funFactForModal);
    disableKeyboard();  

    headerSetup.style.display = 'flex';
    gameElement.style.display = 'flex';
}

function loadOngoingGame(playedGameData) {
Â  Â  const savedUsername = localStorage.getItem("gerNordleUsername");
Â  Â  if (!savedUsername) return;

Â  Â  const headerSetup = document.getElementById("header-setup");
Â  Â  const gameElement = document.getElementById("game");

Â  Â  // Use the new unified header logic
Â  Â  setupUsernameInterface({
Â  Â  Â  Â  isGamePage: true,
Â  Â  Â  Â  containerId: 'setup-username-area',
Â  Â  Â  Â  inputId: 'usernameInputGame',
Â  Â  Â  Â  placeholder: 'Enter username'
Â  Â  });

    isHardMode = playedGameData.isHardMode !== false;
    hardModeWasDisabled = playedGameData.hardModeWasDisabled || false;
         const toggle = document.getElementById('hard-mode-toggle');
    if (toggle) {
        toggle.checked = isHardMode;

        // --- ADD THIS LOGIC ---
        // If hard mode was ever disabled in this saved game,
        // make sure the toggle is disabled when the page loads.
        if (hardModeWasDisabled) {
            toggle.disabled = true;
        }
    }

Â  Â  initBoard();
Â  Â  initKeyboard();

Â  Â  // Restore all game variables from the passed-in Firebase data.
Â  Â  usernameSet = true;
Â  Â  grid = playedGameData.grid;
Â  Â  currentRow = playedGameData.currentRow;
Â  Â  guessHistory = playedGameData.guessHistory || [];
Â  Â  colorHistory = playedGameData.colorHistory || [];
Â  Â  keyColors = playedGameData.keyColors || {};
Â  Â Â 
Â  Â  const hintStatus = playedGameData.hintStatus || {};
Â  Â  hintUsed1 = hintStatus.hintUsed1;
Â  Â  hintUsed2 = hintStatus.hintUsed2;
Â  Â  hintUsed3 = hintStatus.hintUsed3;
Â  Â  hintUsed4 = hintStatus.hintUsed4;
Â  Â  hintExpanded1 = hintStatus.hintExpanded1 || false;
Â  Â  hintExpanded2 = hintStatus.hintExpanded2 || false;
Â  Â  hintExpanded3 = hintStatus.hintExpanded3 || false;
Â  Â  hintExpanded4 = hintStatus.hintExpanded4 || false;
Â  Â  currentCol = 0;
Â  Â Â 
Â  Â  // Apply the restored state to the UI.
Â  Â  updateBoard();
Â  Â  if (Array.isArray(colorHistory)) {
Â  Â  Â  Â  for (let r = 0; r < colorHistory.length; r++) {
Â  Â  Â  Â  Â  Â  const colors = colorHistory[r];
Â  Â  Â  Â  Â  Â  const rowDiv = document.getElementById("board").children[r];
Â  Â  Â  Â  Â  Â  if (Array.isArray(colors) && rowDiv) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let c = 0; c < cols; c++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (rowDiv.children[c] && typeof colors[c] === 'string') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rowDiv.children[c].classList.add(colors[c]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  updateKeyboardColors();
Â  Â  updateHintButtons();
Â  Â Â 
Â  Â  gameElement.classList.remove("dimmed");
Â  Â  headerSetup.style.display = 'flex';
Â  Â  gameElement.style.display = 'flex';
}

function renderAccountStats(snapshot) {
    const statsSection = document.getElementById('account-stats-section');
    const graphContainer = document.getElementById('account-graph-container');
    if (!statsSection || !graphContainer) return;

    const stats = snapshot.val() || {};
    const winPct = (stats.gamesPlayed > 0) ? ((stats.wins / stats.gamesPlayed) * 100).toFixed(1) : "0.0";
    
    // Render the main stats (Played, Wins, etc.)
    statsSection.innerHTML = `
        <div class="stat-item">
            <span class="stat-value">${stats.gamesPlayed || 0}</span>
            <span class="stat-label">Played</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${stats.wins || 0}</span>
            <span class="stat-label">Wins</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${winPct}%</span>
            <span class="stat-label">Win %</span>
        </div>
    `;

    // âœ… Call the reusable function to render the graph. That's all you need!
    renderGuessDistribution(graphContainer, stats.guessDistribution, null);
}

function showToast(message, type = '') {
    const container = document.getElementById('toast-container');
    if (!container) return;

    // Create the toast element
    const toastElement = document.createElement('div');
    toastElement.className = 'toast';
    if (type) {
        toastElement.classList.add(type);
    }
    toastElement.textContent = message;

    // Add it to the container
    container.appendChild(toastElement);

    // Set a timer to remove the toast after its animation finishes
    setTimeout(() => {
        toastElement.remove();
    }, 3000); // 3000ms = 3 seconds
}

async function displayHostCredit() {
    const creditElement = document.getElementById('host-credit');
    if (!secret || !creditElement) return;

    try {
        // âœ… Change the reference to get all metadata, not just the host
        const metadataRef = database.ref(`games/${secret}/metadata`);
        const snapshot = await metadataRef.once('value');

        if (snapshot.exists()) {
            const metadata = snapshot.val();
            const hostName = metadata.host;
            const shortUrl = metadata.shortUrl; // Get the shortUrl

            // Clear any previous content
            creditElement.innerHTML = ''; 

            // Display the host credit
            creditElement.textContent = `WÃ¸rtle by: ${hostName}`;

            // âœ… If a TinyURL exists, create and display the link
            if (shortUrl) {
                const urlElement = document.createElement('div'); // Use a div for a new line
                urlElement.style.marginTop = '5px';
                urlElement.innerHTML = `Share this game: <a href="${shortUrl}" target="_blank" style="color: #5c7a98;">${shortUrl}</a>`;
                creditElement.appendChild(urlElement);
            }
        }
    } catch (error) {
        console.error("Could not fetch host credit:", error);
    }
}
/**
 * Awards a badge to a user if they haven't already earned it.
 * @param {string} username The user who earned the badge.
 * @param {string} badgeId The ID of the badge (e.g., 'genius').
 */
async function awardBadge(username, badgeId) {
    if (!username || !BADGE_DEFINITIONS[badgeId]) return;

    const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
    const badgeRef = database.ref(`userProfiles/${sanitizedUsername}/badges/${badgeId}`);

    try {
        const snapshot = await badgeRef.once('value');
        if (!snapshot.exists()) {
            await badgeRef.set(true);
            // Show a notification to the user!
            const badgeName = BADGE_DEFINITIONS[badgeId].name;
            showToast(`Badge Unlocked: ${badgeName}`);
        }
    } catch (error) {
        console.error(`Could not award badge ${badgeId}:`, error);
    }
}
/**
 * Renders a Wordle-style guess distribution graph inside a given container.
 * @param {HTMLElement} containerElement - The div where the graph should be drawn.
 * @param {object} distributionData - The user's guessDistribution stats.
 * @param {number|null} highlightRow - The row number (1-8) to highlight (optional).
 */
function renderGuessDistribution(containerElement, distributionData, highlightRow = null) {
    if (!containerElement) return;

    containerElement.innerHTML = '<h3>My Guesses</h3>';

    const distribution = distributionData || {};
    const values = Object.values(distribution);
    const maxValue = values.length > 0 ? Math.max(...values) : 1;

    for (let i = 1; i <= rows; i++) {
        const count = distribution[i] || 0;
        const row = document.createElement('div');
        row.className = 'graph-row';

        let barHtml = '';
        if (count > 0) {
            const percentage = (count / maxValue) * 100;
            const highlightClass = (i === highlightRow) ? 'highlight' : '';
            barHtml = `<div class="graph-bar ${highlightClass}" style="width: ${percentage}%">${count}</div>`;
        } else {
            barHtml = `<div class="zero-count">0</div>`;
        }

        row.innerHTML = `<div class="graph-label">${i}</div>${barHtml}`;
        containerElement.appendChild(row);
    }
}
function handleGiveUp() {
    if (isAnimating) return;

    // âœ… This new block checks if a guess has been made
    if (guessHistory.length === 0) {
        showToast("You must make at least one guess before giving up.", "error");
        return; // Stop the function here
    }

    // This part now only runs if the player has made a guess
    if (window.confirm("Are you sure you want to end the game?")) {
        endGame(false);
    }
}

/**
 * Shows a popup to collect the user's native language after registration.
 * @param {string} username The newly registered user's name.
 */
function showLanguagePopup(username, shouldReload = false) {
    const overlay = document.getElementById('language-popup-overlay');
    const popup = document.getElementById('language-popup');
    const title = document.getElementById('language-popup-title');
    const saveBtn = document.getElementById('language-popup-save-btn');
    const languageInput = document.getElementById('language-popup-input');

    languageInput.value = "";
    setInputsDisabled(true);
    isModalOpen = true;
    title.textContent = `Welcome, ${username}!`;
    
    overlay.classList.add('show');
    popup.classList.add('show');
    languageInput.focus();
    
    saveBtn.onclick = async () => {
        const selectedValue = languageInput.value;
        
        if (!selectedValue) {
            showToast('Please select an option from the list.', 'error');
            return;
        }
        
        // --- START: MODIFIED SAVE LOGIC ---
        // Only save to Firebase if the user selected a specific language.
        if (selectedValue !== 'other') {
            const formattedLanguage = selectedValue.charAt(0).toUpperCase() + selectedValue.slice(1);
            const sanitizedUsername = username.replace(/[.#$[\]]/g, '_');
            const profileRef = database.ref(`userProfiles/${sanitizedUsername}`);
            try {
                await profileRef.update({ nativeLanguage: formattedLanguage });
                showToast('Profile updated!', 'success');
            } catch (error) {
                console.error("Could not save native language:", error);
                showToast('Could not save language.', 'error');
            }
        }
        // If "Other" is selected, this block is skipped, and nothing is saved.
        // --- END: MODIFIED SAVE LOGIC ---
        
        closeLanguagePopup();
        
        if (shouldReload) {
            window.location.reload();
        }
    };
}
/**
 * Converts a two-letter country code into a flag emoji.
 * @param {string} countryCode The uppercase, two-letter country code (e.g., "US").
 * @returns {string} The flag emoji.
 */
function getFlagEmoji(countryCode) {
  const codePoints = countryCode
    .toUpperCase()
    .split('')
    .map(char => 127397 + char.charCodeAt());
  return String.fromCodePoint(...codePoints);
}

/**
 * Cycles through the available languages for the secret word.
 */
function switchLanguage() {
  if (availableLanguagesForWord.length <= 1) {
    return;
  }

  // Move to the next language, looping back to the start if needed
  currentLanguageIndex = (currentLanguageIndex + 1) % availableLanguagesForWord.length;

  const newLanguage = availableLanguagesForWord[currentLanguageIndex];
  const langInput = document.getElementById('hintInput');

  // Update the input field with the new language
  langInput.value = newLanguage.charAt(0).toUpperCase() + newLanguage.slice(1);

  // Save the new state to local storage
  saveSetupState();
}

// ADD THESE NEW FUNCTIONS TO YOUR MAIN SCRIPT

function showGameScoreboard(word) {
    isModalOpen = true;
    document.getElementById('game-scoreboard-overlay').classList.add('show');
    document.getElementById('game-scoreboard-popup').classList.add('show');
    
    const title = document.getElementById('game-scoreboard-title');
    title.innerHTML = `Scoreboard for <span style="color:var(--accent-color);">${word}</span>`;

    populateGameScoreboard(word);
}

function closeGameScoreboard() {
    isModalOpen = false;
    document.getElementById('game-scoreboard-overlay').classList.remove('show');
    document.getElementById('game-scoreboard-popup').classList.remove('show');
}

async function populateGameScoreboard(word) {
    const container = document.getElementById('game-scoreboard-content');
    container.innerHTML = '<div class="spinner"></div>';

    try {
        const gameRef = database.ref('games/' + word);
        const snapshot = await gameRef.once('value');
        const scoresData = snapshot.val();

        if (!scoresData) {
            container.innerHTML = '<p>No scores found for this game yet.</p>';
            return;
        }

        const playerScores = Object.keys(scoresData)
            .filter(key => key !== 'metadata' && key !== 'players')
            .map(key => scoresData[key]);

        if (playerScores.length === 0) {
            container.innerHTML = '<p>No one has won this WÃ¸rtle yet.</p>';
            return;
        }
        
        playerScores.sort((a, b) => {
            if (a.guesses === -1) return 1; // Move losses to the bottom
            if (b.guesses === -1) return -1;
            return a.guesses - b.guesses || (a.hintCount || 0) - (b.hintCount || 0);
        });

        let tableHTML = `<table class="scoreboard-table" style="width:100%; font-size:11pt;"><thead><tr><th>Rank</th><th>Player</th><th>Guesses</th><th>Hints</th></tr></thead><tbody>`;

        playerScores.forEach((score, index) => {
            const guessDisplay = score.guesses > 0 ? score.guesses : 'X';
            tableHTML += `<tr>
                <td>${index + 1}</td>
                <td>${score.username}</td>
                <td>${guessDisplay}</td>
                <td>${score.hintCount || 0}</td>
            </tr>`;
        });

        tableHTML += `</tbody></table>`;
        container.innerHTML = tableHTML;

    } catch (error) {
        console.error("Error loading game scoreboard:", error);
        container.innerHTML = '<p>Could not load scores for this game.</p>';
    }
}
function closeLanguagePopup() {
    isModalOpen = false;
    document.getElementById('language-popup-overlay').classList.remove('show');
    document.getElementById('language-popup').classList.remove('show');
    // Re-enable all inputs on the main page
    setInputsDisabled(false);
}

/**
 * Populates the language dropdown menu from the validLanguages Set.
 */
function populateLanguageDropdown() {
    const dropdown = document.getElementById('language-popup-input');
    if (!dropdown) return;

    // Sort languages alphabetically
    const sortedLanguages = [...validLanguages].sort();

    sortedLanguages.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang; // e.g., "danish"
        // Capitalize the first letter for display
        option.textContent = lang.charAt(0).toUpperCase() + lang.slice(1);
        dropdown.appendChild(option);
    });

    // --- ADD THIS PART ---
    // Add the "Other" option at the end of the list
    const otherOption = document.createElement('option');
    otherOption.value = 'other';
    otherOption.textContent = 'None of the above';
    dropdown.appendChild(otherOption);
    // ---------------------
}

// Call the function once when the script loads
populateLanguageDropdown();

// --- START: CLICK-OUTSIDE-TO-CLOSE LOGIC ---

/**
 * Attaches event listeners to an overlay to close its corresponding popup.
 * Also prevents clicks inside the popup from closing it.
 * @param {string} overlayId The ID of the overlay element.
 * @param {string} popupId The ID of the popup/modal element.
 * @param {Function} closeFunction The function to call to close the popup.
 */
function setupPopupCloseEvents(overlayId, popupId, closeFunction) {
    const overlay = document.getElementById(overlayId);
    const popup = document.getElementById(popupId);

    if (overlay) {
        // When the overlay is clicked, call the close function.
        overlay.addEventListener('click', closeFunction);
    }
    
    if (popup) {
        // This stops a click on the popup itself from "bubbling up"
        // to the overlay and closing the popup unintentionally.
        popup.addEventListener('click', (event) => {
            event.stopPropagation();
        });
    }
}

// Set up the "click outside" functionality for all your popups and sidebars
setupPopupCloseEvents('game-over-overlay', 'game-over-modal', closeGameOverModal);
setupPopupCloseEvents('language-popup-overlay', 'language-popup', closeLanguagePopup);
setupPopupCloseEvents('game-scoreboard-overlay', 'game-scoreboard-popup', closeGameScoreboard);

// --- END: CLICK-OUTSIDE-TO-CLOSE LOGIC ---

// --- ADD THIS BLOCK TO THE END OF YOUR SCRIPT ---
const hardModeToggle = document.getElementById('hard-mode-toggle');
if (hardModeToggle) {
    hardModeToggle.addEventListener('change', (event) => {
        const isEnabling = event.target.checked;
        if (isEnabling) {
            isHardMode = true;
        } else {
            // If turning off, ask for confirmation
            if (window.confirm("Are you sure you want to turn off hard mode? This cannot be undone for this game.")) {
                isHardMode = false;
                hardModeWasDisabled = true;
                event.target.disabled = true;

                // NEW: Disable the toggle to make the choice permanent
                event.target.disabled = true;

            } else {
                event.target.checked = true; // User cancelled, revert the toggle
            }
        }
        if (window.currentUsername && secret) {
            saveOngoingGame(window.currentUsername, base64Encode(secret));
        }
    });
}

</script>
</body>
</html>
